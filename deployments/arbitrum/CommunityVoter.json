{
  "address": "0x73128419AD185562fFBfDd9eEB71d151950423fE",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_quorumVotes",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "_merkleRoot",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "_blockTimestampVotingEnd",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "numberOfVotes",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "yesVote",
          "type": "bool"
        }
      ],
      "name": "Voted",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "blockTimestampVotingEnd",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_index",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_numberOfVotes",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "_yesVote",
          "type": "bool"
        },
        {
          "internalType": "bytes32[]",
          "name": "_merkleProof",
          "type": "bytes32[]"
        }
      ],
      "name": "castVote",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "hasTokenIdVoted",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "hasVoted",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "merkleRoot",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "noVoteCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "quorumVotes",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "yesVoteCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x658b7336df0785afeef5eea3b8bb040d8fd9e401fbac7570f75ef49f15f30b5b",
  "receipt": {
    "to": null,
    "from": "0xF8F6B70a36f4398f0853a311dC6699Aba8333Cc1",
    "contractAddress": "0x73128419AD185562fFBfDd9eEB71d151950423fE",
    "transactionIndex": 2,
    "gasUsed": "3148957",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x91f97a9572e1ffe6585a90b3c5705b249023ae7577bdd25b6bb54d96ccd33e55",
    "transactionHash": "0x658b7336df0785afeef5eea3b8bb040d8fd9e401fbac7570f75ef49f15f30b5b",
    "logs": [],
    "blockNumber": 119667573,
    "cumulativeGasUsed": "3562491",
    "status": 1,
    "byzantium": true
  },
  "args": [
    2949,
    "0x6ed1e37fd73c15d1be19a88a6404d911e85bfd5d1477fa73a0b9a00332b8530a",
    1691755200
  ],
  "numDeployments": 2,
  "solcInputHash": "78e42726ae422344af467a4e32a48513",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_quorumVotes\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_blockTimestampVotingEnd\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numberOfVotes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"yesVote\",\"type\":\"bool\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"blockTimestampVotingEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numberOfVotes\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_yesVote\",\"type\":\"bool\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"castVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hasTokenIdVoted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"hasVoted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"noVoteCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quorumVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yesVoteCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"castVote(uint256,uint256,bool,bytes32[])\":{\"params\":{\"_index\":\"index of the voter\",\"_merkleProof\":\"merkle proof that needs to be verified against the merkle root to check the msg.sender against the snapshot\",\"_numberOfVotes\":\"number of voltz nfts and sbts held by the msg.sender before the snapshot was taken\",\"_yesVote\":\"if this boolean is true then the msg.sender is casting a yes vote, if the boolean is false the msg.sender is casting a no vote\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"blockTimestampVotingEnd()\":{\"notice\":\"voting end block timestamp (once this contract is deployed, voting is considered to be officially started)\"},\"castVote(uint256,uint256,bool,bytes32[])\":{\"notice\":\"Vote for the proposal\"},\"hasTokenIdVoted(uint256)\":{\"notice\":\"mapping of voltz genesis token ids to a boolean, if true that means the token id has already voted\"},\"noVoteCount()\":{\"notice\":\"Total number of votes against the deployment of voltz protocol\"},\"quorumVotes()\":{\"notice\":\"The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\"},\"yesVoteCount()\":{\"notice\":\"Total number of votes in favour of deploying voltz protocol\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/voter/CommunityVoter.sol\":\"CommunityVoter\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\\n     * consuming from one or the other at each step according to the instructions given by\\n     * `proofFlags`.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x596ed72a251d391b814a4aa19d7acb02ebdcc92ba27d3fff74a6f0c158b12ab7\",\"license\":\"MIT\"},\"contracts/voter/CommunityVoter.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity =0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\ncontract CommunityVoter {\\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\\n    uint256 public quorumVotes;\\n\\n    /// @notice Total number of votes in favour of deploying voltz protocol\\n    uint256 public yesVoteCount;\\n\\n    /// @notice Total number of votes against the deployment of voltz protocol\\n    uint256 public noVoteCount;\\n\\n    /// @notice mapping of voltz genesis token ids to a boolean, if true that means the token id has already voted\\n    mapping(uint256 => bool) public hasTokenIdVoted;\\n\\n    /// @notice voting end block timestamp (once this contract is deployed, voting is considered to be officially started)\\n    uint256 public blockTimestampVotingEnd;\\n\\n    // Merkle Tree\\n    bytes32 public merkleRoot;\\n\\n    // This is a packed array of booleans.\\n    mapping(uint256 => uint256) private votedBitMap;\\n\\n    // This event is triggered whenever a call to cast a vote succeeds\\n    event Voted(\\n        uint256 index,\\n        address account,\\n        uint256 numberOfVotes,\\n        bool yesVote\\n    );\\n\\n    constructor(\\n        uint256 _quorumVotes,\\n        bytes32 _merkleRoot,\\n        uint256 _blockTimestampVotingEnd\\n    ) {\\n        blockTimestampVotingEnd = _blockTimestampVotingEnd;\\n        quorumVotes = _quorumVotes;\\n        merkleRoot = _merkleRoot;\\n    }\\n\\n    function hasVoted(uint256 index) public view returns (bool) {\\n        uint256 votedWordIndex = index / 256;\\n        uint256 votedBitIndex = index % 256;\\n        uint256 votedWord = votedBitMap[votedWordIndex];\\n        uint256 mask = (1 << votedBitIndex);\\n        return votedWord & mask == mask;\\n    }\\n\\n    function _setVoted(uint256 index) private {\\n        uint256 votedWordIndex = index / 256;\\n        uint256 votedBitIndex = index % 256;\\n        votedBitMap[votedWordIndex] =\\n            votedBitMap[votedWordIndex] |\\n            (1 << votedBitIndex);\\n    }\\n\\n    /// @notice Vote for the proposal\\n    /// @param _index index of the voter\\n    /// @param _numberOfVotes number of voltz nfts and sbts held by the msg.sender before the snapshot was taken\\n    /// @param _yesVote if this boolean is true then the msg.sender is casting a yes vote, if the boolean is false the msg.sender is casting a no vote\\n    /// @param _merkleProof merkle proof that needs to be verified against the merkle root to check the msg.sender against the snapshot\\n    function castVote(\\n        uint256 _index,\\n        uint256 _numberOfVotes,\\n        bool _yesVote,\\n        bytes32[] calldata _merkleProof\\n    ) external {\\n        require(\\n            block.timestamp <= blockTimestampVotingEnd,\\n            \\\"voting period over\\\"\\n        );\\n\\n        // check if msg.sender has already voted\\n        require(!hasVoted(_index), \\\"duplicate vote\\\");\\n\\n        // verify the merkle proof\\n        bytes32 _node = keccak256(\\n            abi.encodePacked(_index, msg.sender, _numberOfVotes)\\n        );\\n        require(\\n            MerkleProof.verify(_merkleProof, merkleRoot, _node),\\n            \\\"invalid merkle proof\\\"\\n        );\\n\\n        // mark hasVoted\\n        _setVoted(_index);\\n\\n        // cast the vote\\n        if (_yesVote) {\\n            yesVoteCount += _numberOfVotes;\\n        } else {\\n            noVoteCount += _numberOfVotes;\\n        }\\n\\n        // emit an event\\n        emit Voted(_index, msg.sender, _numberOfVotes, _yesVote);\\n    }\\n}\\n\",\"keccak256\":\"0xb63caedc16d43c44d3e50f4ae15c1aa9963c605522a86d9cfc6c9e7ac62c3db0\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5060405161062238038061062283398101604081905261002f91610040565b60045560009190915560055561006e565b60008060006060848603121561005557600080fd5b8351925060208401519150604084015190509250925092565b6105a58061007d6000396000f3fe608060405234801561001057600080fd5b50600436106100785760003560e01c806324bc1a641461007d5780632eb4a7ab1461009957806344a0b3e7146100a2578063916e62f3146100ab57806392c7abb7146100b4578063b4395f83146100c9578063b8f2145f146100d2578063ecca031f14610105575b600080fd5b61008660005481565b6040519081526020015b60405180910390f35b61008660055481565b61008660015481565b61008660025481565b6100c76100c236600461041c565b610118565b005b61008660045481565b6100f56100e03660046104b9565b60036020526000908152604090205460ff1681565b6040519015158152602001610090565b6100f56101133660046104b9565b610308565b6004544211156101645760405162461bcd60e51b81526020600482015260126024820152713b37ba34b733903832b934b7b21037bb32b960711b60448201526064015b60405180910390fd5b61016d85610308565b156101ab5760405162461bcd60e51b815260206004820152600e60248201526d6475706c696361746520766f746560901b604482015260640161015b565b60408051602081018790526001600160601b03193360601b169181019190915260548101859052600090607401604051602081830303815290604052805190602001209050610231838380806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250506005549150849050610349565b6102745760405162461bcd60e51b815260206004820152601460248201527334b73b30b634b21036b2b935b63290383937b7b360611b604482015260640161015b565b61027d8661035f565b83156102a057846001600082825461029591906104e8565b909155506102b89050565b84600260008282546102b291906104e8565b90915550505b6040805187815233602082015290810186905284151560608201527fb7086a9dd618ffa688aa9500720dfe31d3b288daba445664cecceaed4a1562c39060800160405180910390a1505050505050565b60008061031761010084610516565b905060006103276101008561052a565b60009283526006602052604090922054600190921b9182169091149392505050565b600082610356858461039d565b14949350505050565b600061036d61010083610516565b9050600061037d6101008461052a565b6000928352600660205260409092208054600190931b9092179091555050565b600081815b84518110156103e2576103ce828683815181106103c1576103c161053e565b60200260200101516103ea565b9150806103da81610554565b9150506103a2565b509392505050565b6000818310610406576000828152602084905260409020610415565b60008381526020839052604090205b9392505050565b60008060008060006080868803121561043457600080fd5b85359450602086013593506040860135801515811461045257600080fd5b925060608601356001600160401b038082111561046e57600080fd5b818801915088601f83011261048257600080fd5b81358181111561049157600080fd5b8960208260051b85010111156104a657600080fd5b9699959850939650602001949392505050565b6000602082840312156104cb57600080fd5b5035919050565b634e487b7160e01b600052601160045260246000fd5b600082198211156104fb576104fb6104d2565b500190565b634e487b7160e01b600052601260045260246000fd5b60008261052557610525610500565b500490565b60008261053957610539610500565b500690565b634e487b7160e01b600052603260045260246000fd5b6000600019821415610568576105686104d2565b506001019056fea26469706673582212204f082e7e91bab44de4fce560a615cb025a0d81f23c329a10c0fc0aff7ed72aad64736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100785760003560e01c806324bc1a641461007d5780632eb4a7ab1461009957806344a0b3e7146100a2578063916e62f3146100ab57806392c7abb7146100b4578063b4395f83146100c9578063b8f2145f146100d2578063ecca031f14610105575b600080fd5b61008660005481565b6040519081526020015b60405180910390f35b61008660055481565b61008660015481565b61008660025481565b6100c76100c236600461041c565b610118565b005b61008660045481565b6100f56100e03660046104b9565b60036020526000908152604090205460ff1681565b6040519015158152602001610090565b6100f56101133660046104b9565b610308565b6004544211156101645760405162461bcd60e51b81526020600482015260126024820152713b37ba34b733903832b934b7b21037bb32b960711b60448201526064015b60405180910390fd5b61016d85610308565b156101ab5760405162461bcd60e51b815260206004820152600e60248201526d6475706c696361746520766f746560901b604482015260640161015b565b60408051602081018790526001600160601b03193360601b169181019190915260548101859052600090607401604051602081830303815290604052805190602001209050610231838380806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250506005549150849050610349565b6102745760405162461bcd60e51b815260206004820152601460248201527334b73b30b634b21036b2b935b63290383937b7b360611b604482015260640161015b565b61027d8661035f565b83156102a057846001600082825461029591906104e8565b909155506102b89050565b84600260008282546102b291906104e8565b90915550505b6040805187815233602082015290810186905284151560608201527fb7086a9dd618ffa688aa9500720dfe31d3b288daba445664cecceaed4a1562c39060800160405180910390a1505050505050565b60008061031761010084610516565b905060006103276101008561052a565b60009283526006602052604090922054600190921b9182169091149392505050565b600082610356858461039d565b14949350505050565b600061036d61010083610516565b9050600061037d6101008461052a565b6000928352600660205260409092208054600190931b9092179091555050565b600081815b84518110156103e2576103ce828683815181106103c1576103c161053e565b60200260200101516103ea565b9150806103da81610554565b9150506103a2565b509392505050565b6000818310610406576000828152602084905260409020610415565b60008381526020839052604090205b9392505050565b60008060008060006080868803121561043457600080fd5b85359450602086013593506040860135801515811461045257600080fd5b925060608601356001600160401b038082111561046e57600080fd5b818801915088601f83011261048257600080fd5b81358181111561049157600080fd5b8960208260051b85010111156104a657600080fd5b9699959850939650602001949392505050565b6000602082840312156104cb57600080fd5b5035919050565b634e487b7160e01b600052601160045260246000fd5b600082198211156104fb576104fb6104d2565b500190565b634e487b7160e01b600052601260045260246000fd5b60008261052557610525610500565b500490565b60008261053957610539610500565b500690565b634e487b7160e01b600052603260045260246000fd5b6000600019821415610568576105686104d2565b506001019056fea26469706673582212204f082e7e91bab44de4fce560a615cb025a0d81f23c329a10c0fc0aff7ed72aad64736f6c63430008090033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "castVote(uint256,uint256,bool,bytes32[])": {
        "params": {
          "_index": "index of the voter",
          "_merkleProof": "merkle proof that needs to be verified against the merkle root to check the msg.sender against the snapshot",
          "_numberOfVotes": "number of voltz nfts and sbts held by the msg.sender before the snapshot was taken",
          "_yesVote": "if this boolean is true then the msg.sender is casting a yes vote, if the boolean is false the msg.sender is casting a no vote"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "blockTimestampVotingEnd()": {
        "notice": "voting end block timestamp (once this contract is deployed, voting is considered to be officially started)"
      },
      "castVote(uint256,uint256,bool,bytes32[])": {
        "notice": "Vote for the proposal"
      },
      "hasTokenIdVoted(uint256)": {
        "notice": "mapping of voltz genesis token ids to a boolean, if true that means the token id has already voted"
      },
      "noVoteCount()": {
        "notice": "Total number of votes against the deployment of voltz protocol"
      },
      "quorumVotes()": {
        "notice": "The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed"
      },
      "yesVoteCount()": {
        "notice": "Total number of votes in favour of deploying voltz protocol"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 35556,
        "contract": "contracts/voter/CommunityVoter.sol:CommunityVoter",
        "label": "quorumVotes",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 35559,
        "contract": "contracts/voter/CommunityVoter.sol:CommunityVoter",
        "label": "yesVoteCount",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 35562,
        "contract": "contracts/voter/CommunityVoter.sol:CommunityVoter",
        "label": "noVoteCount",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 35567,
        "contract": "contracts/voter/CommunityVoter.sol:CommunityVoter",
        "label": "hasTokenIdVoted",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_uint256,t_bool)"
      },
      {
        "astId": 35570,
        "contract": "contracts/voter/CommunityVoter.sol:CommunityVoter",
        "label": "blockTimestampVotingEnd",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 35572,
        "contract": "contracts/voter/CommunityVoter.sol:CommunityVoter",
        "label": "merkleRoot",
        "offset": 0,
        "slot": "5",
        "type": "t_bytes32"
      },
      {
        "astId": 35576,
        "contract": "contracts/voter/CommunityVoter.sol:CommunityVoter",
        "label": "votedBitMap",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_uint256,t_uint256)"
      }
    ],
    "types": {
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_uint256,t_bool)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}