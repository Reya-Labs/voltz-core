{
  "address": "0xFa9DDF4569206625370D2A8546f42c1CC924063c",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "AmountSignsSame",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CannotLiquidate",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CannotSettleBeforeMaturity",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidMarginDelta",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MarginLessThanMinimum",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MarginRequirementNotMet",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OnlyFCM",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OnlyOwnerCanUpdatePosition",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OnlyVAMM",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PRBMathSD59x18__DivInputTooSmall",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "rAbs",
          "type": "uint256"
        }
      ],
      "name": "PRBMathSD59x18__DivOverflow",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "x",
          "type": "int256"
        }
      ],
      "name": "PRBMathSD59x18__Exp2InputTooBig",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "x",
          "type": "int256"
        }
      ],
      "name": "PRBMathSD59x18__ExpInputTooBig",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "x",
          "type": "int256"
        }
      ],
      "name": "PRBMathSD59x18__FromIntOverflow",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "x",
          "type": "int256"
        }
      ],
      "name": "PRBMathSD59x18__FromIntUnderflow",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PRBMathSD59x18__MulInputTooSmall",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "rAbs",
          "type": "uint256"
        }
      ],
      "name": "PRBMathSD59x18__MulOverflow",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "x",
          "type": "int256"
        }
      ],
      "name": "PRBMathSD59x18__SqrtNegativeInput",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "x",
          "type": "int256"
        }
      ],
      "name": "PRBMathSD59x18__SqrtOverflow",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "x",
          "type": "uint256"
        }
      ],
      "name": "PRBMathUD60x18__FromUintOverflow",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "prod1",
          "type": "uint256"
        }
      ],
      "name": "PRBMath__MulDivFixedPointOverflow",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "prod1",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "denominator",
          "type": "uint256"
        }
      ],
      "name": "PRBMath__MulDivOverflow",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PositionNetZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PositionNotSettled",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "WithdrawalExceedsCurrentMargin",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "cacheMaxAgeInSecondsOld",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "cacheMaxAgeInSeconds",
          "type": "uint256"
        }
      ],
      "name": "CacheMaxAgeSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "CollectProtocol",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "contract IFCM",
          "name": "fcmOld",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "contract IFCM",
          "name": "fcm",
          "type": "address"
        }
      ],
      "name": "FCMSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "secondsAgoOld",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "secondsAgo",
          "type": "uint256"
        }
      ],
      "name": "HistoricalApyWindowSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "indexed": false,
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "fixedTokenBalance",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "variableTokenBalance",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "margin",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "liquidity",
          "type": "uint128"
        }
      ],
      "name": "LiquidatePosition",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "liquidatorRewardWadOld",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "liquidatorRewardWad",
          "type": "uint256"
        }
      ],
      "name": "LiquidatorRewardSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "apyUpperMultiplierWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "apyLowerMultiplierWad",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "sigmaSquaredWad",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "alphaWad",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "betaWad",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "xiUpperWad",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "xiLowerWad",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "tMaxWad",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "devMulLeftUnwindLMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "devMulRightUnwindLMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "devMulLeftUnwindIMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "devMulRightUnwindIMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fixedRateDeviationMinLeftUnwindLMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fixedRateDeviationMinRightUnwindLMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fixedRateDeviationMinLeftUnwindIMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fixedRateDeviationMinRightUnwindIMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "gammaWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minMarginToIncentiviseLiquidators",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct IMarginEngine.MarginCalculatorParameters",
          "name": "marginCalculatorParametersOld",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "apyUpperMultiplierWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "apyLowerMultiplierWad",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "sigmaSquaredWad",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "alphaWad",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "betaWad",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "xiUpperWad",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "xiLowerWad",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "tMaxWad",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "devMulLeftUnwindLMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "devMulRightUnwindLMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "devMulLeftUnwindIMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "devMulRightUnwindIMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fixedRateDeviationMinLeftUnwindLMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fixedRateDeviationMinRightUnwindLMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fixedRateDeviationMinLeftUnwindIMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fixedRateDeviationMinRightUnwindIMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "gammaWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minMarginToIncentiviseLiquidators",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct IMarginEngine.MarginCalculatorParameters",
          "name": "marginCalculatorParameters",
          "type": "tuple"
        }
      ],
      "name": "MarginCalculatorParametersSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Paused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "indexed": false,
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "fixedTokenBalance",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "variableTokenBalance",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "margin",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "isSettled",
          "type": "bool"
        }
      ],
      "name": "SettlePosition",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Unpaused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "indexed": false,
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "positionMargin",
          "type": "int256"
        }
      ],
      "name": "UpdatePositionMargin",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "indexed": false,
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "liquidity",
          "type": "uint128"
        }
      ],
      "name": "UpdatePositionPostMintBurn",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "indexed": false,
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "fixedTokenBalance",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "variableTokenBalance",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "margin",
          "type": "int256"
        }
      ],
      "name": "UpdatePositionPostSwap",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "contract IVAMM",
          "name": "vammOld",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "contract IVAMM",
          "name": "vamm",
          "type": "address"
        }
      ],
      "name": "VAMMSet",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "cacheMaxAgeInSeconds",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "collectProtocol",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "factory",
      "outputs": [
        {
          "internalType": "contract IFactory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "fcm",
      "outputs": [
        {
          "internalType": "contract IFCM",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getHistoricalApy",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getHistoricalApyReadOnly",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        }
      ],
      "name": "getPosition",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bool",
              "name": "isSettled",
              "type": "bool"
            },
            {
              "internalType": "uint128",
              "name": "_liquidity",
              "type": "uint128"
            },
            {
              "internalType": "int256",
              "name": "margin",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "fixedTokenGrowthInsideLastX128",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "variableTokenGrowthInsideLastX128",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "fixedTokenBalance",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "variableTokenBalance",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "feeGrowthInsideLastX128",
              "type": "uint256"
            }
          ],
          "internalType": "struct Position.Info",
          "name": "position",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_underlyingToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_rateOracleAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_termStartTimestampWad",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_termEndTimestampWad",
          "type": "uint256"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        },
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        }
      ],
      "name": "liquidatePosition",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "liquidatorRewardWad",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "paused",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "rateOracle",
      "outputs": [
        {
          "internalType": "contract IRateOracle",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "secondsAgo",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_cacheMaxAgeInSeconds",
          "type": "uint256"
        }
      ],
      "name": "setCacheMaxAgeInSeconds",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_fcm",
          "type": "address"
        }
      ],
      "name": "setFCM",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_liquidatorRewardWad",
          "type": "uint256"
        }
      ],
      "name": "setLiquidatorReward",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "apyUpperMultiplierWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "apyLowerMultiplierWad",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "sigmaSquaredWad",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "alphaWad",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "betaWad",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "xiUpperWad",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "xiLowerWad",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "tMaxWad",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "devMulLeftUnwindLMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "devMulRightUnwindLMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "devMulLeftUnwindIMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "devMulRightUnwindIMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fixedRateDeviationMinLeftUnwindLMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fixedRateDeviationMinRightUnwindLMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fixedRateDeviationMinLeftUnwindIMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fixedRateDeviationMinRightUnwindIMWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "gammaWad",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minMarginToIncentiviseLiquidators",
              "type": "uint256"
            }
          ],
          "internalType": "struct IMarginEngine.MarginCalculatorParameters",
          "name": "_marginCalculatorParameters",
          "type": "tuple"
        }
      ],
      "name": "setMarginCalculatorParameters",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_secondsAgo",
          "type": "uint256"
        }
      ],
      "name": "setSecondsAgo",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_vAMMAddress",
          "type": "address"
        }
      ],
      "name": "setVAMM",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        },
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        }
      ],
      "name": "settlePosition",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "termEndTimestampWad",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "termStartTimestampWad",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "marginDelta",
          "type": "uint256"
        }
      ],
      "name": "transferMarginToFCMTrader",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "underlyingToken",
      "outputs": [
        {
          "internalType": "contract IERC20Minimal",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        },
        {
          "internalType": "int256",
          "name": "marginDelta",
          "type": "int256"
        }
      ],
      "name": "updatePositionMargin",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "int24",
              "name": "tickLower",
              "type": "int24"
            },
            {
              "internalType": "int24",
              "name": "tickUpper",
              "type": "int24"
            },
            {
              "internalType": "int128",
              "name": "liquidityDelta",
              "type": "int128"
            }
          ],
          "internalType": "struct IPositionStructs.ModifyPositionParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "updatePositionPostVAMMInducedMintBurn",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        },
        {
          "internalType": "int256",
          "name": "fixedTokenDelta",
          "type": "int256"
        },
        {
          "internalType": "int256",
          "name": "variableTokenDelta",
          "type": "int256"
        },
        {
          "internalType": "uint256",
          "name": "cumulativeFeeIncurred",
          "type": "uint256"
        }
      ],
      "name": "updatePositionPostVAMMInducedSwap",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "vamm",
      "outputs": [
        {
          "internalType": "contract IVAMM",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x2b421bf62b022746051b47cce4ebda3fad63871b4069528b1b910e159200ba0a",
  "receipt": {
    "to": null,
    "from": "0xF8F6B70a36f4398f0853a311dC6699Aba8333Cc1",
    "contractAddress": "0xFa9DDF4569206625370D2A8546f42c1CC924063c",
    "transactionIndex": 3,
    "gasUsed": "4651202",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x9220ac5250b3331fbc868b723184ae953394c059e73be7718c8ad346b702f3e3",
    "transactionHash": "0x2b421bf62b022746051b47cce4ebda3fad63871b4069528b1b910e159200ba0a",
    "logs": [],
    "blockNumber": 30105374,
    "cumulativeGasUsed": "6291113",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "9f9566c0cdca10f3ecaa77aa61f80c3b",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AmountSignsSame\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotLiquidate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotSettleBeforeMaturity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMarginDelta\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MarginLessThanMinimum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MarginRequirementNotMet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyFCM\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyOwnerCanUpdatePosition\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyVAMM\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PRBMathSD59x18__DivInputTooSmall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAbs\",\"type\":\"uint256\"}],\"name\":\"PRBMathSD59x18__DivOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"PRBMathSD59x18__Exp2InputTooBig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"PRBMathSD59x18__ExpInputTooBig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"PRBMathSD59x18__FromIntOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"PRBMathSD59x18__FromIntUnderflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PRBMathSD59x18__MulInputTooSmall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAbs\",\"type\":\"uint256\"}],\"name\":\"PRBMathSD59x18__MulOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"PRBMathSD59x18__SqrtNegativeInput\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"PRBMathSD59x18__SqrtOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"PRBMathUD60x18__FromUintOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prod1\",\"type\":\"uint256\"}],\"name\":\"PRBMath__MulDivFixedPointOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prod1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"PRBMath__MulDivOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PositionNetZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PositionNotSettled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawalExceedsCurrentMargin\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cacheMaxAgeInSecondsOld\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cacheMaxAgeInSeconds\",\"type\":\"uint256\"}],\"name\":\"CacheMaxAgeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CollectProtocol\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IFCM\",\"name\":\"fcmOld\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IFCM\",\"name\":\"fcm\",\"type\":\"address\"}],\"name\":\"FCMSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"secondsAgoOld\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"secondsAgo\",\"type\":\"uint256\"}],\"name\":\"HistoricalApyWindowSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"fixedTokenBalance\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"variableTokenBalance\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"margin\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"}],\"name\":\"LiquidatePosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidatorRewardWadOld\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidatorRewardWad\",\"type\":\"uint256\"}],\"name\":\"LiquidatorRewardSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"apyUpperMultiplierWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"apyLowerMultiplierWad\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"sigmaSquaredWad\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"alphaWad\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"betaWad\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"xiUpperWad\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"xiLowerWad\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"tMaxWad\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"devMulLeftUnwindLMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"devMulRightUnwindLMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"devMulLeftUnwindIMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"devMulRightUnwindIMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fixedRateDeviationMinLeftUnwindLMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fixedRateDeviationMinRightUnwindLMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fixedRateDeviationMinLeftUnwindIMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fixedRateDeviationMinRightUnwindIMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gammaWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minMarginToIncentiviseLiquidators\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct IMarginEngine.MarginCalculatorParameters\",\"name\":\"marginCalculatorParametersOld\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"apyUpperMultiplierWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"apyLowerMultiplierWad\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"sigmaSquaredWad\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"alphaWad\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"betaWad\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"xiUpperWad\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"xiLowerWad\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"tMaxWad\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"devMulLeftUnwindLMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"devMulRightUnwindLMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"devMulLeftUnwindIMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"devMulRightUnwindIMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fixedRateDeviationMinLeftUnwindLMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fixedRateDeviationMinRightUnwindLMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fixedRateDeviationMinLeftUnwindIMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fixedRateDeviationMinRightUnwindIMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gammaWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minMarginToIncentiviseLiquidators\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct IMarginEngine.MarginCalculatorParameters\",\"name\":\"marginCalculatorParameters\",\"type\":\"tuple\"}],\"name\":\"MarginCalculatorParametersSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"fixedTokenBalance\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"variableTokenBalance\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"margin\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isSettled\",\"type\":\"bool\"}],\"name\":\"SettlePosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"positionMargin\",\"type\":\"int256\"}],\"name\":\"UpdatePositionMargin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"}],\"name\":\"UpdatePositionPostMintBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"fixedTokenBalance\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"variableTokenBalance\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"margin\",\"type\":\"int256\"}],\"name\":\"UpdatePositionPostSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IVAMM\",\"name\":\"vammOld\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IVAMM\",\"name\":\"vamm\",\"type\":\"address\"}],\"name\":\"VAMMSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"cacheMaxAgeInSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"collectProtocol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fcm\",\"outputs\":[{\"internalType\":\"contract IFCM\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHistoricalApy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHistoricalApyReadOnly\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"getPosition\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isSettled\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"_liquidity\",\"type\":\"uint128\"},{\"internalType\":\"int256\",\"name\":\"margin\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"fixedTokenGrowthInsideLastX128\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"variableTokenGrowthInsideLastX128\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"fixedTokenBalance\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"variableTokenBalance\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthInsideLastX128\",\"type\":\"uint256\"}],\"internalType\":\"struct Position.Info\",\"name\":\"position\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlyingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rateOracleAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_termStartTimestampWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_termEndTimestampWad\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"liquidatePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidatorRewardWad\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateOracle\",\"outputs\":[{\"internalType\":\"contract IRateOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondsAgo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cacheMaxAgeInSeconds\",\"type\":\"uint256\"}],\"name\":\"setCacheMaxAgeInSeconds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fcm\",\"type\":\"address\"}],\"name\":\"setFCM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidatorRewardWad\",\"type\":\"uint256\"}],\"name\":\"setLiquidatorReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"apyUpperMultiplierWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"apyLowerMultiplierWad\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"sigmaSquaredWad\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"alphaWad\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"betaWad\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"xiUpperWad\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"xiLowerWad\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"tMaxWad\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"devMulLeftUnwindLMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"devMulRightUnwindLMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"devMulLeftUnwindIMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"devMulRightUnwindIMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fixedRateDeviationMinLeftUnwindLMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fixedRateDeviationMinRightUnwindLMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fixedRateDeviationMinLeftUnwindIMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fixedRateDeviationMinRightUnwindIMWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gammaWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minMarginToIncentiviseLiquidators\",\"type\":\"uint256\"}],\"internalType\":\"struct IMarginEngine.MarginCalculatorParameters\",\"name\":\"_marginCalculatorParameters\",\"type\":\"tuple\"}],\"name\":\"setMarginCalculatorParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_secondsAgo\",\"type\":\"uint256\"}],\"name\":\"setSecondsAgo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vAMMAddress\",\"type\":\"address\"}],\"name\":\"setVAMM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"settlePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"termEndTimestampWad\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"termStartTimestampWad\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"marginDelta\",\"type\":\"uint256\"}],\"name\":\"transferMarginToFCMTrader\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingToken\",\"outputs\":[{\"internalType\":\"contract IERC20Minimal\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int256\",\"name\":\"marginDelta\",\"type\":\"int256\"}],\"name\":\"updatePositionMargin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int128\",\"name\":\"liquidityDelta\",\"type\":\"int128\"}],\"internalType\":\"struct IPositionStructs.ModifyPositionParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"updatePositionPostVAMMInducedMintBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int256\",\"name\":\"fixedTokenDelta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"variableTokenDelta\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeFeeIncurred\",\"type\":\"uint256\"}],\"name\":\"updatePositionPostVAMMInducedSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vamm\",\"outputs\":[{\"internalType\":\"contract IVAMM\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"MarginLessThanMinimum()\":[{\"details\":\"Cannot have less margin than the minimum requirement\"}],\"PositionNetZero()\":[{\"details\":\"No need to unwind a net zero position\"}],\"PositionNotSettled()\":[{\"details\":\"Position must be settled after AMM has reached maturity\"}],\"WithdrawalExceedsCurrentMargin()\":[{\"details\":\"We can't withdraw more margin than we have\"}]},\"kind\":\"dev\",\"methods\":{\"collectProtocol(address,uint256)\":{\"params\":{\"amount\":\"the amount in terms of underlying tokens collected from the protocol's earnings\",\"recipient\":\"the address which collects the protocol generated fees\"}},\"constructor\":{\"custom:oz-upgrades-unsafe-allow\":\"constructor\"},\"getHistoricalApy()\":{\"details\":\"The lookback window used by this function is determined by the secondsAgo state variable\"},\"getHistoricalApyReadOnly()\":{\"details\":\"The lookback window used by this function is determined by the secondsAgo state variable\"},\"getPosition(address,int24,int24)\":{\"params\":{\"_owner\":\"The address of the position owner\",\"tickLower\":\"The lower tick boundary of the position\",\"tickUpper\":\"The upper tick boundary of the position Returns position The Position.Info corresponding to the requested position\"}},\"initialize(address,address,uint256,uint256)\":{\"details\":\"\\\"constructor\\\" for proxy instances\"},\"liquidatePosition(int24,int24,address)\":{\"details\":\"Steps to liquidate: update position's fixed and variable token balances to account for balances accumulated throughout the trades made since the last mint/burn/poke,Check if the position is liquidatable by calling the isLiquidatablePosition function of the calculator, revert if that is not the case,Calculate the liquidation reward = current margin of the position * liquidatorReward, subtract the liquidator reward from the position margin,Burn the position's liquidity, unwind unnetted fixed and variable balances of a position, transfer the reward to the liquidator\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"paused()\":{\"details\":\"Returns true if the contract is paused, and false otherwise.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"setCacheMaxAgeInSeconds(uint256)\":{\"params\":{\"_cacheMaxAgeInSeconds\":\"The new maximum age that the historical APY cache can be before being considered stale\"}},\"setMarginCalculatorParameters((uint256,uint256,int256,int256,int256,int256,int256,int256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"details\":\"marginCalculatorParameteres is of type MarginCalculatorParameters (refer to the definition of the struct for elaboration on what each parameter means)\",\"params\":{\"_marginCalculatorParameters\":\"the MarginCalculatorParameters to set\"}},\"setSecondsAgo(uint256)\":{\"details\":\"Can only be set by the Factory Owner\",\"params\":{\"_secondsAgo\":\"the duration of the lookback window in seconds\"}},\"setVAMM(address)\":{\"details\":\"the VAMM is responsible for price discovery, whereas the management of the underlying collateral and liquidations are handled by the Margin Engine\"},\"settlePosition(int24,int24,address)\":{\"details\":\"Can be called by anyoneA position cannot be settled before maturitySteps to settle a position:1. Retrieve the current fixed and variable token growth inside the tick range of a position2. Calculate accumulated fixed and variable balances of the position since the last mint/poke/burn3. Update the postion's fixed and variable token balances4. Update the postion's fixed and varaible token growth inside last to enable future updates5. Calculates the settlement cashflow from all of the IRS contracts the position has entered since entering the AMM6. Updates the fixed and variable token balances of the position to be zero, adds the settlement cashflow to the position's current margin\"},\"transferMarginToFCMTrader(address,uint256)\":{\"details\":\"post maturity date of the MarginEngine, the traders from the Full Collateralisation module will be able to settle with the MarginEngineto ensure their fixed yield is guaranteed, in order to collect the funds from the MarginEngine, the FCM needs to invoke the transferMarginToFCMTrader function whcih is only callable by the FCM attached to a particular Margin Engine\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"updatePositionMargin(address,int24,int24,int256)\":{\"details\":\"if the position has positive liquidity then before the margin update, we call the updatePositionTokenBalancesAndAccountForFees functon that calculates up to datemargin, fixed and variable token balances by taking into account the fee income from their tick range and fixed and variable deltas settled along their tick rangemarginDelta is the delta applied to the current margin of a positioin, if the marginDelta is negative, the position is withdrawing margin, if the marginDelta is positive, the position is depositing funds in terms of the underlying tokensif marginDelta is negative, we need to check if the msg.sender is either the _owner of the position or the msg.sender is apporved by the _owner to act on their behalf in Voltz Protocolthe approval logic is implemented in the Factory.solif marginDelta is negative, we additionally need to check if post the initial margin requirement is still satisfied post withdrawalif marginDelta is positive, the depositor of the margin is either the msg.sender or the owner who interacted through an approved peripheral contract\"},\"updatePositionPostVAMMInducedMintBurn((address,int24,int24,int128))\":{\"details\":\"Steps taken:1. Update position liquidity based on params.liquidityDelta2. Update fixed and variable token balances of the position based on how much has been accumulated since the last mint/burn/poke3. Update position's margin by taking into account the position accumulated fees since the last mint/burn/poke4. Update fixed and variable token growth + fee growth in the position info struct for future interactions with the position\",\"params\":{\"params\":\"necessary for the purposes of referencing the position being updated (owner, tickLower, tickUpper, _) and the liquidity delta that needs to be applied to position._liquidity\"}},\"updatePositionPostVAMMInducedSwap(address,int24,int24,int256,int256,uint256)\":{\"details\":\"Since every position can also engage in swaps with the VAMM, this function needs to be invoked after non-external calls are made to the VAMM's swap functionThis purpose of this function is to:1. updatePositionTokenBalancesAndAccountForFees2. update position margin to account for fees paid to execute the swap3. calculate the position margin requrement given the swap, check if the position marigin satisfies the most up to date requirement4. if all the requirements are satisfied then position gets updated to take into account the swap that it just entered, if the minimum margin requirement is not satisfied then the transaction will revert\"}},\"stateVariables\":{\"factory\":{\"details\":\"the factory that deployed the master Margin Engine\"},\"fcm\":{\"details\":\"The FCM is a smart contract that acts as an intermediary Position between the Voltz Core and traders who wish to take fully collateralised fixed taker positionsAn example FCM is the AaveFCM.sol module which inherits from the IFCM interface, it lets fixed takers deposit underlying yield bearing tokens (e.g.) aUSDC as margin to enter into a fixed taker swap without the need to worry about liquidationssince the MarginEngine is confident the FCM is always fully collateralised, it does not let liquidators liquidate the FCM Position\",\"return\":\"The Full Collateralisation Module linked to the MarginEngine\",\"returns\":{\"_0\":\"The Full Collateralisation Module linked to the MarginEngine\"}},\"liquidatorRewardWad\":{\"details\":\"liquidatorReward (in wad) is the percentage of the margin (of a liquidated position) that is sent to the liquidatorfollowing a successful liquidation that results in a trader/position unwind; example value:  2 * 10**16 => 2% of position margin is used to cover liquidator reward\",\"return\":\"Liquidator Reward in Wad\",\"returns\":{\"_0\":\"Liquidator Reward in Wad\"}},\"rateOracle\":{\"return\":\"The underlying ERC20 token (e.g. USDC)\",\"returns\":{\"_0\":\"The underlying ERC20 token (e.g. USDC)\"}},\"secondsAgo\":{\"details\":\"The historical APY of the Rate Oracle is necessary for MarginEngine computationsThe look-back window is seconds from the current timestampThis value is only settable by the the Factory owner and may be unique for each MarginEngineWhen setting secondAgo, the setter needs to take into consideration the underlying volatility of the APYs in the reference yield-bearing pool (e.g. Aave v2 USDC)\"},\"termEndTimestampWad\":{\"return\":\"Term End Timestamp in Wad\",\"returns\":{\"_0\":\"Term End Timestamp in Wad\"}},\"termStartTimestampWad\":{\"return\":\"Term Start Timestamp in Wad\",\"returns\":{\"_0\":\"Term Start Timestamp in Wad\"}},\"underlyingToken\":{\"return\":\"The underlying ERC20 token (e.g. USDC)\",\"returns\":{\"_0\":\"The underlying ERC20 token (e.g. USDC)\"}},\"vamm\":{\"details\":\"The VAMM is responsible for pricing only (determining the effective fixed rate at which a given Interest Rate Swap notional will be executed)\",\"return\":\"The VAMM\",\"returns\":{\"_0\":\"The VAMM\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"AmountSignsSame()\":[{\"notice\":\"amount0 and amount1 must have different signs\"}],\"CannotLiquidate()\":[{\"notice\":\"The position/trader needs to be below the liquidation threshold to be liquidated\"}],\"CannotSettleBeforeMaturity()\":[{\"notice\":\"Positions and Traders cannot be settled before the applicable interest rate swap has matured\"}],\"InvalidMarginDelta()\":[{\"notice\":\"Margin delta must not equal zero\"}],\"MarginRequirementNotMet()\":[{\"notice\":\"The resulting margin does not meet minimum requirements\"}],\"OnlyOwnerCanUpdatePosition()\":[{\"notice\":\"Only the position/trade owner can update the LP/Trader margin\"}],\"PRBMathSD59x18__DivInputTooSmall()\":[{\"notice\":\"Emitted when one of the inputs is MIN_SD59x18.\"}],\"PRBMathSD59x18__DivOverflow(uint256)\":[{\"notice\":\"Emitted when one of the intermediary unsigned results overflows SD59x18.\"}],\"PRBMathSD59x18__Exp2InputTooBig(int256)\":[{\"notice\":\"Emitted when the input is greater than 192.\"}],\"PRBMathSD59x18__ExpInputTooBig(int256)\":[{\"notice\":\"Emitted when the input is greater than 133.084258667509499441.\"}],\"PRBMathSD59x18__FromIntOverflow(int256)\":[{\"notice\":\"Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\"}],\"PRBMathSD59x18__FromIntUnderflow(int256)\":[{\"notice\":\"Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\"}],\"PRBMathSD59x18__MulInputTooSmall()\":[{\"notice\":\"Emitted when one of the inputs is MIN_SD59x18.\"}],\"PRBMathSD59x18__MulOverflow(uint256)\":[{\"notice\":\"Emitted when the intermediary absolute result overflows SD59x18.\"}],\"PRBMathSD59x18__SqrtNegativeInput(int256)\":[{\"notice\":\"Emitted when the input is negative.\"}],\"PRBMathSD59x18__SqrtOverflow(int256)\":[{\"notice\":\"Emitted when the calculating the square root overflows SD59x18.\"}],\"PRBMathUD60x18__FromUintOverflow(uint256)\":[{\"notice\":\"Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\"}],\"PRBMath__MulDivFixedPointOverflow(uint256)\":[{\"notice\":\"Emitted when the result overflows uint256.\"}],\"PRBMath__MulDivOverflow(uint256,uint256)\":[{\"notice\":\"Emitted when the result overflows uint256.\"}]},\"kind\":\"user\",\"methods\":{\"collectProtocol(address,uint256)\":{\"notice\":\"function that can only be called by the owner enables collection of protocol generated fees from any give margin engine\"},\"factory()\":{\"notice\":\"The Factory\"},\"fcm()\":{\"notice\":\"The Full Collateralisation Module (FCM)\"},\"getHistoricalApy()\":{\"notice\":\"Computes the historical APY value of the RateOracle\"},\"getHistoricalApyReadOnly()\":{\"notice\":\"Computes the historical APY value of the RateOracle\"},\"getPosition(address,int24,int24)\":{\"notice\":\"Returns the information about a position by the position's key\"},\"liquidatePosition(int24,int24,address)\":{\"notice\":\"Liquidate a Position\"},\"liquidatorRewardWad()\":{\"notice\":\"The liquidator Reward Percentage (in Wad)\"},\"rateOracle()\":{\"notice\":\"The rateOracle contract which lets the protocol access historical apys in the yield bearing pools it is built on top of\"},\"secondsAgo()\":{\"notice\":\"Gets the look-back window size that's used to request the historical APY from the rate Oracle\"},\"setCacheMaxAgeInSeconds(uint256)\":{\"notice\":\"Sets the maximum age that the cached historical APY value\"},\"setFCM(address)\":{\"notice\":\"sets the Full Collateralisation Module\"},\"setLiquidatorReward(uint256)\":{\"notice\":\"Sets the liquidator reward: proportion of liquidated position's margin paid as a reward to the liquidator\"},\"setMarginCalculatorParameters((uint256,uint256,int256,int256,int256,int256,int256,int256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"Set the MarginCalculatorParameters (each margin engine can have its own custom set of margin calculator parameters)\"},\"setSecondsAgo(uint256)\":{\"notice\":\"Sets secondsAgo: The look-back window size used to calculate the historical APY for margin purposes\"},\"setVAMM(address)\":{\"notice\":\"sets the Virtual Automated Market Maker (VAMM) attached to the MarginEngine\"},\"settlePosition(int24,int24,address)\":{\"notice\":\"Settles a Position\"},\"termEndTimestampWad()\":{\"notice\":\"The unix termEndTimestamp of the MarginEngine in Wad\"},\"termStartTimestampWad()\":{\"notice\":\"The unix termStartTimestamp of the MarginEngine in Wad\"},\"transferMarginToFCMTrader(address,uint256)\":{\"notice\":\"transfers margin in terms of underlying tokens to a trader from the Full Collateralisation Module\"},\"underlyingToken()\":{\"notice\":\"The address of the underlying (non-yield bearing) token - e.g. USDC\"},\"updatePositionMargin(address,int24,int24,int256)\":{\"notice\":\"updates the margin account of a position which can be uniquily identified with its _owner, tickLower, tickUpper\"},\"updatePositionPostVAMMInducedMintBurn((address,int24,int24,int128))\":{\"notice\":\"Update a Position post VAMM induced mint or burn\"},\"vamm()\":{\"notice\":\"VAMM (Virtual Automated Market Maker) linked to the MarginEngine\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/MarginEngine.sol\":\"MarginEngine\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x652fee292f698d8dba81bf287cb71f1682f6483b67ebe601a5f7387dcfc30b34\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x372b0bc04e3b4c074559bbbfb1317afddb56de5504158ca25a7f9cd403980445\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x041af89e5e60b74e1203d5a34614c9de379726f52ecb8cf064cab78b9fdcdf9d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x55cf2bd9fc76704ddcdc19834cd288b7de00fc0f298a40ea16a954ae8991db2d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"contracts/MarginEngine.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"./core_libraries/Tick.sol\\\";\\nimport \\\"./interfaces/IMarginEngine.sol\\\";\\nimport \\\"./interfaces/IVAMM.sol\\\";\\nimport \\\"./core_libraries/Position.sol\\\";\\nimport \\\"./core_libraries/MarginCalculator.sol\\\";\\nimport \\\"./utils/SafeCast.sol\\\";\\nimport \\\"./interfaces/rate_oracles/IRateOracle.sol\\\";\\nimport \\\"./interfaces/IERC20Minimal.sol\\\";\\nimport \\\"./interfaces/IFCM.sol\\\";\\nimport \\\"prb-math/contracts/PRBMathUD60x18.sol\\\";\\nimport \\\"./core_libraries/FixedAndVariableMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"./core_libraries/SafeTransferLib.sol\\\";\\n\\ncontract MarginEngine is IMarginEngine, Initializable, OwnableUpgradeable, PausableUpgradeable {\\n    using SafeCast for uint256;\\n    using SafeCast for int256;\\n    using Tick for mapping(int24 => Tick.Info);\\n\\n    using Position for mapping(bytes32 => Position.Info);\\n    using Position for Position.Info;\\n\\n    using SafeTransferLib for IERC20Minimal;\\n\\n    uint256 public override liquidatorRewardWad;\\n    IERC20Minimal public override underlyingToken;\\n\\n    /// @inheritdoc IMarginEngine\\n    uint256 public override termStartTimestampWad;\\n    /// @inheritdoc IMarginEngine\\n    uint256 public override termEndTimestampWad;\\n    \\n    /// @inheritdoc IMarginEngine\\n    IFCM public override fcm;\\n\\n    mapping(bytes32 => Position.Info) internal positions;\\n    \\n    IVAMM public override vamm;\\n\\n    MarginCalculatorParameters internal marginCalculatorParameters;\\n\\n    /// @inheritdoc IMarginEngine\\n    uint256 public override secondsAgo;\\n\\n    uint256 internal cachedHistoricalApy;\\n    uint256 private cachedHistoricalApyRefreshTimestamp;\\n\\n    uint256 public cacheMaxAgeInSeconds;\\n\\n    address private deployer;\\n    /// @inheritdoc IMarginEngine\\n    IFactory public override factory;\\n    /// @inheritdoc IMarginEngine\\n    IRateOracle public override rateOracle;\\n\\n    // https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() initializer {\\n\\n        deployer = msg.sender; /// this is presumably the factory\\n\\n    }\\n\\n    function initialize(address _underlyingToken, address _rateOracleAddress, uint256 _termStartTimestampWad, uint256 _termEndTimestampWad) external override initializer {\\n        require(_underlyingToken != address(0), \\\"UT must be set\\\");\\n        require(_rateOracleAddress != address(0), \\\"RO must be set\\\");\\n        require(_termStartTimestampWad != 0, \\\"TS must be set\\\");\\n        require(_termEndTimestampWad != 0, \\\"TE must be set\\\");\\n\\n        underlyingToken = IERC20Minimal(_underlyingToken);\\n        termStartTimestampWad = _termStartTimestampWad;\\n        termEndTimestampWad = _termEndTimestampWad;\\n\\n        rateOracle = IRateOracle(_rateOracleAddress);\\n        factory = IFactory(msg.sender);\\n\\n        __Ownable_init();\\n        __Pausable_init();\\n    }\\n\\n    /// Only the position/trade owner can update the LP/Trader margin\\n    error OnlyOwnerCanUpdatePosition();\\n\\n    error OnlyVAMM();\\n\\n    error OnlyFCM();\\n\\n    /// Margin delta must not equal zero\\n    error InvalidMarginDelta();\\n\\n    /// Positions and Traders cannot be settled before the applicable interest rate swap has matured\\n    error CannotSettleBeforeMaturity();\\n\\n    /// The position/trader needs to be below the liquidation threshold to be liquidated\\n    error CannotLiquidate();\\n\\n    /// The resulting margin does not meet minimum requirements\\n    error MarginRequirementNotMet();\\n\\n    modifier nonZeroDelta (int256 marginDelta) {\\n        if (marginDelta == 0) {\\n            revert InvalidMarginDelta();\\n        }\\n        _;\\n    }\\n\\n    /// @dev Modifier that ensures only the VAMM can execute certain actions\\n    modifier onlyVAMM () {\\n        if (msg.sender != address(vamm)) {\\n            revert OnlyVAMM();\\n        }\\n        _;\\n    }\\n    \\n    /// @dev Modifier that reverts if the msg.sender is not the Full Collateralisation Module\\n    modifier onlyFCM () {\\n        if (msg.sender != address(fcm)) {\\n            revert OnlyFCM();\\n        }\\n        _;\\n    }\\n    \\n    /// @dev Modifier that reverts if the termEndTimestamp is higher than the current block timestamp\\n    /// @dev This modifier ensures that actions such as settlePosition (can only be done after maturity)\\n    modifier onlyAfterMaturity () {\\n        if (termEndTimestampWad > Time.blockTimestampScaled()) {\\n            revert CannotSettleBeforeMaturity();\\n        }\\n        _;\\n    }\\n\\n    /// @dev Modifier that ensures new LP positions cannot be minted after one day before the maturity of the vamm\\n    /// @dev also ensures new swaps cannot be conducted after one day before maturity of the vamm\\n    modifier checkCurrentTimestampTermEndTimestampDelta() {\\n        if (Time.isCloseToMaturityOrBeyondMaturity(termEndTimestampWad)) {\\n        revert(\\\"closeToOrBeyondMaturity\\\");\\n        }\\n        _;\\n    }\\n\\n    /// @inheritdoc IMarginEngine\\n    function setMarginCalculatorParameters(\\n        MarginCalculatorParameters memory _marginCalculatorParameters\\n    ) external override onlyOwner {\\n        marginCalculatorParameters = _marginCalculatorParameters;\\n    }\\n    \\n    /// @inheritdoc IMarginEngine\\n    function setVAMM(address _vAMMAddress) external override onlyOwner {\\n        vamm = IVAMM(_vAMMAddress);\\n    }\\n    /// @inheritdoc IMarginEngine\\n    function setFCM(address _fcm) external override onlyOwner {\\n        fcm = IFCM(_fcm);\\n    }\\n\\n    /// @inheritdoc IMarginEngine\\n    function setSecondsAgo(uint256 _secondsAgo)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        uint256 secondsAgoOld = secondsAgo;\\n        secondsAgo = _secondsAgo;\\n        emit HistoricalApyWindowSet(secondsAgoOld, secondsAgo);\\n    }\\n\\n    /// @inheritdoc IMarginEngine\\n    function setCacheMaxAgeInSeconds(uint256 _cacheMaxAgeInSeconds)\\n        external\\n        override \\n        onlyOwner\\n    {\\n        uint256 cacheMaxAgeInSecondsOld = cacheMaxAgeInSeconds;\\n        cacheMaxAgeInSeconds = _cacheMaxAgeInSeconds;\\n        emit CacheMaxAgeSet(cacheMaxAgeInSecondsOld, cacheMaxAgeInSeconds);\\n    }\\n\\n    /// @inheritdoc IMarginEngine\\n    function collectProtocol(address recipient, uint256 amount)\\n        external\\n        override\\n        onlyOwner{\\n\\n        if (amount > 0) {\\n            /// @dev if the amount exceeds the available balances, vamm.updateProtocolFees(amount) should be reverted as intended\\n            vamm.updateProtocolFees(amount);\\n            underlyingToken.safeTransfer(\\n                recipient,\\n                amount\\n            );\\n        }\\n\\n        emit CollectProtocol(msg.sender, recipient, amount);\\n    }\\n\\n    /// @inheritdoc IMarginEngine\\n    function setLiquidatorReward(uint256 _liquidatorRewardWad) external override onlyOwner {\\n        uint256 liquidatorRewardWadOld = liquidatorRewardWad;\\n        liquidatorRewardWad = _liquidatorRewardWad;\\n        emit LiquidatorRewardSet(liquidatorRewardWadOld, liquidatorRewardWad);\\n    }\\n\\n    /// @inheritdoc IMarginEngine\\n    function getPosition(address _owner,\\n                         int24 tickLower,\\n                         int24 tickUpper)\\n        external override view returns (Position.Info memory position) {\\n            /// Costin: update position to account for fees?\\n            return positions.get(_owner, tickLower, tickUpper);\\n    }\\n\\n    /// @notice transferMargin function which:\\n    /// @dev Transfers funds in from account if _marginDelta is positive, or out to account if _marginDelta is negative\\n    /// @dev if the margiDelta is positive, we conduct a safe transfer from the _account address to the address of the MarginEngine\\n    /// @dev if the marginDelta is negative, the user wishes to withdraw underlying tokens from the MarginEngine,\\n    /// @dev in that case we first check the balance of the marginEngine in terms of the underlying tokens, if the balance is sufficient to cover the margin transfer, then we cover it via a safeTransfer\\n    /// @dev if the marginEngineBalance is not sufficient to cover the marginDelta then we cover the remainingDelta by invoking the transferMarginToMarginEngineTrader function of the fcm which in case of Aave will calls the Aave withdraw function to settle with the MarginEngine in underlying tokens\\n    function transferMargin(address _account, int256 _marginDelta) internal {\\n        if (_marginDelta > 0) {\\n            underlyingToken.safeTransferFrom(_account, address(this), uint256(_marginDelta));\\n        } else {\\n            uint256 marginEngineBalance = underlyingToken.balanceOf(address(this));\\n\\n            if (uint256(-_marginDelta) > marginEngineBalance) {\\n                uint256 remainingDeltaToCover = uint256(-_marginDelta);\\n                if (marginEngineBalance > 0) {\\n                    remainingDeltaToCover = remainingDeltaToCover - marginEngineBalance;\\n                    underlyingToken.safeTransfer(_account, marginEngineBalance);\\n                }\\n                fcm.transferMarginToMarginEngineTrader(_account, remainingDeltaToCover);\\n            } else {\\n                underlyingToken.safeTransfer(_account, uint256(-_marginDelta));\\n            }\\n\\n        }\\n    }\\n\\n\\n    /// @inheritdoc IMarginEngine\\n    function transferMarginToFCMTrader(address _account, uint256 marginDelta) external onlyFCM override {\\n        underlyingToken.safeTransfer(_account, marginDelta);\\n    }\\n\\n    /// @inheritdoc IMarginEngine\\n    function updatePositionMargin(address _owner, int24 tickLower, int24 tickUpper, int256 marginDelta) external nonZeroDelta(marginDelta) override {\\n        \\n        Tick.checkTicks(tickLower, tickUpper);\\n        \\n        Position.Info storage position = positions.get(_owner, tickLower, tickUpper);\\n        \\n        updatePositionTokenBalancesAndAccountForFees(position, tickLower, tickUpper, false);\\n\\n        require((position.margin + marginDelta) >= 0, \\\"can't withdraw more than have\\\");\\n        \\n        if (marginDelta < 0) {\\n\\n            if (_owner != msg.sender && !factory.isApproved(_owner, msg.sender)) {\\n                revert OnlyOwnerCanUpdatePosition();\\n            }\\n\\n            position.updateMarginViaDelta(marginDelta);\\n\\n            checkPositionMarginCanBeUpdated(position, tickLower, tickUpper); \\n\\n            transferMargin(_owner, marginDelta);\\n\\n        } else {\\n\\n            position.updateMarginViaDelta(marginDelta);\\n\\n            address depositor;\\n            if (factory.isApproved(_owner, msg.sender)) {\\n                depositor = _owner;\\n            } else {\\n                depositor = msg.sender;\\n            }\\n\\n            transferMargin(depositor, marginDelta);\\n        }\\n\\n        emit UpdatePositionMargin(_owner, tickLower, tickUpper, position.margin);\\n\\n    }\\n    \\n    \\n    /// @inheritdoc IMarginEngine\\n    function settlePosition(int24 tickLower, int24 tickUpper, address _owner) external override whenNotPaused onlyAfterMaturity {\\n        \\n        Tick.checkTicks(tickLower, tickUpper);\\n\\n        Position.Info storage position = positions.get(_owner, tickLower, tickUpper); \\n            \\n        require(!position.isSettled, \\\"already settled\\\");\\n        \\n        updatePositionTokenBalancesAndAccountForFees(position, tickLower, tickUpper, false);\\n        \\n        int256 settlementCashflow = FixedAndVariableMath.calculateSettlementCashflow(position.fixedTokenBalance, position.variableTokenBalance, termStartTimestampWad, termEndTimestampWad, rateOracle.variableFactor(termStartTimestampWad, termEndTimestampWad));\\n\\n        position.updateBalancesViaDeltas(-position.fixedTokenBalance, -position.variableTokenBalance);\\n        position.updateMarginViaDelta(settlementCashflow);\\n        position.settlePosition();\\n\\n        emit SettlePosition(_owner, tickLower, tickUpper, position.fixedTokenBalance, position.variableTokenBalance, position.margin, position.isSettled);\\n\\n    }\\n    \\n    /// @notice Computes the historical APY value of the RateOracle\\n    /// @dev The lookback window used by this function is determined by the secondsAgo state variable\\n    function getHistoricalApy()\\n        public\\n        returns (uint256)\\n    {\\n        if (cachedHistoricalApyRefreshTimestamp < block.timestamp - cacheMaxAgeInSeconds) {\\n            // Cache is stale\\n            _refreshHistoricalApyCache();\\n        }\\n        return cachedHistoricalApy;\\n    }\\n\\n    /// @notice Computes the historical APY value of the RateOracle\\n    /// @dev The lookback window used by this function is determined by the secondsAgo state variable\\n    function getHistoricalApyReadOnly()\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (cachedHistoricalApyRefreshTimestamp < block.timestamp - cacheMaxAgeInSeconds) {\\n            // Cache is stale\\n            return _getHistoricalApy();\\n        }\\n        return cachedHistoricalApy;\\n    }\\n\\n    /// @notice Computes the historical APY value of the RateOracle\\n    /// @dev The lookback window used by this function is determined by the secondsAgo state variable\\n    function _getHistoricalApy()\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 to = block.timestamp;\\n        uint256 from = to - secondsAgo;\\n\\n        return rateOracle.getApyFromTo(from, to);\\n    }\\n\\n    /// @notice Updates the cached historical APY value of the RateOracle even if the cache is not stale\\n    function _refreshHistoricalApyCache()\\n        internal\\n    {\\n        cachedHistoricalApy = _getHistoricalApy();\\n        cachedHistoricalApyRefreshTimestamp = block.timestamp;\\n    }\\n\\n\\n    /// @inheritdoc IMarginEngine\\n    function liquidatePosition(int24 tickLower, int24 tickUpper, address _owner) external checkCurrentTimestampTermEndTimestampDelta override {\\n\\n        /// @dev can only happen before maturity, this is checked when an unwind is triggered which in turn triggers a swap which checks for this condition\\n\\n        Tick.checkTicks(tickLower,tickUpper);\\n\\n        Position.Info storage position = positions.get(_owner, tickLower, tickUpper);  \\n\\n        updatePositionTokenBalancesAndAccountForFees(position, tickLower, tickUpper, false);\\n        \\n        bool isLiquidatable = isLiquidatablePosition(position, tickLower, tickUpper);\\n\\n        if (!isLiquidatable) {\\n            revert CannotLiquidate();\\n        }\\n\\n        uint256 liquidatorRewardValueWad = PRBMathUD60x18.mul(PRBMathUD60x18.fromUint(uint256(position.margin)), liquidatorRewardWad);\\n\\n        uint256 liquidatorRewardValue = PRBMathUD60x18.toUint(liquidatorRewardValueWad);\\n\\n        position.updateMarginViaDelta(-int256(liquidatorRewardValue));\\n\\n        if (position._liquidity > 0) {\\n            /// @dev pass position._liquidity to ensure all of the liqudity is burnt\\n            vamm.burn(_owner, tickLower, tickUpper, position._liquidity);\\n        }\\n    \\n        unwindPosition(position, _owner, tickLower, tickUpper);\\n\\n        underlyingToken.safeTransfer(msg.sender, liquidatorRewardValue);\\n\\n        emit LiquidatePosition(_owner, tickLower, tickUpper, position.fixedTokenBalance, position.variableTokenBalance, position.margin, position._liquidity);\\n\\n    }\\n\\n\\n    /// @inheritdoc IMarginEngine\\n    function updatePositionPostVAMMInducedMintBurn(IVAMM.ModifyPositionParams memory params) external onlyVAMM override {\\n\\n        Position.Info storage position = positions.get(params.owner, params.tickLower, params.tickUpper);\\n\\n        updatePositionTokenBalancesAndAccountForFees(position, params.tickLower, params.tickUpper, true);\\n\\n        position.updateLiquidity(params.liquidityDelta);\\n\\n        if (params.liquidityDelta>0) {\\n            checkPositionMarginAboveRequirement(position, params.tickLower, params.tickUpper);\\n        }\\n\\n        emit UpdatePositionPostMintBurn(params.owner, params.tickLower, params.tickUpper, position._liquidity);\\n\\n    }\\n\\n    /// @inheritdoc IMarginEngine\\n    function updatePositionPostVAMMInducedSwap(address _owner, int24 tickLower, int24 tickUpper, int256 fixedTokenDelta, int256 variableTokenDelta, uint256 cumulativeFeeIncurred) external onlyVAMM override {\\n        /// @dev this function can only be called by the vamm following a swap    \\n\\n        Position.Info storage position = positions.get(_owner, tickLower, tickUpper);\\n        updatePositionTokenBalancesAndAccountForFees(position, tickLower, tickUpper, false);\\n\\n        if (cumulativeFeeIncurred > 0) {\\n            position.updateMarginViaDelta(-int256(cumulativeFeeIncurred));\\n        }\\n\\n        position.updateBalancesViaDeltas(fixedTokenDelta, variableTokenDelta);\\n\\n        int256 positionMarginRequirement = int256(\\n            getPositionMarginRequirement(position, tickLower, tickUpper, false)\\n        );\\n\\n        if (positionMarginRequirement > position.margin) {\\n            revert MarginRequirementNotMet();\\n        }\\n\\n        emit UpdatePositionPostSwap(_owner, tickLower, tickUpper, position.fixedTokenBalance, position.variableTokenBalance, position.margin);\\n    }\\n    \\n\\n    /// @notice update position token balances and account for fees\\n    /// @dev if the _liquidity of the position supplied to this function is >0 then we\\n    /// @dev 1. retrieve the fixed, variable and fee Growth variables from the vamm by invoking the computeGrowthInside function of the VAMM\\n    /// @dev 2. calculate the deltas that need to be applied to the position's fixed and variable token balances by taking into account trads that took place in the VAMM since the last mint/poke/burn that invoked this function\\n    /// @dev 3. update the fixed and variable token balances and the margin of the positioin to account for deltas (outlined above) and fees generated by the active liquidity supplied by the position\\n    /// @dev 4. additionally, we need to update the last growth inside variables in the Position.Info struct so that we take a note that we've accounted for the changes up until this point \\n    /// @dev if _liquidity of the position supplied to this function is zero, then we need to check if isMintBurn is set to true (if it is set to true) then we know thsi function was called post a mint/burn event,\\n    /// @dev meaning we still need to correctly update the last fixed, variable and fee growth variables in the Position.Info struct\\n    function updatePositionTokenBalancesAndAccountForFees(\\n        Position.Info storage position,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        bool isMintBurn\\n        ) internal {\\n\\n        if (position._liquidity > 0) {\\n            (int256 fixedTokenGrowthInsideX128, int256 variableTokenGrowthInsideX128, uint256 feeGrowthInsideX128) = vamm.computeGrowthInside(tickLower, tickUpper);\\n            (int256 fixedTokenDelta, int256 variableTokenDelta) = position.calculateFixedAndVariableDelta(fixedTokenGrowthInsideX128, variableTokenGrowthInsideX128);\\n            uint256 feeDelta = position.calculateFeeDelta(feeGrowthInsideX128);\\n\\n            position.updateBalancesViaDeltas(fixedTokenDelta, variableTokenDelta);\\n            position.updateFixedAndVariableTokenGrowthInside(fixedTokenGrowthInsideX128, variableTokenGrowthInsideX128);\\n            /// @dev collect fees\\n            position.updateMarginViaDelta(int256(feeDelta));\\n            position.updateFeeGrowthInside(feeGrowthInsideX128);\\n        } else {\\n            if (isMintBurn) {\\n                (int256 fixedTokenGrowthInsideX128, int256 variableTokenGrowthInsideX128, uint256 feeGrowthInsideX128) = vamm.computeGrowthInside(tickLower, tickUpper);\\n                position.updateFixedAndVariableTokenGrowthInside(fixedTokenGrowthInsideX128, variableTokenGrowthInsideX128);\\n                position.updateFeeGrowthInside(feeGrowthInsideX128);\\n            }\\n        }\\n    }\\n    \\n\\n    /// @notice Internal function that checks if the position's current margin is above the requirement\\n    /// @param position Position.Info of the position of interest, updates to position, edit it in storage\\n    /// @param tickLower Lower Tick of the position\\n    /// @param tickUpper Upper Tick of the position\\n    /// @dev This function calculates the position margin requirement, compares it with the position.margin and reverts if the current position margin is below the requirement\\n    function checkPositionMarginAboveRequirement(\\n        Position.Info storage position,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) internal {\\n    \\n        int256 positionMarginRequirement = int256(\\n            getPositionMarginRequirement(position, tickLower, tickUpper, false)\\n        );\\n\\n        if (position.margin <= positionMarginRequirement) {\\n            revert MarginLessThanMinimum();\\n        }\\n    }\\n\\n\\n    /// @notice Check the position margin can be updated\\n    /// @param position Position.Info of the position of interest, updates to position, edit it in storage\\n    /// @param tickLower Lower Tick of the position\\n    /// @param tickUpper Upper Tick of the position\\n    function checkPositionMarginCanBeUpdated(\\n        Position.Info storage position,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) internal {\\n\\n        /// @dev If the IRS AMM has reached maturity, the only reason why someone would want to update\\n        /// @dev their margin is to withdraw it completely. If so, the position needs to be settled\\n        if (Time.blockTimestampScaled() >= termEndTimestampWad) {\\n            if (!position.isSettled) {\\n                revert PositionNotSettled();\\n            }\\n            if (position.margin < 0) {\\n                revert WithdrawalExceedsCurrentMargin();\\n            }\\n        }\\n        else {\\n            /// @dev if we haven't reached maturity yet, then check if the positon margin requirement is satisfied if not then the position margin update will also revert\\n            checkPositionMarginAboveRequirement(\\n                position,\\n                tickLower,\\n                tickUpper\\n            );\\n        }\\n    }\\n\\n    \\n    /// @notice Unwind a position\\n    /// @dev Before unwinding a position, need to check if it is even necessary to unwind it, i.e. check if the most up to date variable token balance of a position is non-zero\\n    /// @dev If the current variable token balance is negative, then it means the position is a net Fixed Taker\\n    /// @dev Hence to unwind, we need to enter into a Variable Taker IRS contract with notional = abs(current variable token balance of the position)\\n    /// @param _owner the owner of the position\\n    /// @param tickLower the lower tick of the position's tick range\\n    /// @param tickUpper the upper tick of the position's tick range\\n    function unwindPosition(\\n        Position.Info storage position,\\n        address _owner,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) internal {\\n\\n        Tick.checkTicks(tickLower, tickUpper);\\n\\n        if (position.variableTokenBalance != 0 ) {\\n\\n            int256 _fixedTokenDelta;\\n            int256 _variableTokenDelta;\\n            uint256 _cumulativeFeeIncurred;\\n\\n            /// @dev initiate a swap\\n\\n            bool isFT = position.variableTokenBalance < 0;\\n\\n            if (isFT) {\\n\\n                /// @dev get into a Variable Taker swap (the opposite of LP's current position) --> hence params.isFT is set to false for the vamm swap call\\n                /// @dev amountSpecified needs to be negative (since getting into a variable taker swap)\\n                /// @dev since the position.variableTokenBalance is already negative, pass position.variableTokenBalance as amountSpecified\\n                /// @dev since moving from left to right along the virtual amm, sqrtPriceLimit is set to MIN_SQRT_RATIO + 1\\n                /// @dev isExternal is a boolean that ensures the state updates to the position are handled directly in the body of the unwind call\\n                /// @dev that's more efficient than letting the swap call the margin engine again to update position fixed and varaible token balances + account for fees\\n\\n                IVAMM.SwapParams memory params = IVAMM.SwapParams({\\n                    recipient: _owner,\\n                    amountSpecified: position.variableTokenBalance,\\n                    sqrtPriceLimitX96: TickMath.MIN_SQRT_RATIO + 1,\\n                    isExternal: true,\\n                    tickLower: tickLower,\\n                    tickUpper: tickUpper\\n                });\\n\\n                (_fixedTokenDelta, _variableTokenDelta, _cumulativeFeeIncurred) = vamm.swap(params);\\n            } else {\\n\\n                /// @dev get into a Fixed Taker swap (the opposite of LP's current position)\\n                /// @dev amountSpecified needs to be positive, since we are executing a fixedd taker swap\\n                /// @dev since the position.variableTokenBalance is already positive, pass position.variableTokenBalance as amountSpecified\\n                /// @dev since moving from right to left along the virtual amm, sqrtPriceLimit is set to MAX_SQRT_RATIO - 1\\n\\n                IVAMM.SwapParams memory params = IVAMM.SwapParams({\\n                    recipient: _owner,\\n                    amountSpecified: position.variableTokenBalance,\\n                    sqrtPriceLimitX96: TickMath.MAX_SQRT_RATIO - 1,\\n                    isExternal: true,\\n                    tickLower: tickLower,\\n                    tickUpper: tickUpper\\n                });\\n\\n                (_fixedTokenDelta, _variableTokenDelta, _cumulativeFeeIncurred) = vamm.swap(params);\\n            }\\n\\n            if (_cumulativeFeeIncurred > 0) {\\n                /// @dev update position margin to account for the fees incurred while conducting a swap in order to unwind\\n                position.updateMarginViaDelta(-int256(_cumulativeFeeIncurred));\\n            }\\n\\n            /// @dev passes the _fixedTokenBalance and _variableTokenBalance deltas\\n            position.updateBalancesViaDeltas(_fixedTokenDelta, _variableTokenDelta);\\n        }\\n\\n    }\\n\\n    \\n    function getExtraBalances(int24 from, int24 to, uint128 liquidity, uint256 variableFactorWad) internal view returns (int256 extraFixedTokenBalance, int256 extraVariableTokenBalance) {\\n        if (from == to) return (0, 0);\\n        \\n        int256 amount0 = SqrtPriceMath.getAmount0Delta(\\n            TickMath.getSqrtRatioAtTick(from),\\n            TickMath.getSqrtRatioAtTick(to),\\n            (from < to) ? -int128(liquidity) : int128(liquidity)\\n        );\\n\\n        int256 amount1 = SqrtPriceMath.getAmount1Delta(\\n            TickMath.getSqrtRatioAtTick(from),\\n            TickMath.getSqrtRatioAtTick(to),\\n            (from < to) ? int128(liquidity) : -int128(liquidity)\\n        );\\n\\n        extraFixedTokenBalance = FixedAndVariableMath.getFixedTokenBalance(\\n                        amount0,\\n                        amount1,\\n                        variableFactorWad,\\n                        termStartTimestampWad,\\n                        termEndTimestampWad\\n                    );\\n\\n        extraVariableTokenBalance = amount1;\\n    }\\n\\n\\n    /// @notice Get Position Margin Requirement\\n    /// @dev if the position has no active liquidity in the VAMM, then we can compute its margin requirement by just passing its current fixed and variable token balances to teh getMarginRequirement function\\n    /// @dev however, if the current _liquidity of the position is positive, it means that the position can potentially enter into interest rate swap positions with traders in their tick range\\n    /// @dev to account for that possibility, we analyse two scenarios:\\n    /// @dev scenario 1: a trader comes in and trades all the liquidity all the way to the the upper tick\\n    /// @dev scenario 2: a trader comes in and trades all the liquidity all the way to the the lower tick\\n    /// @dev one the fixed and variable token balances are calculated for each counterfactual scenarios, their margin requiremnets can be obtained by calling getMarginrRequirement for each scenario\\n    /// @dev finally, the output is the max of the margin requirements from two of the scenarios considered\\n    function getPositionMarginRequirement(\\n        Position.Info storage position,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        bool isLM\\n    ) internal returns (uint256 margin) {\\n        Tick.checkTicks(tickLower, tickUpper);\\n\\n        (uint160 sqrtPriceX96, int24 tick, ) = vamm.vammVars();\\n\\n        uint256 variableFactorWad = rateOracle.variableFactor(termStartTimestampWad, termEndTimestampWad);\\n\\n        if (position._liquidity > 0) {\\n            PositionMarginRequirementLocalVars2 memory localVars;\\n            localVars.inRangeTick = (tick < tickLower) ? tickLower : ((tick < tickUpper) ? tick : tickUpper);\\n\\n            // scenario 1: a trader comes in and trades all the liquidity all the way to the the upper tick\\n            // scenario 2: a trader comes in and trades all the liquidity all the way to the the lower tick\\n            \\n            (int256 extraFixedTokenBalance, int256 extraVariableTokenBalance) = getExtraBalances(localVars.inRangeTick, tickUpper, position._liquidity, variableFactorWad);\\n            localVars.scenario1LPVariableTokenBalance =\\n                    position.variableTokenBalance + extraVariableTokenBalance;\\n\\n            localVars.scenario1LPFixedTokenBalance =\\n                    position.fixedTokenBalance + extraFixedTokenBalance;\\n\\n            (extraFixedTokenBalance, extraVariableTokenBalance) = getExtraBalances(localVars.inRangeTick, tickLower, position._liquidity, variableFactorWad);\\n            localVars.scenario2LPVariableTokenBalance =\\n                    position.variableTokenBalance + extraVariableTokenBalance;\\n\\n            localVars.scenario2LPFixedTokenBalance =\\n                    position.fixedTokenBalance + extraFixedTokenBalance;\\n\\n            uint160 priceAtLowerTick = TickMath.getSqrtRatioAtTick(tickLower);\\n            uint160 priceAtUpperTick = TickMath.getSqrtRatioAtTick(tickUpper);\\n        \\n            localVars.scenario1SqrtPriceX96 = (localVars.scenario1LPVariableTokenBalance > 0) \\n                ? ((sqrtPriceX96 > priceAtUpperTick) ? sqrtPriceX96 : priceAtUpperTick) \\n                : ((sqrtPriceX96 < priceAtLowerTick) ? sqrtPriceX96 : priceAtLowerTick);\\n\\n            localVars.scenario2SqrtPriceX96 = (localVars.scenario2LPVariableTokenBalance > 0) \\n                ? ((sqrtPriceX96 > priceAtUpperTick) ? sqrtPriceX96 : priceAtUpperTick) \\n                : ((sqrtPriceX96 < priceAtLowerTick) ? sqrtPriceX96 : priceAtLowerTick);\\n\\n\\n            uint256 scenario1MarginRequirement = getMarginRequirement(localVars.scenario1LPFixedTokenBalance, localVars.scenario1LPVariableTokenBalance, isLM, localVars.scenario1SqrtPriceX96);\\n            uint256 scenario2MarginRequirement = getMarginRequirement(localVars.scenario2LPFixedTokenBalance, localVars.scenario2LPVariableTokenBalance, isLM, localVars.scenario2SqrtPriceX96);\\n\\n            if (scenario1MarginRequirement > scenario2MarginRequirement) {\\n                return scenario1MarginRequirement;\\n            } else {\\n                return scenario2MarginRequirement;\\n            }\\n\\n        } else {\\n            // directly get the trader margin requirement\\n            return getMarginRequirement(position.fixedTokenBalance, position.variableTokenBalance, isLM, sqrtPriceX96);\\n        }\\n    }\\n\\n    /// @notice Checks if a given position is liquidatable\\n    /// @dev In order for a position to be liquidatable its current margin needs to be lower than the position's liquidation margin requirement\\n    /// @return _isLiquidatable A boolean which suggests if a given position is liquidatable\\n    function isLiquidatablePosition(\\n        Position.Info storage position,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) internal returns (bool _isLiquidatable) {\\n        uint256 marginRequirement = getPositionMarginRequirement(\\n            position,\\n            tickLower,\\n            tickUpper,\\n            true\\n        );\\n        if (position.margin < int256(marginRequirement)) {\\n            _isLiquidatable = true;\\n        } else {\\n            _isLiquidatable = false;\\n        }\\n    }\\n\\n\\n    /// @notice Returns either the Liquidation or Initial Margin Requirement given a fixed and variable token balance as well as the isLM boolean\\n    /// @return margin  either liquidation or initial margin requirement of a given trader in terms of the underlying tokens\\n    function getMarginRequirement(\\n        int256 fixedTokenBalance,\\n        int256 variableTokenBalance,\\n        bool isLM,\\n        uint160 sqrtPriceX96\\n    ) internal returns (uint256 margin) {    \\n        margin = _getMarginRequirement(\\n            fixedTokenBalance,\\n            variableTokenBalance,\\n            isLM\\n        );\\n\\n        uint256 minimumMarginRequirement = getMinimumMarginRequirement(\\n            fixedTokenBalance,\\n            variableTokenBalance,\\n            isLM,\\n            sqrtPriceX96\\n        );\\n\\n        if (margin < minimumMarginRequirement) {\\n            margin = minimumMarginRequirement;\\n        }\\n    }\\n\\n    /// @notice get margin requirement based on a fixed and variable token balance and isLM boolean\\n    function _getMarginRequirement(\\n        int256 fixedTokenBalance,\\n        int256 variableTokenBalance,\\n        bool isLM\\n    ) internal returns (uint256 margin) {\\n    \\n        if (fixedTokenBalance >= 0 && variableTokenBalance >= 0) {\\n            return 0;\\n        }\\n\\n        int256 fixedTokenBalanceWad = PRBMathSD59x18.fromInt(\\n            fixedTokenBalance\\n        );\\n        int256 variableTokenBalanceWad = PRBMathSD59x18.fromInt(\\n            variableTokenBalance\\n        );\\n\\n        uint256 timeInSecondsFromStartToMaturityWad = termEndTimestampWad - termStartTimestampWad;\\n\\n\\n        /// exp1 = fixedTokenBalance*timeInYearsFromTermStartToTermEnd*0.01\\n        // this can either be negative or positive depending on the sign of the fixedTokenBalance\\n        int256 exp1Wad = PRBMathSD59x18.mul(\\n            fixedTokenBalanceWad,\\n            int256(\\n                FixedAndVariableMath.fixedFactor(\\n                    true,\\n                    termStartTimestampWad,\\n                    termEndTimestampWad\\n                )\\n            )\\n        );\\n        \\n        /// exp2 = variableTokenBalance*worstCaseVariableFactor(from term start to term end)\\n        int256 exp2Wad = PRBMathSD59x18.mul(\\n            variableTokenBalanceWad,\\n            int256(\\n                MarginCalculator.worstCaseVariableFactorAtMaturity(\\n                    timeInSecondsFromStartToMaturityWad,\\n                    termEndTimestampWad,\\n                    Time.blockTimestampScaled(),\\n                    variableTokenBalance < 0,\\n                    isLM,\\n                    getHistoricalApy(),\\n                    marginCalculatorParameters\\n                )\\n            )\\n        );\\n\\n        // this is the worst case settlement cashflow expected by the position to cover\\n        int256 maxCashflowDeltaToCoverPostMaturity = exp1Wad + exp2Wad;\\n\\n        // hence if maxCashflowDeltaToCoverPostMaturity is negative then the margin needs to be sufficient to cover it\\n        // if maxCashflowDeltaToCoverPostMaturity is non-negative then it means according to this model the even in the worst case, the settlement cashflow is expected to be non-negative\\n        // hence, returning zero as the margin requirement\\n        if (maxCashflowDeltaToCoverPostMaturity < 0) {\\n            margin = PRBMathUD60x18.toUint(\\n                uint256(-maxCashflowDeltaToCoverPostMaturity)\\n            );\\n        } else {\\n            margin = 0;\\n        }\\n    }\\n\\n\\n    /// @notice Get Minimum Margin Requirement\\n    // given the fixed and variable balances and a starting sqrtPriceX96\\n    // we calculate the minimum marign requirement by simulating a counterfactual unwind at fixed rate that is a function of the current fixed rate (sqrtPriceX96) (details in the litepaper)\\n    // if the variable token balance is 0 or if the variable token balance is >0 and the fixed token balace >0 then the minimum margin requirement is zero\\n    function getMinimumMarginRequirement(\\n        int256 fixedTokenBalance,\\n        int256 variableTokenBalance,\\n        bool isLM,\\n        uint160 sqrtPriceX96\\n    ) internal returns (uint256 margin) {\\n        \\n        if (variableTokenBalance == 0) {\\n            // if the variable token balance is zero there is no need for a minimum liquidator incentive since a liquidtion is not expected\\n            return 0;\\n        }\\n\\n        int256 fixedTokenDeltaUnbalanced;\\n        uint256 devMulWad;\\n        uint256 fixedRateDeviationMinWad;\\n\\n        if (variableTokenBalance > 0) {\\n            if (fixedTokenBalance > 0) {\\n                // if both are positive, no need to have a margin requirement\\n                return 0;\\n            }\\n\\n            if (isLM) {\\n                devMulWad = marginCalculatorParameters.devMulLeftUnwindLMWad;\\n                fixedRateDeviationMinWad = marginCalculatorParameters\\n                    .fixedRateDeviationMinLeftUnwindLMWad;\\n            } else {\\n                devMulWad = marginCalculatorParameters.devMulLeftUnwindIMWad;\\n                fixedRateDeviationMinWad = marginCalculatorParameters\\n                    .fixedRateDeviationMinLeftUnwindIMWad;\\n            }\\n\\n            // simulate an adversarial unwind (cumulative position is a Variable Taker --> simulate FT unwind --> movement to the left along the VAMM)\\n            // fixedTokenDelta unbalanced that results from the simulated unwind\\n            fixedTokenDeltaUnbalanced = int256(\\n                MarginCalculator.getAbsoluteFixedTokenDeltaUnbalancedSimulatedUnwind(\\n                    uint256(variableTokenBalance),\\n                    sqrtPriceX96,\\n                    devMulWad,\\n                    fixedRateDeviationMinWad,\\n                    termEndTimestampWad,\\n                    Time.blockTimestampScaled(),\\n                    uint256(marginCalculatorParameters.tMaxWad),\\n                    marginCalculatorParameters.gammaWad,\\n                    true\\n                )\\n            );\\n        } else {\\n            if (isLM) {\\n                devMulWad = marginCalculatorParameters.devMulRightUnwindLMWad;\\n                fixedRateDeviationMinWad = marginCalculatorParameters\\n                    .fixedRateDeviationMinRightUnwindLMWad;\\n            } else {\\n                devMulWad = marginCalculatorParameters.devMulRightUnwindIMWad;\\n                fixedRateDeviationMinWad = marginCalculatorParameters\\n                    .fixedRateDeviationMinRightUnwindIMWad;\\n            }\\n\\n            // simulate an adversarial unwind (cumulative position is an FT --> simulate a VT unwind --> movement to the right along the VAMM)\\n            fixedTokenDeltaUnbalanced = -int256(\\n                MarginCalculator.getAbsoluteFixedTokenDeltaUnbalancedSimulatedUnwind(\\n                    uint256(-variableTokenBalance),\\n                    sqrtPriceX96,\\n                    devMulWad,\\n                    fixedRateDeviationMinWad,\\n                    termEndTimestampWad,\\n                    Time.blockTimestampScaled(),\\n                    uint256(marginCalculatorParameters.tMaxWad),\\n                    marginCalculatorParameters.gammaWad,\\n                    false\\n                )\\n            );\\n        }\\n\\n        int256 variableTokenDelta = -variableTokenBalance;\\n\\n        int256 fixedTokenDelta = FixedAndVariableMath.getFixedTokenBalance(\\n            fixedTokenDeltaUnbalanced,\\n            variableTokenDelta,\\n            rateOracle.variableFactor(termStartTimestampWad, termEndTimestampWad),\\n            termStartTimestampWad,\\n            termEndTimestampWad\\n        );\\n\\n        int256 updatedVariableTokenBalance = variableTokenBalance +\\n            variableTokenDelta; // should be zero\\n        int256 updatedFixedTokenBalance = fixedTokenBalance +\\n            fixedTokenDelta;\\n\\n        margin = _getMarginRequirement(\\n            updatedFixedTokenBalance,\\n            updatedVariableTokenBalance,\\n            isLM);\\n\\n        if (\\n            margin <\\n            marginCalculatorParameters.minMarginToIncentiviseLiquidators\\n        ) {\\n            margin = marginCalculatorParameters\\n                .minMarginToIncentiviseLiquidators;\\n        }\\n    }\\n\\n\\n}\",\"keccak256\":\"0x05d9241ad9afdb45e36c5eade03df91fa9995aae6e608defe5681dcc2a61fc45\",\"license\":\"MIT\"},\"contracts/core_libraries/FixedAndVariableMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"prb-math/contracts/PRBMathSD59x18.sol\\\";\\nimport \\\"prb-math/contracts/PRBMathUD60x18.sol\\\";\\nimport \\\"./Time.sol\\\";\\n\\n/// @title A utility library for mathematics of fixed and variable token amounts.\\nlibrary FixedAndVariableMath {\\n    /// @notice Number of wei-seconds in a year\\n    /// @dev Ignoring leap years since we're only using it to calculate the eventual APY rate\\n\\n    // suggestion: do this conversion with PRB.fromUnit()\\n    uint256 public constant SECONDS_IN_YEAR_IN_WAD = 31536000 * 10**18;\\n    uint256 public constant ONE_HUNDRED_IN_WAD = 100 * 10**18;\\n\\n    /// @notice amount0 and amount1 must have different signs\\n    error AmountSignsSame();\\n\\n    /// @notice Caclulate the remaining cashflow to settle a position\\n    /// @param fixedTokenBalance The current balance of the fixed side of the position\\n    /// @param variableTokenBalance The current balance of the variable side of the position\\n    /// @param termStartTimestampWad When did the position begin, in seconds\\n    /// @param termEndTimestampWad When does the position reach maturity, in seconds\\n    /// @param variableFactorToMaturityWad What factor expresses the current remaining variable rate, up to position maturity? (in WAD)\\n    /// @return cashflow The remaining cashflow of the position\\n    function calculateSettlementCashflow(\\n        int256 fixedTokenBalance,\\n        int256 variableTokenBalance,\\n        uint256 termStartTimestampWad,\\n        uint256 termEndTimestampWad,\\n        uint256 variableFactorToMaturityWad\\n    ) internal view returns (int256 cashflow) {\\n        /// @dev convert fixed and variable token balances to their respective fixed token representations\\n\\n        int256 fixedTokenBalanceWad = PRBMathSD59x18.fromInt(fixedTokenBalance);\\n        int256 variableTokenBalanceWad = PRBMathSD59x18.fromInt(\\n            variableTokenBalance\\n        );\\n\\n        int256 fixedCashflowWad = PRBMathSD59x18.mul(\\n            fixedTokenBalanceWad,\\n            int256(\\n                fixedFactor(true, termStartTimestampWad, termEndTimestampWad)\\n            )\\n        );\\n\\n        int256 variableCashflowWad = PRBMathSD59x18.mul(\\n            variableTokenBalanceWad,\\n            int256(variableFactorToMaturityWad)\\n        );\\n\\n        int256 cashflowWad = fixedCashflowWad + variableCashflowWad;\\n\\n        /// @dev convert back to non-fixed point representation\\n        cashflow = PRBMathSD59x18.toInt(cashflowWad);\\n    }\\n\\n    /// @notice Divide a given time in seconds by the number of seconds in a year\\n    /// @param timeInSecondsAsWad A time in seconds in Wad (i.e. scaled up by 10^18)\\n    /// @return timeInYearsWad An annualised factor of timeInSeconds, also in Wad\\n    function accrualFact(uint256 timeInSecondsAsWad)\\n        internal\\n        pure\\n        returns (uint256 timeInYearsWad)\\n    {\\n        timeInYearsWad = PRBMathUD60x18.div(\\n            timeInSecondsAsWad,\\n            SECONDS_IN_YEAR_IN_WAD\\n        );\\n    }\\n\\n    /// @notice Calculate the fixed factor for a position - that is, the percentage earned over\\n    /// the specified period of time, assuming 1% per year\\n    /// @param atMaturity Whether to calculate the factor at maturity (true), or now (false)\\n    /// @param termStartTimestampWad When does the period of time begin, in wei-seconds\\n    /// @param termEndTimestampWad When does the period of time end, in wei-seconds\\n    /// @return fixedFactorValueWad The fixed factor for the position (in Wad)\\n    function fixedFactor(\\n        bool atMaturity,\\n        uint256 termStartTimestampWad,\\n        uint256 termEndTimestampWad\\n    ) internal view returns (uint256 fixedFactorValueWad) {\\n        require(termEndTimestampWad > termStartTimestampWad, \\\"E<=S\\\");\\n\\n        require(Time.blockTimestampScaled() >= termStartTimestampWad, \\\"B.T<S\\\");\\n\\n        uint256 timeInSecondsWad;\\n\\n        if (\\n            atMaturity || (Time.blockTimestampScaled() >= termEndTimestampWad)\\n        ) {\\n            timeInSecondsWad = termEndTimestampWad - termStartTimestampWad;\\n        } else {\\n            timeInSecondsWad =\\n                Time.blockTimestampScaled() -\\n                termStartTimestampWad;\\n        }\\n\\n        uint256 timeInYearsWad = accrualFact(timeInSecondsWad);\\n        fixedFactorValueWad = PRBMathUD60x18.div(\\n            timeInYearsWad,\\n            ONE_HUNDRED_IN_WAD\\n        );\\n    }\\n\\n    /// @notice Calculate the fixed token balance for a position over a timespan\\n    /// @param amount0Wad A fixed amount\\n    /// @param excessBalanceWad Any excess balance from the variable side of the position\\n    /// @param termStartTimestampWad When does the period of time begin, in wei-seconds\\n    /// @param termEndTimestampWad When does the period of time end, in wei-seconds\\n    /// @return fixedTokenBalanceWad The fixed token balance for that time period\\n    function calculateFixedTokenBalance(\\n        int256 amount0Wad,\\n        int256 excessBalanceWad,\\n        uint256 termStartTimestampWad,\\n        uint256 termEndTimestampWad\\n    ) internal view returns (int256 fixedTokenBalanceWad) {\\n        require(termEndTimestampWad > termStartTimestampWad, \\\"E<=S\\\");\\n\\n        /// explain the math in simple terms\\n\\n        // expected fixed cashflow with unbalanced number of fixed tokens\\n        int256 exp1Wad = PRBMathSD59x18.mul(\\n            amount0Wad,\\n            int256(\\n                fixedFactor(true, termStartTimestampWad, termEndTimestampWad)\\n            )\\n        );\\n\\n        // fixed cashflow with balanced number of fixed tokens, this cashflow accounts for the excess balance accrued since\\n        // the inception of the IRS AMM\\n        int256 numeratorWad = exp1Wad - excessBalanceWad;\\n\\n        // fixed token balance that takes into account acrrued cashflows\\n        fixedTokenBalanceWad = PRBMathSD59x18.div(\\n            numeratorWad,\\n            int256(\\n                fixedFactor(true, termStartTimestampWad, termEndTimestampWad)\\n            )\\n        );\\n    }\\n\\n    /// @notice Represent excess values accrued in some period\\n    struct AccruedValues {\\n        int256 excessFixedAccruedBalanceWad;\\n        int256 excessVariableAccruedBalanceWad;\\n        int256 excessBalanceWad;\\n    }\\n\\n    /// @notice Calculate the excess balance of both sides of a position in Wad\\n    /// @param amount0Wad A fixed balance\\n    /// @param amount1Wad A variable balance\\n    /// @param accruedVariableFactorWad An annualised factor in wei-years\\n    /// @param termStartTimestampWad When does the period of time begin, in wei-seconds\\n    /// @param termEndTimestampWad When does the period of time end, in wei-seconds\\n    /// @return excessBalanceWad The excess balance in wad\\n    function getExcessBalance(\\n        int256 amount0Wad,\\n        int256 amount1Wad,\\n        uint256 accruedVariableFactorWad,\\n        uint256 termStartTimestampWad,\\n        uint256 termEndTimestampWad\\n    ) internal view returns (int256) {\\n        AccruedValues memory accruedValues;\\n\\n        accruedValues.excessFixedAccruedBalanceWad = PRBMathSD59x18.mul(\\n            amount0Wad,\\n            int256(\\n                fixedFactor(false, termStartTimestampWad, termEndTimestampWad)\\n            )\\n        );\\n\\n        accruedValues.excessVariableAccruedBalanceWad = PRBMathSD59x18.mul(\\n            amount1Wad,\\n            int256(accruedVariableFactorWad)\\n        );\\n\\n        /// @dev cashflows accrued since the inception of the IRS AMM\\n\\n        accruedValues.excessBalanceWad =\\n            accruedValues.excessFixedAccruedBalanceWad +\\n            accruedValues.excessVariableAccruedBalanceWad;\\n\\n        return accruedValues.excessBalanceWad;\\n    }\\n\\n    /// @notice Calculate the fixed token balance given both fixed and variable balances\\n    /// @param amount0 A fixed balance\\n    /// @param amount1 A variable balance\\n    /// @param accruedVariableFactorWad An annualised factor in wei-years\\n    /// @param termStartTimestampWad When does the period of time begin, in wei-seconds\\n    /// @param termEndTimestampWad When does the period of time end, in wei-seconds\\n    /// @return fixedTokenBalance The fixed token balance for that time period\\n    function getFixedTokenBalance(\\n        int256 amount0,\\n        int256 amount1,\\n        uint256 accruedVariableFactorWad,\\n        uint256 termStartTimestampWad,\\n        uint256 termEndTimestampWad\\n    ) internal view returns (int256 fixedTokenBalance) {\\n        if (\\n            !(((amount0 <= 0 && amount1 >= 0) ||\\n                (amount0 >= 0 && amount1 <= 0)) ||\\n                (amount0 == 0 && amount1 == 0))\\n        ) {\\n            revert AmountSignsSame();\\n        }\\n\\n        int256 amount0Wad = PRBMathSD59x18.fromInt(amount0);\\n        int256 amount1Wad = PRBMathSD59x18.fromInt(amount1);\\n\\n        require(termEndTimestampWad > termStartTimestampWad, \\\"E<=S\\\");\\n\\n        int256 excessBalanceWad = getExcessBalance(\\n            amount0Wad,\\n            amount1Wad,\\n            accruedVariableFactorWad,\\n            termStartTimestampWad,\\n            termEndTimestampWad\\n        );\\n\\n        int256 fixedTokenBalanceWad = calculateFixedTokenBalance(\\n            amount0Wad,\\n            excessBalanceWad,\\n            termStartTimestampWad,\\n            termEndTimestampWad\\n        );\\n\\n        fixedTokenBalance = PRBMathSD59x18.toInt(fixedTokenBalanceWad);\\n    }\\n}\\n\",\"keccak256\":\"0x639f7b110df49d70c792613a87beed88567fd3ec61db256b0282d47b69c6737c\",\"license\":\"MIT\"},\"contracts/core_libraries/MarginCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"prb-math/contracts/PRBMathUD60x18.sol\\\";\\nimport \\\"prb-math/contracts/PRBMathSD59x18.sol\\\";\\nimport \\\"../utils/TickMath.sol\\\";\\nimport \\\"../utils/SqrtPriceMath.sol\\\";\\nimport \\\"./FixedAndVariableMath.sol\\\";\\nimport \\\"./Position.sol\\\";\\nimport \\\"./Tick.sol\\\";\\nimport \\\"../interfaces/IFactory.sol\\\";\\nimport \\\"../interfaces/IMarginEngine.sol\\\";\\nimport \\\"../utils/FullMath.sol\\\";\\nimport \\\"../utils/FixedPoint96.sol\\\";\\n\\n/// @title Margin Calculator\\n/// @notice Margin Calculator Performs the calculations necessary to establish Margin Requirements on Voltz Protocol\\nlibrary MarginCalculator {\\n    // structs\\n\\n    struct ApyBoundVars {\\n        /// @dev In the litepaper the timeFactor is exp(-beta*(t-s)/t_max) where t is the maturity timestamp, s is the current timestamp and beta is a diffusion process parameter set via calibration, t_max is the max possible duration of an IRS AMM\\n        int256 timeFactorWad;\\n        /// @dev 1 - timeFactor\\n        int256 oneMinusTimeFactorWad;\\n        /// @dev k = (4 * alpha/sigmaSquared)\\n        int256 kWad;\\n        /// @dev zeta = (sigmaSquared*(1-timeFactor))/ 4 * beta\\n        int256 zetaWad;\\n        /// @dev lambdaNum = 4 * beta * timeFactor * historicalApy\\n        int256 lambdaNumWad;\\n        /// @dev lambdaDen = sigmaSquared * (1 - timeFactor)\\n        int256 lambdaDenWad;\\n        /// @dev lambda = lambdaNum / lambdaDen\\n        int256 lambdaWad;\\n        /// @dev critical value multiplier = 2(k+2lambda)\\n        int256 criticalValueMultiplierWad;\\n        /// @dev critical value = sqrt(2(k+2*lambda))*xiUpper (for upper bound calculation), critical value = sqrt(2(k+2*lambda))*xiLower (for lower bound calculation)\\n        int256 criticalValueWad;\\n    }\\n\\n    /// suggestions: do the below conversions using PRBMath\\n    int256 public constant ONE_WEI = 10**18;\\n\\n    /// @dev Seconds in a year\\n    int256 public constant SECONDS_IN_YEAR = 31536000 * ONE_WEI;\\n\\n    /// @dev In the litepaper the timeFactor is exp(-beta*(t-s)/t_max) where t is the maturity timestamp, and t_max is the max number of seconds for the IRS AMM duration, s is the current timestamp and beta is a diffusion process parameter set via calibration\\n    function computeTimeFactor(\\n        uint256 termEndTimestampWad,\\n        uint256 currentTimestampWad,\\n        IMarginEngine.MarginCalculatorParameters\\n            memory _marginCalculatorParameters\\n    ) internal pure returns (int256 timeFactorWad) {\\n        require(termEndTimestampWad > 0, \\\"termEndTimestamp must be > 0\\\");\\n        require(\\n            currentTimestampWad <= termEndTimestampWad,\\n            \\\"endTime must be > currentTime\\\"\\n        );\\n        require(_marginCalculatorParameters.betaWad != 0, \\\"parameters not set\\\");\\n\\n        int256 betaWad = _marginCalculatorParameters.betaWad;\\n        int256 tMaxWad = _marginCalculatorParameters.tMaxWad;\\n\\n        int256 scaledTimeWad = PRBMathSD59x18.div(\\n            (int256(termEndTimestampWad) - int256(currentTimestampWad)),\\n            tMaxWad\\n        );\\n\\n        int256 expInputWad = PRBMathSD59x18.mul((-betaWad), scaledTimeWad);\\n\\n        timeFactorWad = PRBMathSD59x18.exp(expInputWad);\\n    }\\n\\n    /// @notice Calculates an APY Upper or Lower Bound of a given underlying pool (e.g. Aave v2 USDC Lending Pool)\\n    /// @param termEndTimestampWad termEndTimestampScaled\\n    /// @param currentTimestampWad currentTimestampScaled\\n    /// @param historicalApyWad Geometric Mean Time Weighted Average APY (TWAPPY) of the underlying pool (e.g. Aave v2 USDC Lending Pool)\\n    /// @param isUpper isUpper = true ==> calculating the APY Upper Bound, otherwise APY Lower Bound\\n    /// @return apyBoundWad APY Upper or Lower Bound of a given underlying pool (e.g. Aave v2 USDC Lending Pool)\\n    function computeApyBound(\\n        uint256 termEndTimestampWad,\\n        uint256 currentTimestampWad,\\n        uint256 historicalApyWad,\\n        bool isUpper,\\n        IMarginEngine.MarginCalculatorParameters\\n            memory _marginCalculatorParameters\\n    ) internal pure returns (uint256 apyBoundWad) {\\n        ApyBoundVars memory apyBoundVars;\\n\\n        int256 beta4Wad = PRBMathSD59x18.mul(\\n            _marginCalculatorParameters.betaWad,\\n            PRBMathSD59x18.fromInt(4)\\n        );\\n\\n        int256 alpha4Wad = PRBMathSD59x18.mul(\\n            _marginCalculatorParameters.alphaWad,\\n            PRBMathSD59x18.fromInt(4)\\n        );\\n\\n        apyBoundVars.timeFactorWad = computeTimeFactor(\\n            termEndTimestampWad,\\n            currentTimestampWad,\\n            _marginCalculatorParameters\\n        );\\n\\n        apyBoundVars.oneMinusTimeFactorWad =\\n            PRBMathSD59x18.fromInt(1) -\\n            apyBoundVars.timeFactorWad;\\n\\n        apyBoundVars.kWad = PRBMathSD59x18.div(\\n            alpha4Wad,\\n            _marginCalculatorParameters.sigmaSquaredWad\\n        );\\n\\n        apyBoundVars.zetaWad = PRBMathSD59x18.div(\\n            PRBMathSD59x18.mul(\\n                _marginCalculatorParameters.sigmaSquaredWad,\\n                apyBoundVars.oneMinusTimeFactorWad\\n            ),\\n            beta4Wad\\n        );\\n\\n        apyBoundVars.lambdaNumWad = PRBMathSD59x18.mul(\\n            PRBMathSD59x18.mul(beta4Wad, apyBoundVars.timeFactorWad),\\n            int256(historicalApyWad)\\n        );\\n\\n        apyBoundVars.lambdaDenWad = PRBMathSD59x18.mul(\\n            _marginCalculatorParameters.sigmaSquaredWad,\\n            apyBoundVars.oneMinusTimeFactorWad\\n        );\\n\\n        apyBoundVars.lambdaWad = PRBMathSD59x18.div(\\n            apyBoundVars.lambdaNumWad,\\n            apyBoundVars.lambdaDenWad\\n        );\\n\\n        apyBoundVars.criticalValueMultiplierWad = PRBMathSD59x18.mul(\\n            (PRBMathSD59x18.mul(\\n                PRBMathSD59x18.fromInt(2),\\n                apyBoundVars.lambdaWad\\n            ) + apyBoundVars.kWad),\\n            (PRBMathSD59x18.fromInt(2))\\n        );\\n\\n        if (isUpper) {\\n            apyBoundVars.criticalValueWad = PRBMathSD59x18.mul(\\n                _marginCalculatorParameters.xiUpperWad,\\n                PRBMathSD59x18.sqrt(apyBoundVars.criticalValueMultiplierWad)\\n            );\\n        } else {\\n            apyBoundVars.criticalValueWad = PRBMathSD59x18.mul(\\n                _marginCalculatorParameters.xiLowerWad,\\n                PRBMathSD59x18.sqrt(apyBoundVars.criticalValueMultiplierWad)\\n            );\\n        }\\n\\n        int256 apyBoundIntWad = (isUpper)\\n            ? PRBMathSD59x18.mul(\\n                apyBoundVars.zetaWad,\\n                (apyBoundVars.kWad +\\n                    apyBoundVars.lambdaWad +\\n                    apyBoundVars.criticalValueWad)\\n            )\\n            : PRBMathSD59x18.mul(\\n                apyBoundVars.zetaWad,\\n                (apyBoundVars.kWad +\\n                    apyBoundVars.lambdaWad -\\n                    apyBoundVars.criticalValueWad)\\n            );\\n\\n        if (apyBoundIntWad < 0) {\\n            apyBoundWad = 0;\\n        } else {\\n            apyBoundWad = uint256(apyBoundIntWad);\\n        }\\n    }\\n\\n    /// @notice Calculates the Worst Case Variable Factor At Maturity\\n    /// @param timeInSecondsFromStartToMaturityWad Duration of a given IRS AMM (18 decimals)\\n    /// @param termEndTimestampWad termEndTimestampWad\\n    /// @param currentTimestampWad currentTimestampWad\\n    /// @param isFT isFT => we are dealing with a Fixed Taker (short) IRS position, otherwise it is a Variable Taker (long) IRS position\\n    /// @param isLM isLM => we are computing a Liquidation Margin otherwise computing an Initial Margin\\n    /// @param historicalApyWad Historical Average APY of the underlying pool (e.g. Aave v2 USDC Lending Pool)\\n    /// @return variableFactorWad The Worst Case Variable Factor At Maturity = APY Bound * accrualFactor(timeInYearsFromStartUntilMaturity) where APY Bound = APY Upper Bound for Fixed Takers and APY Lower Bound for Variable Takers (18 decimals)\\n    function worstCaseVariableFactorAtMaturity(\\n        uint256 timeInSecondsFromStartToMaturityWad,\\n        uint256 termEndTimestampWad,\\n        uint256 currentTimestampWad,\\n        bool isFT,\\n        bool isLM,\\n        uint256 historicalApyWad,\\n        IMarginEngine.MarginCalculatorParameters\\n            memory _marginCalculatorParameters\\n    ) internal pure returns (uint256 variableFactorWad) {\\n        uint256 timeInYearsFromStartUntilMaturityWad = FixedAndVariableMath\\n            .accrualFact(timeInSecondsFromStartToMaturityWad);\\n\\n        if (isFT) {\\n            if (isLM) {\\n                variableFactorWad = PRBMathUD60x18.mul(\\n                    computeApyBound(\\n                        termEndTimestampWad,\\n                        currentTimestampWad,\\n                        historicalApyWad,\\n                        true,\\n                        _marginCalculatorParameters\\n                    ),\\n                    timeInYearsFromStartUntilMaturityWad\\n                );\\n            } else {\\n                variableFactorWad = PRBMathUD60x18.mul(\\n                    PRBMathUD60x18.mul(\\n                        computeApyBound(\\n                            termEndTimestampWad,\\n                            currentTimestampWad,\\n                            historicalApyWad,\\n                            true,\\n                            _marginCalculatorParameters\\n                        ),\\n                        _marginCalculatorParameters.apyUpperMultiplierWad\\n                    ),\\n                    timeInYearsFromStartUntilMaturityWad\\n                );\\n            }\\n        } else {\\n            if (isLM) {\\n                variableFactorWad = PRBMathUD60x18.mul(\\n                    computeApyBound(\\n                        termEndTimestampWad,\\n                        currentTimestampWad,\\n                        historicalApyWad,\\n                        false,\\n                        _marginCalculatorParameters\\n                    ),\\n                    timeInYearsFromStartUntilMaturityWad\\n                );\\n            } else {\\n                variableFactorWad = PRBMathUD60x18.mul(\\n                    PRBMathUD60x18.mul(\\n                        computeApyBound(\\n                            termEndTimestampWad,\\n                            currentTimestampWad,\\n                            historicalApyWad,\\n                            false,\\n                            _marginCalculatorParameters\\n                        ),\\n                        _marginCalculatorParameters.apyLowerMultiplierWad\\n                    ),\\n                    timeInYearsFromStartUntilMaturityWad\\n                );\\n            }\\n        }\\n    }\\n\\n    struct SimulatedUnwindLocalVars {\\n        uint256 sqrtRatioCurrWad;\\n        uint256 fixedRateStartWad;\\n        uint256 upperDWad;\\n        uint256 scaledTimeWad;\\n        int256 expInputWad;\\n        int256 oneMinusTimeFactorWad;\\n        uint256 dWad;\\n        uint256 fixedRateCFWad;\\n        uint256 fixedTokenDeltaUnbalancedWad;\\n    }\\n\\n    // simulation of a swap without the need to involve the swap function\\n    /// @notice calculates the absolute fixed token delta unbalanced resulting from a simulated counterfactual unwind necessary to determine the minimum margin requirement of a trader\\n    /// @param variableTokenDeltaAbsolute absolute value of the variableTokenDelta for which the unwind is simulated\\n    /// @param sqrtRatioCurrX96 sqrtRatio necessary to calculate the starting fixed rate which is used to calculate the counterfactual unwind fixed rate\\n    /// @param startingFixedRateMultiplierWad the multiplier (lambda from the litepaper - minimum margin requirement equation) that is multiplied by the starting fixed rate to determine the deviation applied to the starting fixed rate (in Wad)\\n    /// @param termEndTimestampWad term end timestamp in wad\\n    /// @param currentTimestampWad current timestamp in wad\\n    /// @param tMaxWad the maximum duration for a Voltz Protocol IRS AMM\\n    /// @param gammaWad adjustable parameter that controls the rate of time decay applied to the deviation depending on time from now to maturity\\n    /// @param isFTUnwind isFTUnwind == true => the counterfactual unwind is in the Fixed Taker direction (from left to right along the VAMM), the opposite is true if isFTUnwind == false\\n    function getAbsoluteFixedTokenDeltaUnbalancedSimulatedUnwind(\\n        uint256 variableTokenDeltaAbsolute,\\n        uint160 sqrtRatioCurrX96,\\n        uint256 startingFixedRateMultiplierWad,\\n        uint256 fixedRateDeviationMinWad,\\n        uint256 termEndTimestampWad,\\n        uint256 currentTimestampWad,\\n        uint256 tMaxWad,\\n        uint256 gammaWad,\\n        bool isFTUnwind\\n    ) internal view returns (uint256 fixedTokenDeltaUnbalanced) {\\n        SimulatedUnwindLocalVars memory simulatedUnwindLocalVars;\\n\\n        // require checks\\n\\n        // calculate fixedRateStart\\n        simulatedUnwindLocalVars.sqrtRatioCurrWad = FullMath.mulDiv(\\n            PRBMathUD60x18.fromUint(1),\\n            sqrtRatioCurrX96,\\n            FixedPoint96.Q96\\n        );\\n\\n        simulatedUnwindLocalVars.fixedRateStartWad = PRBMathUD60x18.div(\\n            PRBMathUD60x18.fromUint(1),\\n            PRBMathUD60x18.mul(\\n                simulatedUnwindLocalVars.sqrtRatioCurrWad,\\n                simulatedUnwindLocalVars.sqrtRatioCurrWad\\n            )\\n        );\\n\\n        // calculate D (from the litepaper)\\n        simulatedUnwindLocalVars.upperDWad = PRBMathUD60x18.mul(\\n            simulatedUnwindLocalVars.fixedRateStartWad,\\n            startingFixedRateMultiplierWad\\n        );\\n\\n        if (simulatedUnwindLocalVars.upperDWad < fixedRateDeviationMinWad) {\\n            simulatedUnwindLocalVars.upperDWad = fixedRateDeviationMinWad;\\n        }\\n\\n        // calculate d (from the litepaper)\\n\\n        simulatedUnwindLocalVars.scaledTimeWad = PRBMathUD60x18.div(\\n            (termEndTimestampWad - currentTimestampWad),\\n            tMaxWad\\n        );\\n\\n        simulatedUnwindLocalVars.expInputWad = PRBMathSD59x18.mul(\\n            (-int256(gammaWad)),\\n            int256(simulatedUnwindLocalVars.scaledTimeWad)\\n        );\\n\\n        simulatedUnwindLocalVars.oneMinusTimeFactorWad =\\n            PRBMathSD59x18.fromInt(1) -\\n            PRBMathSD59x18.exp(simulatedUnwindLocalVars.expInputWad);\\n\\n        simulatedUnwindLocalVars.dWad = PRBMathUD60x18.mul(\\n            simulatedUnwindLocalVars.upperDWad,\\n            uint256(simulatedUnwindLocalVars.oneMinusTimeFactorWad)\\n        );\\n\\n        // calculate counterfactual fixed rate\\n\\n        if (isFTUnwind) {\\n            if (\\n                simulatedUnwindLocalVars.fixedRateStartWad >\\n                simulatedUnwindLocalVars.dWad\\n            ) {\\n                simulatedUnwindLocalVars.fixedRateCFWad =\\n                    simulatedUnwindLocalVars.fixedRateStartWad -\\n                    simulatedUnwindLocalVars.dWad;\\n            } else {\\n                simulatedUnwindLocalVars.fixedRateCFWad = 0;\\n            }\\n        } else {\\n            simulatedUnwindLocalVars.fixedRateCFWad =\\n                simulatedUnwindLocalVars.fixedRateStartWad +\\n                simulatedUnwindLocalVars.dWad;\\n        }\\n\\n        // calculate fixedTokenDeltaUnbalancedWad\\n\\n        simulatedUnwindLocalVars.fixedTokenDeltaUnbalancedWad = PRBMathUD60x18\\n            .mul(\\n                PRBMathUD60x18.fromUint(variableTokenDeltaAbsolute),\\n                simulatedUnwindLocalVars.fixedRateCFWad\\n            );\\n\\n        // calculate fixedTokenDeltaUnbalanced\\n\\n        fixedTokenDeltaUnbalanced = PRBMathUD60x18.toUint(\\n            simulatedUnwindLocalVars.fixedTokenDeltaUnbalancedWad\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x0a2ba8dca7c063c70e9b55a34956b495ad47e0dafbcaf5545daaecbbd468b11e\",\"license\":\"MIT\"},\"contracts/core_libraries/Position.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/LiquidityMath.sol\\\";\\nimport \\\"../utils/FixedPoint128.sol\\\";\\nimport \\\"../utils/FullMath.sol\\\";\\nimport \\\"prb-math/contracts/PRBMathSD59x18.sol\\\";\\nimport \\\"prb-math/contracts/PRBMathUD60x18.sol\\\";\\n\\n/// @title Position\\n/// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary\\n/// @dev Positions store additional state for tracking fees owed to the position as well as their fixed and variable token balances\\nlibrary Position {\\n    using Position for Position.Info;\\n\\n    // info stored for each user's position\\n    struct Info {\\n        // has the position been already burned\\n        // a burned position can no longer support new IRS contracts but still needs to cover settlement cash-flows of on-going IRS contracts it entered\\n        // bool isBurned;, equivalent to having zero liquidity\\n        // is position settled\\n        bool isSettled;\\n        // the amount of liquidity owned by this position\\n        uint128 _liquidity;\\n        // current margin of the position in terms of the underlyingToken\\n        int256 margin;\\n        // fixed token growth per unit of liquidity as of the last update to liquidity or fixed/variable token balance\\n        int256 fixedTokenGrowthInsideLastX128;\\n        // variable token growth per unit of liquidity as of the last update to liquidity or fixed/variable token balance\\n        int256 variableTokenGrowthInsideLastX128;\\n        // current Fixed Token balance of the position, 1 fixed token can be redeemed for 1% APY * (annualised amm term) at the maturity of the amm\\n        // assuming 1 token worth of notional \\\"deposited\\\" in the underlying pool at the inception of the amm\\n        // can be negative/positive/zero\\n        int256 fixedTokenBalance;\\n        // current Variable Token Balance of the position, 1 variable token can be redeemed for underlyingPoolAPY*(annualised amm term) at the maturity of the amm\\n        // assuming 1 token worth of notional \\\"deposited\\\" in the underlying pool at the inception of the amm\\n        // can be negative/positive/zero\\n        int256 variableTokenBalance;\\n        // fee growth per unit of liquidity as of the last update to liquidity or fees owed (via the margin)\\n        uint256 feeGrowthInsideLastX128;\\n    }\\n\\n    /// @notice Returns the Info struct of a position, given an owner and position boundaries\\n    /// @param self The mapping containing all user positions\\n    /// @param owner The address of the position owner\\n    /// @param tickLower The lower tick boundary of the position\\n    /// @param tickUpper The upper tick boundary of the position\\n    /// @return position The position info struct of the given owners' position\\n    function get(\\n        mapping(bytes32 => Info) storage self,\\n        address owner,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) internal view returns (Position.Info storage position) {\\n        position = self[\\n            keccak256(abi.encodePacked(owner, tickLower, tickUpper))\\n        ];\\n    }\\n\\n    function settlePosition(Info storage self) internal {\\n        self.isSettled = true;\\n    }\\n\\n    /// @notice Updates the Info struct of a position by changing the amount of margin according to marginDelta\\n    /// @param self Position Info Struct of the Liquidity Provider\\n    /// @param marginDelta Change in the margin account of the position (in wei)\\n    function updateMarginViaDelta(Info storage self, int256 marginDelta)\\n        internal\\n    {\\n        Info memory _self = self;\\n        self.margin = _self.margin + marginDelta;\\n    }\\n\\n    /// @notice Updates the Info struct of a position by changing the fixed and variable token balances of the position\\n    /// @param self Position Info struct of the liquidity provider\\n    /// @param fixedTokenBalanceDelta Change in the number of fixed tokens in the position's fixed token balance\\n    /// @param variableTokenBalanceDelta Change in the number of variable tokens in the position's variable token balance\\n    function updateBalancesViaDeltas(\\n        Info storage self,\\n        int256 fixedTokenBalanceDelta,\\n        int256 variableTokenBalanceDelta\\n    ) internal {\\n        if (fixedTokenBalanceDelta != 0 || variableTokenBalanceDelta != 0) {\\n            Info memory _self = self;\\n\\n            self.fixedTokenBalance =\\n                _self.fixedTokenBalance +\\n                fixedTokenBalanceDelta;\\n            self.variableTokenBalance =\\n                _self.variableTokenBalance +\\n                variableTokenBalanceDelta;\\n        }\\n    }\\n\\n    /// @notice Returns Fee Delta = (feeGrowthInside-feeGrowthInsideLast) * liquidity of the position\\n    /// @param self position info struct represeting a liquidity provider\\n    /// @param feeGrowthInsideX128 fee growth per unit of liquidity as of now\\n    /// @return _feeDelta Fee Delta\\n    function calculateFeeDelta(Info storage self, uint256 feeGrowthInsideX128)\\n        internal\\n        pure\\n        returns (uint256 _feeDelta)\\n    {\\n        Info memory _self = self;\\n\\n        unchecked {\\n            _feeDelta = FullMath.mulDiv(\\n                feeGrowthInsideX128 - _self.feeGrowthInsideLastX128,\\n                _self._liquidity,\\n                FixedPoint128.Q128\\n            );\\n        }\\n    }\\n\\n    /// @notice Returns Fixed and Variable Token Deltas\\n    /// @param self position info struct represeting a liquidity provider\\n    /// @param fixedTokenGrowthInsideX128 fixed token growth per unit of liquidity as of now (in wei)\\n    /// @param variableTokenGrowthInsideX128 variable token growth per unit of liquidity as of now (in wei)\\n    /// @return _fixedTokenDelta = (fixedTokenGrowthInside-fixedTokenGrowthInsideLast) * liquidity of a position\\n    /// @return _variableTokenDelta = (variableTokenGrowthInside-variableTokenGrowthInsideLast) * liquidity of a position\\n    function calculateFixedAndVariableDelta(\\n        Info storage self,\\n        int256 fixedTokenGrowthInsideX128,\\n        int256 variableTokenGrowthInsideX128\\n    )\\n        internal\\n        pure\\n        returns (int256 _fixedTokenDelta, int256 _variableTokenDelta)\\n    {\\n        Info memory _self = self;\\n\\n        int256 fixedTokenGrowthInsideDeltaX128 = fixedTokenGrowthInsideX128 -\\n            _self.fixedTokenGrowthInsideLastX128;\\n\\n        if (fixedTokenGrowthInsideDeltaX128 > 0) {\\n            _fixedTokenDelta = int256(\\n                FullMath.mulDiv(\\n                    uint256(fixedTokenGrowthInsideDeltaX128),\\n                    _self._liquidity,\\n                    FixedPoint128.Q128\\n                )\\n            );\\n        } else {\\n            _fixedTokenDelta = -int256(\\n                FullMath.mulDiv(\\n                    uint256(-fixedTokenGrowthInsideDeltaX128),\\n                    _self._liquidity,\\n                    FixedPoint128.Q128\\n                )\\n            );\\n        }\\n\\n        int256 variableTokenGrowthInsideDeltaX128 = variableTokenGrowthInsideX128 -\\n                _self.variableTokenGrowthInsideLastX128;\\n\\n        if (variableTokenGrowthInsideDeltaX128 > 0) {\\n            _variableTokenDelta = int256(\\n                FullMath.mulDiv(\\n                    uint256(variableTokenGrowthInsideDeltaX128),\\n                    _self._liquidity,\\n                    FixedPoint128.Q128\\n                )\\n            );\\n        } else {\\n            _variableTokenDelta = -int256(\\n                FullMath.mulDiv(\\n                    uint256(-variableTokenGrowthInsideDeltaX128),\\n                    _self._liquidity,\\n                    FixedPoint128.Q128\\n                )\\n            );\\n        }\\n    }\\n\\n    /// @notice Updates fixedTokenGrowthInsideLast and variableTokenGrowthInsideLast to the current values\\n    /// @param self position info struct represeting a liquidity provider\\n    /// @param fixedTokenGrowthInsideX128 fixed token growth per unit of liquidity as of now\\n    /// @param variableTokenGrowthInsideX128 variable token growth per unit of liquidity as of now\\n    function updateFixedAndVariableTokenGrowthInside(\\n        Info storage self,\\n        int256 fixedTokenGrowthInsideX128,\\n        int256 variableTokenGrowthInsideX128\\n    ) internal {\\n        self.fixedTokenGrowthInsideLastX128 = fixedTokenGrowthInsideX128;\\n        self.variableTokenGrowthInsideLastX128 = variableTokenGrowthInsideX128;\\n    }\\n\\n    /// @notice Updates feeGrowthInsideLast to the current value\\n    /// @param self position info struct represeting a liquidity provider\\n    /// @param feeGrowthInsideX128 fee growth per unit of liquidity as of now\\n    function updateFeeGrowthInside(\\n        Info storage self,\\n        uint256 feeGrowthInsideX128\\n    ) internal {\\n        self.feeGrowthInsideLastX128 = feeGrowthInsideX128;\\n    }\\n\\n    /// @notice Updates position's liqudity following either mint or a burn\\n    /// @param self The individual position to update\\n    /// @param liquidityDelta The change in pool liquidity as a result of the position update\\n    function updateLiquidity(Info storage self, int128 liquidityDelta)\\n        internal\\n    {\\n        Info memory _self = self;\\n\\n        uint128 liquidityNext;\\n        if (liquidityDelta == 0) {\\n            require(_self._liquidity > 0, \\\"NP\\\"); // disallow pokes for 0 liquidity positions\\n            liquidityNext = _self._liquidity;\\n        } else {\\n            liquidityNext = LiquidityMath.addDelta(\\n                _self._liquidity,\\n                liquidityDelta\\n            );\\n        }\\n\\n        if (liquidityDelta != 0) self._liquidity = liquidityNext;\\n    }\\n}\\n\",\"keccak256\":\"0x92845ee9d06ece68249d9c061749a0b5e6acb4216985e7f33c879b8888143399\",\"license\":\"MIT\"},\"contracts/core_libraries/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport \\\"../interfaces/IERC20Minimal.sol\\\";\\n\\n// FROM https://github.com/Rari-Capital/solmate\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\nlibrary SafeTransferLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(callStatus, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        IERC20Minimal token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(\\n                freeMemoryPointer,\\n                0x23b872dd00000000000000000000000000000000000000000000000000000000\\n            ) // Begin with the function selector.\\n            mstore(\\n                add(freeMemoryPointer, 4),\\n                and(from, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Mask and append the \\\"from\\\" argument.\\n            mstore(\\n                add(freeMemoryPointer, 36),\\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\\n        }\\n\\n        require(\\n            didLastOptionalReturnCallSucceed(callStatus),\\n            \\\"TRANSFER_FROM_FAILED\\\"\\n        );\\n    }\\n\\n    function safeTransfer(\\n        IERC20Minimal token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(\\n                freeMemoryPointer,\\n                0xa9059cbb00000000000000000000000000000000000000000000000000000000\\n            ) // Begin with the function selector.\\n            mstore(\\n                add(freeMemoryPointer, 4),\\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(\\n            didLastOptionalReturnCallSucceed(callStatus),\\n            \\\"TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    function safeApprove(\\n        IERC20Minimal token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(\\n                freeMemoryPointer,\\n                0x095ea7b300000000000000000000000000000000000000000000000000000000\\n            ) // Begin with the function selector.\\n            mstore(\\n                add(freeMemoryPointer, 4),\\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(bool callStatus)\\n        private\\n        pure\\n        returns (bool success)\\n    {\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                success := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                success := 0\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb43369b14aab87878699998537ee55ea52c151b1528054e1ed1b8c688332c2e4\",\"license\":\"AGPL-3.0-only\"},\"contracts/core_libraries/Tick.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/SafeCast.sol\\\";\\nimport \\\"../utils/TickMath.sol\\\";\\nimport \\\"../utils/LiquidityMath.sol\\\";\\n\\n// import \\\"../utils/Printer.sol\\\";\\n\\n/// @title Tick\\n/// @notice Contains functions for managing tick processes and relevant calculations\\nlibrary Tick {\\n    using SafeCast for int256;\\n\\n    // info stored for each initialized individual tick\\n    struct Info {\\n        // the total position liquidity that references this tick\\n        uint128 liquidityGross;\\n        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\\n        int128 liquidityNet;\\n        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\\n        // only has relative meaning, not absolute \\u2014 the value depends on when the tick is initialized\\n        int256 fixedTokenGrowthOutsideX128;\\n        int256 variableTokenGrowthOutsideX128;\\n        uint256 feeGrowthOutsideX128;\\n        // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0\\n        // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks\\n        bool initialized;\\n    }\\n\\n    /// @notice Derives max liquidity per tick from given tick spacing\\n    /// @dev Executed within the pool constructor\\n    /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`\\n    ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...\\n    /// @return The max liquidity per tick\\n    function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing)\\n        internal\\n        pure\\n        returns (uint128)\\n    {\\n        int24 minTick = (TickMath.MIN_TICK / tickSpacing) * tickSpacing;\\n        int24 maxTick = (TickMath.MAX_TICK / tickSpacing) * tickSpacing;\\n        uint24 numTicks = uint24((maxTick - minTick) / tickSpacing) + 1;\\n        return type(uint128).max / numTicks;\\n    }\\n\\n    /// @dev Common checks for valid tick inputs.\\n    function checkTicks(int24 tickLower, int24 tickUpper) internal pure {\\n        require(tickLower < tickUpper, \\\"TLU\\\");\\n        require(tickLower >= TickMath.MIN_TICK, \\\"TLM\\\");\\n        require(tickUpper <= TickMath.MAX_TICK, \\\"TUM\\\");\\n    }\\n\\n    function getFeeGrowthInside(\\n        mapping(int24 => Tick.Info) storage self,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        int24 tickCurrent,\\n        uint256 feeGrowthGlobalX128\\n    ) internal view returns (uint256 feeGrowthInsideX128) {\\n        unchecked {\\n            Info storage lower = self[tickLower];\\n            Info storage upper = self[tickUpper];\\n\\n            // calculate fee growth below\\n            uint256 feeGrowthBelowX128;\\n\\n            if (tickCurrent >= tickLower) {\\n                feeGrowthBelowX128 = lower.feeGrowthOutsideX128;\\n            } else {\\n                feeGrowthBelowX128 =\\n                    feeGrowthGlobalX128 -\\n                    lower.feeGrowthOutsideX128;\\n            }\\n\\n            // calculate fee growth above\\n            uint256 feeGrowthAboveX128;\\n\\n            if (tickCurrent < tickUpper) {\\n                feeGrowthAboveX128 = upper.feeGrowthOutsideX128;\\n            } else {\\n                feeGrowthAboveX128 =\\n                    feeGrowthGlobalX128 -\\n                    upper.feeGrowthOutsideX128;\\n            }\\n\\n            feeGrowthInsideX128 =\\n                feeGrowthGlobalX128 -\\n                (feeGrowthBelowX128 + feeGrowthAboveX128);\\n        }\\n    }\\n\\n    struct VariableTokenGrowthInsideParams {\\n        int24 tickLower;\\n        int24 tickUpper;\\n        int24 tickCurrent;\\n        int256 variableTokenGrowthGlobalX128;\\n    }\\n\\n    function getVariableTokenGrowthInside(\\n        mapping(int24 => Tick.Info) storage self,\\n        VariableTokenGrowthInsideParams memory params\\n    ) internal view returns (int256 variableTokenGrowthInsideX128) {\\n        Info storage lower = self[params.tickLower];\\n        Info storage upper = self[params.tickUpper];\\n\\n        // calculate the VariableTokenGrowth below\\n        int256 variableTokenGrowthBelowX128;\\n\\n        if (params.tickCurrent >= params.tickLower) {\\n            variableTokenGrowthBelowX128 = lower.variableTokenGrowthOutsideX128;\\n        } else {\\n            variableTokenGrowthBelowX128 =\\n                params.variableTokenGrowthGlobalX128 -\\n                lower.variableTokenGrowthOutsideX128;\\n        }\\n\\n        // calculate the VariableTokenGrowth above\\n        int256 variableTokenGrowthAboveX128;\\n\\n        if (params.tickCurrent < params.tickUpper) {\\n            variableTokenGrowthAboveX128 = upper.variableTokenGrowthOutsideX128;\\n        } else {\\n            variableTokenGrowthAboveX128 =\\n                params.variableTokenGrowthGlobalX128 -\\n                upper.variableTokenGrowthOutsideX128;\\n        }\\n\\n        // do we need an unchecked block in here (given we are dealing with an int256)?\\n        variableTokenGrowthInsideX128 =\\n            params.variableTokenGrowthGlobalX128 -\\n            (variableTokenGrowthBelowX128 + variableTokenGrowthAboveX128);\\n    }\\n\\n    struct FixedTokenGrowthInsideParams {\\n        int24 tickLower;\\n        int24 tickUpper;\\n        int24 tickCurrent;\\n        int256 fixedTokenGrowthGlobalX128;\\n    }\\n\\n    function getFixedTokenGrowthInside(\\n        mapping(int24 => Tick.Info) storage self,\\n        FixedTokenGrowthInsideParams memory params\\n    ) internal view returns (int256 fixedTokenGrowthInsideX128) {\\n        Info storage lower = self[params.tickLower];\\n        Info storage upper = self[params.tickUpper];\\n\\n        // calculate the fixedTokenGrowth below\\n        int256 fixedTokenGrowthBelowX128;\\n\\n        if (params.tickCurrent >= params.tickLower) {\\n            fixedTokenGrowthBelowX128 = lower.fixedTokenGrowthOutsideX128;\\n        } else {\\n            fixedTokenGrowthBelowX128 =\\n                params.fixedTokenGrowthGlobalX128 -\\n                lower.fixedTokenGrowthOutsideX128;\\n        }\\n\\n        // calculate the fixedTokenGrowth above\\n        int256 fixedTokenGrowthAboveX128;\\n\\n        if (params.tickCurrent < params.tickUpper) {\\n            fixedTokenGrowthAboveX128 = upper.fixedTokenGrowthOutsideX128;\\n        } else {\\n            fixedTokenGrowthAboveX128 =\\n                params.fixedTokenGrowthGlobalX128 -\\n                upper.fixedTokenGrowthOutsideX128;\\n        }\\n\\n        // do we need an unchecked block in here (given we are dealing with an int256)?\\n        fixedTokenGrowthInsideX128 =\\n            params.fixedTokenGrowthGlobalX128 -\\n            (fixedTokenGrowthBelowX128 + fixedTokenGrowthAboveX128);\\n    }\\n\\n    /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa\\n    /// @param self The mapping containing all tick information for initialized ticks\\n    /// @param tick The tick that will be updated\\n    /// @param tickCurrent The current tick\\n    /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)\\n    /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick\\n    /// @param maxLiquidity The maximum liquidity allocation for a single tick\\n    /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa\\n    function update(\\n        mapping(int24 => Tick.Info) storage self,\\n        int24 tick,\\n        int24 tickCurrent,\\n        int128 liquidityDelta,\\n        int256 fixedTokenGrowthGlobalX128,\\n        int256 variableTokenGrowthGlobalX128,\\n        uint256 feeGrowthGlobalX128,\\n        bool upper,\\n        uint128 maxLiquidity\\n    ) internal returns (bool flipped) {\\n        Tick.Info storage info = self[tick];\\n\\n        uint128 liquidityGrossBefore = info.liquidityGross;\\n        uint128 liquidityGrossAfter = LiquidityMath.addDelta(\\n            liquidityGrossBefore,\\n            liquidityDelta\\n        );\\n\\n        require(liquidityGrossAfter <= maxLiquidity, \\\"LO\\\");\\n\\n        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);\\n\\n        if (liquidityGrossBefore == 0) {\\n            // by convention, we assume that all growth before a tick was initialized happened _below_ the tick\\n            if (tick <= tickCurrent) {\\n                info.feeGrowthOutsideX128 = feeGrowthGlobalX128;\\n\\n                info.fixedTokenGrowthOutsideX128 = fixedTokenGrowthGlobalX128;\\n\\n                info\\n                    .variableTokenGrowthOutsideX128 = variableTokenGrowthGlobalX128;\\n            }\\n\\n            info.initialized = true;\\n        }\\n\\n        /// check shouldn't we unintialize the tick if liquidityGrossAfter = 0?\\n\\n        info.liquidityGross = liquidityGrossAfter;\\n\\n        /// add comments\\n        // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)\\n        info.liquidityNet = upper\\n            ? info.liquidityNet - liquidityDelta\\n            : info.liquidityNet + liquidityDelta;\\n    }\\n\\n    /// @notice Clears tick data\\n    /// @param self The mapping containing all initialized tick information for initialized ticks\\n    /// @param tick The tick that will be cleared\\n    function clear(mapping(int24 => Tick.Info) storage self, int24 tick)\\n        internal\\n    {\\n        delete self[tick];\\n    }\\n\\n    /// @notice Transitions to next tick as needed by price movement\\n    /// @param self The mapping containing all tick information for initialized ticks\\n    /// @param tick The destination tick of the transition\\n    /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)\\n    function cross(\\n        mapping(int24 => Tick.Info) storage self,\\n        int24 tick,\\n        int256 fixedTokenGrowthGlobalX128,\\n        int256 variableTokenGrowthGlobalX128,\\n        uint256 feeGrowthGlobalX128\\n    ) internal returns (int128 liquidityNet) {\\n        Tick.Info storage info = self[tick];\\n\\n        info.feeGrowthOutsideX128 =\\n            feeGrowthGlobalX128 -\\n            info.feeGrowthOutsideX128;\\n\\n        info.fixedTokenGrowthOutsideX128 =\\n            fixedTokenGrowthGlobalX128 -\\n            info.fixedTokenGrowthOutsideX128;\\n\\n        info.variableTokenGrowthOutsideX128 =\\n            variableTokenGrowthGlobalX128 -\\n            info.variableTokenGrowthOutsideX128;\\n\\n        liquidityNet = info.liquidityNet;\\n    }\\n}\\n\",\"keccak256\":\"0xd29779440f02034af54a1e61fafa1ba4969232ef0cb7ec8b3045a62903d52109\",\"license\":\"MIT\"},\"contracts/core_libraries/Time.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"prb-math/contracts/PRBMathUD60x18.sol\\\";\\n\\nlibrary Time {\\n    uint256 private constant MAX_UINT32 = 2**32 - 1;\\n    uint256 public constant SECONDS_IN_DAY_WAD = 86400 * 10**18; /// convert into WAD via PRB\\n\\n    /// @notice Calculate block.timestamp to wei precision\\n    /// @return Current timestamp in wei-seconds (1/1e18)\\n    function blockTimestampScaled() internal view returns (uint256) {\\n        // solhint-disable-next-line not-rely-on-time\\n        return PRBMathUD60x18.fromUint(block.timestamp);\\n    }\\n\\n    /// @dev Returns the block timestamp truncated to 32 bits, checking for overflow.\\n    function blockTimestampTruncated() internal view returns (uint32) {\\n        return timestampAsUint32(block.timestamp);\\n    }\\n\\n    function timestampAsUint32(uint256 _timestamp)\\n        internal\\n        pure\\n        returns (uint32 timestamp)\\n    {\\n        require(_timestamp <= MAX_UINT32, \\\"TSOFLOW\\\");\\n        return uint32(_timestamp);\\n    }\\n\\n    function isCloseToMaturityOrBeyondMaturity(uint256 termEndTimestampWad)\\n        internal\\n        view\\n        returns (bool vammInactive)\\n    {\\n        uint256 currentTimestamp = Time.blockTimestampScaled();\\n\\n        if (currentTimestamp >= termEndTimestampWad) {\\n            vammInactive = true;\\n        } else {\\n            uint256 timeDelta = termEndTimestampWad - currentTimestamp;\\n            if (timeDelta <= SECONDS_IN_DAY_WAD) {\\n                vammInactive = true;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x26c357d7c6e1e7b33d280b45725030f70e7bacba78f95567e906d665215eb989\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20Minimal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Minimal ERC20 interface for Voltz\\n/// @notice Contains a subset of the full ERC20 interface that is used in Voltz\\ninterface IERC20Minimal {\\n    /// @notice Returns the balance of a token\\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\\n    /// @return The number of tokens held by the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\\n    /// @param recipient The account that will receive the amount transferred\\n    /// @param amount The number of tokens to send from the sender to the recipient\\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /// @notice Returns the current allowance given to a spender by an owner\\n    /// @param owner The account of the token owner\\n    /// @param spender The account of the token spender\\n    /// @return The current allowance granted by `owner` to `spender`\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\\n    /// @param amount The amount of tokens allowed to be used by `spender`\\n    /// @return Returns true for a successful approval, false for unsuccessful\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\\n    /// @param sender The account from which the transfer will be initiated\\n    /// @param recipient The recipient of the transfer\\n    /// @param amount The amount of the transfer\\n    /// @return Returns true for a successful transfer, false for unsuccessful\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\\n    /// @param value The amount of tokens that were transferred\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\\n    /// @param owner The account that approved spending of its tokens\\n    /// @param spender The account for which the spending allowance was modified\\n    /// @param value The new allowance from the owner to the spender\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\",\"keccak256\":\"0xc1ba0d0f234eb2528c805c8b6fec68d724a2300df2e07efc95015da11e17d85b\",\"license\":\"MIT\"},\"contracts/interfaces/IFCM.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IMarginEngine.sol\\\";\\n\\ninterface IFCM {\\n    /// @notice Initiate a Fully Collateralised Fixed Taker Swap\\n    /// @param notional amount of notional (in terms of the underlying token) to trade\\n    /// @param sqrtPriceLimitX96 the sqrtPriceLimit (in binary fixed point math notation) beyond which swaps won't be executed\\n    /// @dev An example of an initiated fully collateralised fixed taker swap is a scenario where a trader with 100aTokens wishes to get a fixed return on them\\n    /// @dev they can choose to deposit their 100aTokens into the FCM (enter into a fixed taker position with a notional of 100) to swap variable vashflows from the aTokens\\n    /// @dev with the fixed cashflows from the variable takers\\n    function initiateFullyCollateralisedFixedTakerSwap(\\n        uint256 notional,\\n        uint160 sqrtPriceLimitX96\\n    ) external;\\n\\n    /// @notice Unwind a Fully Collateralised Fixed Taker Swap\\n    /// @param notionalToUnwind The amount of notional of the original Fully Collateralised Fixed Taker swap to be unwound at the current VAMM fixed rates\\n    /// @param sqrtPriceLimitX96 the sqrtPriceLimit (in binary fixed point math notation) beyond which the unwind swaps won't be executed\\n    /// @dev The purpose of this function is to let fully collateralised fixed takers to exist their swaps by entering into variable taker positions against the VAMM\\n    /// @dev thus effectively releasing the margin in yield bearing tokens from the fixed swap contract\\n    function unwindFullyCollateralisedFixedTakerSwap(\\n        uint256 notionalToUnwind,\\n        uint160 sqrtPriceLimitX96\\n    ) external;\\n\\n    /// @notice Settle Trader\\n    /// @dev this function in the fcm let's traders settle with the MarginEngine based on their settlement cashflows which is a functon of their fixed and variable token balances\\n    function settleTrader() external;\\n\\n    /// @notice\\n    /// @param _account address of the position owner from the MarginEngine who wishes to settle with the FCM in underlying tokens\\n    /// @param marginDeltaInUnderlyingTokens amount in terms of underlying tokens that needs to be settled with the trader from the MarginEngine\\n    function transferMarginToMarginEngineTrader(\\n        address _account,\\n        uint256 marginDeltaInUnderlyingTokens\\n    ) external;\\n\\n    /// @notice initialize is the constructor for the proxy instances of the FCM\\n    /// @dev \\\"constructor\\\" for proxy instances\\n    /// @dev in the initialize function we set the vamm and the margiEngine associated with the fcm\\n    /// @dev different FCM implementations are free to have different implementations for the initialisation logic\\n    function initialize(address _vammAddress, address _marginEngineAddress)\\n        external;\\n\\n    /// @notice Margine Engine linked to the Full Collateralisation Module\\n    /// @return marginEngine Margine Engine linked to the Full Collateralisation Module\\n    function marginEngine() external view returns (IMarginEngine);\\n}\\n\",\"keccak256\":\"0x1bd6d05ea71ad14613ab53dd96b258b967e2834bd27802c2e77d89e6c0e4aa5c\",\"license\":\"MIT\"},\"contracts/interfaces/IFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n/// @title The interface for the Voltz AMM Factory\\n/// @notice The AMM Factory facilitates creation of Voltz AMMs\\ninterface IFactory {\\n    event IrsInstanceDeployed(\\n        address indexed underlyingToken,\\n        address indexed rateOracle,\\n        uint256 termStartTimestampWad,\\n        uint256 termEndTimestampWad,\\n        int24 tickSpacing,\\n        address marginEngine,\\n        address vamm,\\n        address fcm\\n    );\\n\\n    event MasterFCMSet(\\n        address masterFCMAddressOld,\\n        address masterFCMAddress,\\n        uint8 yieldBearingProtocolID\\n    );\\n\\n    function setApproval(address intAddress, bool allowIntegration) external;\\n\\n    function isApproved(address _owner, address intAddress)\\n        external\\n        view\\n        returns (bool);\\n\\n    function setMasterFCM(address masterFCMAddress, address _rateOracle)\\n        external;\\n\\n    function getVAMMAddress(\\n        address _underlyingToken,\\n        address _rateOracle,\\n        uint256 _termStartTimestampWad,\\n        uint256 _termEndTimestampWad,\\n        int24 _tickSpacing\\n    ) external view returns (address);\\n\\n    function getMarginEngineAddress(\\n        address _underlyingToken,\\n        address _rateOracle,\\n        uint256 _termStartTimestampWad,\\n        uint256 _termEndTimestampWad,\\n        int24 _tickSpacing\\n    ) external view returns (address);\\n\\n    function getFCMAddress(\\n        address _underlyingToken,\\n        address _rateOracle,\\n        uint256 _termStartTimestampWad,\\n        uint256 _termEndTimestampWad,\\n        int24 _tickSpacing\\n    ) external view returns (address);\\n\\n    function masterVAMM() external view returns (address);\\n\\n    function masterMarginEngine() external view returns (address);\\n\\n    /// @notice Deploys the contracts required for a new Interest Rate Swap instance\\n    function deployIrsInstance(\\n        address _underlyingToken,\\n        address _rateOracle,\\n        uint256 _termStartTimestampWad,\\n        uint256 _termEndTimestampWad,\\n        int24 _tickSpacing\\n    )\\n        external\\n        returns (\\n            address marginEngineProxy,\\n            address vammProxy,\\n            address fcmProxy\\n        );\\n\\n    function masterFCMs(uint8 yieldBearingProtocolID)\\n        external\\n        returns (address masterFCMAddress);\\n}\\n\",\"keccak256\":\"0xac2c0042640dffc1904078ebe0fdf04670a4af93af6440f18b8716a502b517ee\",\"license\":\"GPL-2.0-or-later\"},\"contracts/interfaces/IMarginEngine.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"./IVAMM.sol\\\";\\nimport \\\"./IPositionStructs.sol\\\";\\nimport \\\"../core_libraries/Position.sol\\\";\\nimport \\\"./rate_oracles/IRateOracle.sol\\\";\\nimport \\\"./IFCM.sol\\\";\\nimport \\\"./IFactory.sol\\\";\\nimport \\\"./IERC20Minimal.sol\\\";\\n\\ninterface IMarginEngine is IPositionStructs {\\n    // structs\\n    struct PositionMarginRequirementLocalVars2 {\\n        int24 inRangeTick;\\n        int256 scenario1LPVariableTokenBalance;\\n        int256 scenario1LPFixedTokenBalance;\\n        uint160 scenario1SqrtPriceX96;\\n        int256 scenario2LPVariableTokenBalance;\\n        int256 scenario2LPFixedTokenBalance;\\n        uint160 scenario2SqrtPriceX96;\\n    }\\n\\n    struct MarginCalculatorParameters {\\n        /// @dev Upper bound of the underlying pool (e.g. Aave v2 USDC lending pool) APY from the initiation of the IRS AMM and until its maturity (18 decimals fixed point number)\\n        uint256 apyUpperMultiplierWad;\\n        /// @dev Lower bound of the underlying pool (e.g. Aave v2 USDC lending pool) APY from the initiation of the IRS AMM and until its maturity (18 decimals)\\n        uint256 apyLowerMultiplierWad;\\n        /// @dev The volatility of the underlying pool APY (settable by the owner of the Margin Engine) (18 decimals)\\n        int256 sigmaSquaredWad;\\n        /// @dev Margin Engine Parameter estimated via CIR model calibration (for details refer to litepaper) (18 decimals)\\n        int256 alphaWad;\\n        /// @dev Margin Engine Parameter estimated via CIR model calibration (for details refer to litepaper) (18 decimals)\\n        int256 betaWad;\\n        /// @dev Standard normal critical value used in the computation of the Upper APY Bound of the underlying pool\\n        int256 xiUpperWad;\\n        /// @dev Standard normal critical value used in the computation of the Lower APY Bound of the underlying pool\\n        int256 xiLowerWad;\\n        /// @dev Max term possible for a Voltz IRS AMM in seconds (18 decimals)\\n        int256 tMaxWad;\\n        /// @dev multiplier of the starting fixed rate (refer to the litepaper) if simulating a counterfactual fixed taker unwind (moving to the left along the VAMM) for purposes of calculating liquidation margin requirement\\n        uint256 devMulLeftUnwindLMWad;\\n        /// @dev multiplier of the starting fixed rate (refer to the litepaper) if simulating a counterfactual variable taker unwind (moving to the right along the VAMM) for purposes of calculating liquidation margin requirement\\n        uint256 devMulRightUnwindLMWad;\\n        /// @dev same as devMulLeftUnwindLMWad but for purposes of calculating the initial margin requirement\\n        uint256 devMulLeftUnwindIMWad;\\n        /// @dev same as devMulRightUnwindLMWad but for purposes of calculating the initial margin requirement\\n        uint256 devMulRightUnwindIMWad;\\n        /// @dev r_min from the litepaper eq. 11 for a scenario where counterfactual is a simulated fixed taker unwind (left unwind along the VAMM), used for liquidation margin calculation\\n        uint256 fixedRateDeviationMinLeftUnwindLMWad;\\n        /// @dev r_min from the litepaper eq. 11 for a scenario where counterfactual is a simulated variable taker unwind (right unwind along the VAMM), used for liquidation margin calculation\\n        uint256 fixedRateDeviationMinRightUnwindLMWad;\\n        /// @dev same as fixedRateDeviationMinLeftUnwindLMWad but for Initial Margin Requirement\\n        uint256 fixedRateDeviationMinLeftUnwindIMWad;\\n        /// @dev same as fixedRateDeviationMinRightUnwindLMWad but for Initial Margin Requirement\\n        uint256 fixedRateDeviationMinRightUnwindIMWad;\\n        /// @dev gamma from eqn. 12 [append this logic to the litepaper] from the litepaper, gamma is an adjustable parameter necessary to calculate scaled deviations to the fixed rate in counterfactual unwinds for minimum margin requirement calculations\\n        uint256 gammaWad;\\n        /// @dev settable parameter that ensures that minimumMarginRequirement is always above or equal to the minMarginToIncentiviseLiquidators which ensures there is always sufficient incentive for liquidators to liquidate positions given the fact their income is a proportion of position margin\\n        uint256 minMarginToIncentiviseLiquidators;\\n    }\\n\\n    // Events\\n    event HistoricalApyWindowSet(uint256 secondsAgoOld, uint256 secondsAgo);\\n    event CacheMaxAgeSet(\\n        uint256 cacheMaxAgeInSecondsOld,\\n        uint256 cacheMaxAgeInSeconds\\n    );\\n\\n    event CollectProtocol(address sender, address recipient, uint256 amount);\\n    event LiquidatorRewardSet(\\n        uint256 liquidatorRewardWadOld,\\n        uint256 liquidatorRewardWad\\n    );\\n\\n    event VAMMSet(IVAMM vammOld, IVAMM vamm);\\n\\n    event FCMSet(IFCM fcmOld, IFCM fcm);\\n\\n    event MarginCalculatorParametersSet(\\n        MarginCalculatorParameters marginCalculatorParametersOld,\\n        MarginCalculatorParameters marginCalculatorParameters\\n    );\\n\\n    event UpdatePositionMargin(\\n        address owner,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        int256 positionMargin\\n    );\\n\\n    event SettlePosition(\\n        address owner,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        int256 fixedTokenBalance,\\n        int256 variableTokenBalance,\\n        int256 margin,\\n        bool isSettled\\n    );\\n\\n    event LiquidatePosition(\\n        address owner,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        int256 fixedTokenBalance,\\n        int256 variableTokenBalance,\\n        int256 margin,\\n        uint128 liquidity\\n    );\\n\\n    event UpdatePositionPostSwap(\\n        address owner,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        int256 fixedTokenBalance,\\n        int256 variableTokenBalance,\\n        int256 margin\\n    );\\n\\n    event UpdatePositionPostMintBurn(\\n        address owner,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 liquidity\\n    );\\n\\n    // immutables\\n\\n    /// @notice The Full Collateralisation Module (FCM)\\n    /// @dev The FCM is a smart contract that acts as an intermediary Position between the Voltz Core and traders who wish to take fully collateralised fixed taker positions\\n    /// @dev An example FCM is the AaveFCM.sol module which inherits from the IFCM interface, it lets fixed takers deposit underlying yield bearing tokens (e.g.) aUSDC as margin to enter into a fixed taker swap without the need to worry about liquidations\\n    /// @dev since the MarginEngine is confident the FCM is always fully collateralised, it does not let liquidators liquidate the FCM Position\\n    /// @return The Full Collateralisation Module linked to the MarginEngine\\n    function fcm() external view returns (IFCM);\\n\\n    /// @notice The Factory\\n    /// @dev the factory that deployed the master Margin Engine\\n    function factory() external view returns (IFactory);\\n\\n    /// @notice The address of the underlying (non-yield bearing) token - e.g. USDC\\n    /// @return The underlying ERC20 token (e.g. USDC)\\n    function underlyingToken() external view returns (IERC20Minimal);\\n\\n    /// @notice The rateOracle contract which lets the protocol access historical apys in the yield bearing pools it is built on top of\\n    /// @return The underlying ERC20 token (e.g. USDC)\\n    function rateOracle() external view returns (IRateOracle);\\n\\n    /// @notice The unix termStartTimestamp of the MarginEngine in Wad\\n    /// @return Term Start Timestamp in Wad\\n    function termStartTimestampWad() external view returns (uint256);\\n\\n    /// @notice The unix termEndTimestamp of the MarginEngine in Wad\\n    /// @return Term End Timestamp in Wad\\n    function termEndTimestampWad() external view returns (uint256);\\n\\n    // errors\\n\\n    /// @dev No need to unwind a net zero position\\n    error PositionNetZero();\\n\\n    /// @dev Cannot have less margin than the minimum requirement\\n    error MarginLessThanMinimum();\\n\\n    /// @dev We can't withdraw more margin than we have\\n    error WithdrawalExceedsCurrentMargin();\\n\\n    /// @dev Position must be settled after AMM has reached maturity\\n    error PositionNotSettled();\\n\\n    /// @dev \\\"constructor\\\" for proxy instances\\n    function initialize(\\n        address _underlyingToken,\\n        address _rateOracleAddress,\\n        uint256 _termStartTimestampWad,\\n        uint256 _termEndTimestampWad\\n    ) external;\\n\\n    // view functions\\n\\n    /// @notice The liquidator Reward Percentage (in Wad)\\n    /// @dev liquidatorReward (in wad) is the percentage of the margin (of a liquidated position) that is sent to the liquidator\\n    /// @dev following a successful liquidation that results in a trader/position unwind; example value:  2 * 10**16 => 2% of position margin is used to cover liquidator reward\\n    /// @return Liquidator Reward in Wad\\n    function liquidatorRewardWad() external view returns (uint256);\\n\\n    /// @notice VAMM (Virtual Automated Market Maker) linked to the MarginEngine\\n    /// @dev The VAMM is responsible for pricing only (determining the effective fixed rate at which a given Interest Rate Swap notional will be executed)\\n    /// @return The VAMM\\n    function vamm() external view returns (IVAMM);\\n\\n    /// @notice Returns the information about a position by the position's key\\n    /// @param _owner The address of the position owner\\n    /// @param tickLower The lower tick boundary of the position\\n    /// @param tickUpper The upper tick boundary of the position\\n    /// Returns position The Position.Info corresponding to the requested position\\n    function getPosition(\\n        address _owner,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) external view returns (Position.Info memory position);\\n\\n    /// @notice Gets the look-back window size that's used to request the historical APY from the rate Oracle\\n    /// @dev The historical APY of the Rate Oracle is necessary for MarginEngine computations\\n    /// @dev The look-back window is seconds from the current timestamp\\n    /// @dev This value is only settable by the the Factory owner and may be unique for each MarginEngine\\n    /// @dev When setting secondAgo, the setter needs to take into consideration the underlying volatility of the APYs in the reference yield-bearing pool (e.g. Aave v2 USDC)\\n    function secondsAgo() external view returns (uint256);\\n\\n    // non-view functions\\n\\n    /// @notice Sets secondsAgo: The look-back window size used to calculate the historical APY for margin purposes\\n    /// @param _secondsAgo the duration of the lookback window in seconds\\n    /// @dev Can only be set by the Factory Owner\\n    function setSecondsAgo(uint256 _secondsAgo) external;\\n\\n    /// @notice Set the MarginCalculatorParameters (each margin engine can have its own custom set of margin calculator parameters)\\n    /// @param _marginCalculatorParameters the MarginCalculatorParameters to set\\n    /// @dev marginCalculatorParameteres is of type MarginCalculatorParameters (refer to the definition of the struct for elaboration on what each parameter means)\\n    function setMarginCalculatorParameters(\\n        MarginCalculatorParameters memory _marginCalculatorParameters\\n    ) external;\\n\\n    /// @notice Sets the liquidator reward: proportion of liquidated position's margin paid as a reward to the liquidator\\n    function setLiquidatorReward(uint256 _liquidatorRewardWad) external;\\n\\n    /// @notice updates the margin account of a position which can be uniquily identified with its _owner, tickLower, tickUpper\\n    /// @dev if the position has positive liquidity then before the margin update, we call the updatePositionTokenBalancesAndAccountForFees functon that calculates up to date\\n    /// @dev margin, fixed and variable token balances by taking into account the fee income from their tick range and fixed and variable deltas settled along their tick range\\n    /// @dev marginDelta is the delta applied to the current margin of a positioin, if the marginDelta is negative, the position is withdrawing margin, if the marginDelta is positive, the position is depositing funds in terms of the underlying tokens\\n    /// @dev if marginDelta is negative, we need to check if the msg.sender is either the _owner of the position or the msg.sender is apporved by the _owner to act on their behalf in Voltz Protocol\\n    /// @dev the approval logic is implemented in the Factory.sol\\n    /// @dev if marginDelta is negative, we additionally need to check if post the initial margin requirement is still satisfied post withdrawal\\n    /// @dev if marginDelta is positive, the depositor of the margin is either the msg.sender or the owner who interacted through an approved peripheral contract\\n    function updatePositionMargin(\\n        address _owner,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        int256 marginDelta\\n    ) external;\\n\\n    /// @notice Settles a Position\\n    /// @dev Can be called by anyone\\n    /// @dev A position cannot be settled before maturity\\n    /// @dev Steps to settle a position:\\n    /// @dev 1. Retrieve the current fixed and variable token growth inside the tick range of a position\\n    /// @dev 2. Calculate accumulated fixed and variable balances of the position since the last mint/poke/burn\\n    /// @dev 3. Update the postion's fixed and variable token balances\\n    /// @dev 4. Update the postion's fixed and varaible token growth inside last to enable future updates\\n    /// @dev 5. Calculates the settlement cashflow from all of the IRS contracts the position has entered since entering the AMM\\n    /// @dev 6. Updates the fixed and variable token balances of the position to be zero, adds the settlement cashflow to the position's current margin\\n    function settlePosition(\\n        int24 tickLower,\\n        int24 tickUpper,\\n        address _owner\\n    ) external;\\n\\n    /// @notice Liquidate a Position\\n    /// @dev Steps to liquidate: update position's fixed and variable token balances to account for balances accumulated throughout the trades made since the last mint/burn/poke,\\n    /// @dev Check if the position is liquidatable by calling the isLiquidatablePosition function of the calculator, revert if that is not the case,\\n    /// @dev Calculate the liquidation reward = current margin of the position * liquidatorReward, subtract the liquidator reward from the position margin,\\n    /// @dev Burn the position's liquidity, unwind unnetted fixed and variable balances of a position, transfer the reward to the liquidator\\n    function liquidatePosition(\\n        int24 tickLower,\\n        int24 tickUpper,\\n        address _owner\\n    ) external;\\n\\n    /// @notice Update a Position post VAMM induced mint or burn\\n    /// @dev Steps taken:\\n    /// @dev 1. Update position liquidity based on params.liquidityDelta\\n    /// @dev 2. Update fixed and variable token balances of the position based on how much has been accumulated since the last mint/burn/poke\\n    /// @dev 3. Update position's margin by taking into account the position accumulated fees since the last mint/burn/poke\\n    /// @dev 4. Update fixed and variable token growth + fee growth in the position info struct for future interactions with the position\\n    /// @param params necessary for the purposes of referencing the position being updated (owner, tickLower, tickUpper, _) and the liquidity delta that needs to be applied to position._liquidity\\n    function updatePositionPostVAMMInducedMintBurn(\\n        IPositionStructs.ModifyPositionParams memory params\\n    ) external;\\n\\n    // @notive Update a position post VAMM induced swap\\n    /// @dev Since every position can also engage in swaps with the VAMM, this function needs to be invoked after non-external calls are made to the VAMM's swap function\\n    /// @dev This purpose of this function is to:\\n    /// @dev 1. updatePositionTokenBalancesAndAccountForFees\\n    /// @dev 2. update position margin to account for fees paid to execute the swap\\n    /// @dev 3. calculate the position margin requrement given the swap, check if the position marigin satisfies the most up to date requirement\\n    /// @dev 4. if all the requirements are satisfied then position gets updated to take into account the swap that it just entered, if the minimum margin requirement is not satisfied then the transaction will revert\\n    function updatePositionPostVAMMInducedSwap(\\n        address _owner,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        int256 fixedTokenDelta,\\n        int256 variableTokenDelta,\\n        uint256 cumulativeFeeIncurred\\n    ) external;\\n\\n    /// @notice function that can only be called by the owner enables collection of protocol generated fees from any give margin engine\\n    /// @param recipient the address which collects the protocol generated fees\\n    /// @param amount the amount in terms of underlying tokens collected from the protocol's earnings\\n    function collectProtocol(address recipient, uint256 amount) external;\\n\\n    /// @notice sets the Virtual Automated Market Maker (VAMM) attached to the MarginEngine\\n    /// @dev the VAMM is responsible for price discovery, whereas the management of the underlying collateral and liquidations are handled by the Margin Engine\\n    function setVAMM(address _vAMMAddress) external;\\n\\n    /// @notice sets the Full Collateralisation Module\\n    function setFCM(address _fcm) external;\\n\\n    /// @notice transfers margin in terms of underlying tokens to a trader from the Full Collateralisation Module\\n    /// @dev post maturity date of the MarginEngine, the traders from the Full Collateralisation module will be able to settle with the MarginEngine\\n    /// @dev to ensure their fixed yield is guaranteed, in order to collect the funds from the MarginEngine, the FCM needs to invoke the transferMarginToFCMTrader function whcih is only callable by the FCM attached to a particular Margin Engine\\n    function transferMarginToFCMTrader(address _account, uint256 marginDelta)\\n        external;\\n\\n    /// @notice Sets the maximum age that the cached historical APY value\\n    /// @param _cacheMaxAgeInSeconds The new maximum age that the historical APY cache can be before being considered stale\\n    function setCacheMaxAgeInSeconds(uint256 _cacheMaxAgeInSeconds) external;\\n}\\n\",\"keccak256\":\"0x3f82ca31d4f62420e3e3a3512ab30c611536e87f5ea073077edce02e14556b67\",\"license\":\"MIT\"},\"contracts/interfaces/IPositionStructs.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IPositionStructs {\\n    struct ModifyPositionParams {\\n        // the address that owns the position\\n        address owner;\\n        // the lower and upper tick of the position\\n        int24 tickLower;\\n        int24 tickUpper;\\n        // any change in liquidity\\n        int128 liquidityDelta;\\n    }\\n}\\n\",\"keccak256\":\"0xd32ee55155381a997694a0ace0182a369f0710c0952166fb1ae7f8ddf87b1c4d\",\"license\":\"MIT\"},\"contracts/interfaces/IVAMM.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"./IMarginEngine.sol\\\";\\nimport \\\"./IFactory.sol\\\";\\nimport \\\"./IPositionStructs.sol\\\";\\n\\ninterface IVAMM is IPositionStructs {\\n    // events\\n    event Swap(\\n        address indexed sender,\\n        address indexed recipient,\\n        uint160 sqrtPriceX96,\\n        uint128 liquidity,\\n        int24 tick,\\n        int24 tickLower,\\n        int24 tickUpper\\n    );\\n\\n    /// @dev emitted after a given vamm is successfully initialized\\n    event InitializeVAMM(uint160 sqrtPriceX96, int24 tick);\\n\\n    /// @dev emitted after a successful minting of a given LP position\\n    event Mint(\\n        address sender,\\n        address indexed owner,\\n        int24 indexed tickLower,\\n        int24 indexed tickUpper,\\n        uint128 amount\\n    );\\n\\n    /// @dev emitted after a successful burning of a given LP position\\n    event Burn(\\n        address sender,\\n        address indexed owner,\\n        int24 indexed tickLower,\\n        int24 indexed tickUpper,\\n        uint128 amount\\n    );\\n\\n    /// @dev emitted after setting feeProtocol\\n    event SetFeeProtocol(uint8 feeProtocolOld, uint8 feeProtocol);\\n\\n    /// @dev emitted after fee is set\\n    event FeeSet(uint256 feeWadOld, uint256 feeWad);\\n\\n    // errors\\n\\n    /// @dev There are not enough funds available for the requested operation\\n    error NotEnoughFunds(uint256 requested, uint256 available);\\n\\n    /// @dev The two values were expected to have oppostite sigs, but do not\\n    error ExpectedOppositeSigns(int256 amount0, int256 amount1);\\n\\n    /// @dev Error which is reverted if the sqrt price of the vamm is non-zero before a vamm is initialized\\n    error ExpectedSqrtPriceZeroBeforeInit(uint160 sqrtPriceX96);\\n\\n    /// @dev Error which ensures the liquidity delta is positive if a given LP wishes to mint further liquidity in the vamm\\n    error LiquidityDeltaMustBePositiveInMint(uint128 amount);\\n\\n    /// @dev Error which ensures the liquidity delta is positive if a given LP wishes to burn liquidity in the vamm\\n    error LiquidityDeltaMustBePositiveInBurn(uint128 amount);\\n\\n    /// @dev Error which ensures the amount of notional specified when initiating an IRS contract (via the swap function in the vamm) is non-zero\\n    error IRSNotionalAmountSpecifiedMustBeNonZero(int256 amountSpecified);\\n\\n    /// @dev Error which ensures the VAMM is unlocked\\n    error CanOnlyTradeIfUnlocked(bool unlocked);\\n\\n    /// @dev only the margin engine can run a certain function\\n    error OnlyMarginEngine();\\n\\n    // structs\\n\\n    struct VAMMVars {\\n        /// @dev the current sqrt price in the vamm\\n        uint160 sqrtPriceX96;\\n        /// @dev the current tick in the vamm\\n        int24 tick;\\n        // the current protocol fee as a percentage of the swap fee taken on withdrawal\\n        // represented as an integer denominator (1/x)%\\n        uint8 feeProtocol;\\n    }\\n\\n    struct SwapParams {\\n        /// @dev Address of the trader initiating the swap\\n        address recipient;\\n        /// @dev The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\\n        int256 amountSpecified;\\n        /// @dev The Q64.96 sqrt price limit. If !isFT, the price cannot be less than this\\n        uint160 sqrtPriceLimitX96;\\n        /// @dev Is the swap triggered following a liquidation event resulting in an unwind or swap triggered by the FCM\\n        bool isExternal;\\n        /// @dev Is the swap triggered by a trader. If this is false then this is only possible in a scenario where a liquidity provider's position is liquidated\\n        /// @dev leading to an unwind of a liquidity provider\\n        /// @dev lower tick of the liquidity provider (needs to be set if isTrader is false)\\n        int24 tickLower;\\n        /// @dev upper tick of the liqudiity provider (needs to be set if isTrader is false)\\n        int24 tickUpper;\\n    }\\n\\n    struct SwapCache {\\n        /// @dev liquidity at the beginning of the swap\\n        uint128 liquidityStart;\\n        // the current protocol fee as a percentage of the swap fee taken on withdrawal\\n        // represented as an integer denominator (1/x)%\\n        uint8 feeProtocol;\\n    }\\n\\n    /// @dev the top level state of the swap, the results of which are recorded in storage at the end\\n    struct SwapState {\\n        /// @dev the amount remaining to be swapped in/out of the input/output asset\\n        int256 amountSpecifiedRemaining;\\n        /// @dev the amount already swapped out/in of the output/input asset\\n        int256 amountCalculated;\\n        /// @dev current sqrt(price)\\n        uint160 sqrtPriceX96;\\n        /// @dev the tick associated with the current price\\n        int24 tick;\\n        /// @dev the global fixed token growth\\n        int256 fixedTokenGrowthGlobalX128;\\n        /// @dev the global variable token growth\\n        int256 variableTokenGrowthGlobalX128;\\n        /// @dev the current liquidity in range\\n        uint128 liquidity;\\n        /// @dev the global fee growth of the underlying token\\n        uint256 feeGrowthGlobalX128;\\n        /// @dev amount of underlying token paid as protocol fee\\n        uint256 protocolFee;\\n        /// @dev cumulative fee incurred while initiating a swap\\n        uint256 cumulativeFeeIncurred;\\n        /// @dev ...\\n        int256 fixedTokenDeltaCumulative;\\n        /// @dev ...\\n        int256 variableTokenDeltaCumulative;\\n    }\\n\\n    struct StepComputations {\\n        /// @dev the price at the beginning of the step\\n        uint160 sqrtPriceStartX96;\\n        /// @dev the next tick to swap to from the current tick in the swap direction\\n        int24 tickNext;\\n        /// @dev whether tickNext is initialized or not\\n        bool initialized;\\n        /// @dev sqrt(price) for the next tick (1/0)\\n        uint160 sqrtPriceNextX96;\\n        /// @dev how much is being swapped in in this step\\n        uint256 amountIn;\\n        /// @dev how much is being swapped out\\n        uint256 amountOut;\\n        /// @dev how much fee is being paid in (underlying token)\\n        uint256 feeAmount;\\n        /// @dev ...\\n        uint256 feeProtocolDelta;\\n        /// @dev ...\\n        int256 fixedTokenDeltaUnbalanced; // for LP\\n        /// @dev ...\\n        int256 fixedTokenDelta; // for LP\\n        /// @dev ...\\n        int256 variableTokenDelta; // for LP\\n    }\\n\\n    /// @dev \\\"constructor\\\" for proxy instances\\n    function initialize(address _marginEngineAddress, int24 _tickSpacing)\\n        external;\\n\\n    // immutables\\n\\n    /// @notice The vamm's fee (proportion) in wei\\n    /// @return The fee in wei\\n    function feeWad() external view returns (uint256);\\n\\n    /// @notice whether the vamm is locked\\n    /// @return The boolean, true if the vamm is unlocked\\n    function unlocked() external view returns (bool);\\n\\n    /// @notice The vamm tick spacing\\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\\n    /// This value is an int24 to avoid casting even though it is always positive.\\n    /// @return The tick spacing\\n    function tickSpacing() external view returns (int24);\\n\\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\\n    /// @dev This parameter should be enforced per tick (when setting) to prevent liquidity from overflowing a uint128 at any point, and\\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to the vamm\\n    /// @return The max amount of liquidity per tick\\n    function maxLiquidityPerTick() external view returns (uint128);\\n\\n    // state variables\\n\\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(variableToken/fixedToken) Q64.96 value\\n    /// @return tick The current tick of the vamm, i.e. according to the last tick transition that was run.\\n    /// @return feeProtocol feeProtocol\\n    function vammVars()\\n        external\\n        view\\n        returns (\\n            uint160 sqrtPriceX96,\\n            int24 tick,\\n            uint8 feeProtocol\\n        );\\n\\n    /// @notice The fixed token growth in wei, accumulated per unit of liquidity for the entire life of the vamm\\n    /// @dev This value can overflow the uint256\\n    function fixedTokenGrowthGlobalX128() external view returns (int256);\\n\\n    /// @notice The variable token growth in wei, accumulated per unit of liquidity for the entire life of the vamm\\n    /// @dev This value can overflow the uint256\\n    function variableTokenGrowthGlobalX128() external view returns (int256);\\n\\n    /// @notice The fee growth in wei, collected per unit of liquidity for the entire life of the vamm\\n    /// @dev This value can overflow the uint256\\n    function feeGrowthGlobalX128() external view returns (uint256);\\n\\n    /// @notice The currently in range liquidity available to the vamm\\n    function liquidity() external view returns (uint128);\\n\\n    /// @notice The amount underlying token that are owed to the protocol\\n    /// @dev Protocol fees will never exceed uint256\\n    function protocolFees() external view returns (uint256);\\n\\n    function marginEngine() external view returns (IMarginEngine);\\n\\n    function factory() external view returns (IFactory);\\n\\n    /// @notice Function that sets the feeProtocol of the vamm\\n    function setFeeProtocol(uint8 feeProtocol) external;\\n\\n    /// @notice Function that sets fee of the vamm\\n    function setFee(uint256 _fee) external;\\n\\n    /// @notice Updates internal accounting to reflect a collection of protocol fees. The actual transfer of fees must happen separately in the AMM\\n    /// @dev can only be done via the collectProtocol function of the parent AMM of the vamm\\n    function updateProtocolFees(uint256 protocolFeesCollected) external;\\n\\n    /// @notice Sets the initial price for the vamm\\n    /// @dev Price is represented as a sqrt(amountVariableToken/amountFixedToken) Q64.96 value\\n    /// @param sqrtPriceX96 the initial sqrt price of the vamm as a Q64.96\\n    function initializeVAMM(uint160 sqrtPriceX96) external;\\n\\n    /// @notice removes liquidity given recipient/tickLower/tickUpper of the position\\n    /// @param recipient The address for which the liquidity will be created\\n    /// @param tickLower The lower tick of the position in which to add liquidity\\n    /// @param tickUpper The upper tick of the position in which to add liquidity\\n    /// @param amount The amount of liquidity to burn\\n    function burn(\\n        address recipient,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 amount\\n    ) external;\\n\\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\\n    /// @param recipient The address for which the liquidity will be created\\n    /// @param tickLower The lower tick of the position in which to add liquidity\\n    /// @param tickUpper The upper tick of the position in which to add liquidity\\n    /// @param amount The amount of liquidity to mint\\n    function mint(\\n        address recipient,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 amount\\n    ) external;\\n\\n    /// @notice Initiate an Interest Rate Swap\\n    /// @param params SwapParams necessary to initiate an Interest Rate Swap\\n    /// @return _fixedTokenDelta Fixed Token Delta\\n    /// @return _variableTokenDelta Variable Token Delta\\n    /// @return _cumulativeFeeIncurred Cumulative Fee Incurred\\n    function swap(SwapParams memory params)\\n        external\\n        returns (\\n            int256 _fixedTokenDelta,\\n            int256 _variableTokenDelta,\\n            uint256 _cumulativeFeeIncurred\\n        );\\n\\n    /// @notice Look up information about a specific tick in the amm\\n    /// @param tick The tick to look up\\n    /// @return liquidityGross the total amount of position liquidity that uses the vamm either as tick lower or\\n    /// tick upper,\\n    /// liquidityNet how much liquidity changes when the vamm price crosses the tick,\\n    /// feeGrowthOutsideX128 the fee growth on the other side of the tick from the current tick in underlying token\\n    /// i.e. if liquidityGross is greater than 0. In addition, these values are only relative.\\n    function ticks(int24 tick)\\n        external\\n        view\\n        returns (\\n            uint128 liquidityGross,\\n            int128 liquidityNet,\\n            int256 fixedTokenGrowthOutside,\\n            int256 variableTokenGrowthOutside,\\n            uint256 feeGrowthOutside,\\n            bool initialized\\n        );\\n\\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\\n\\n    /// @notice Computes the current fixed and variable token growth inside a given tick range given the current tick in the vamm\\n    /// @param tickLower The lower tick of the position\\n    /// @param tickUpper The upper tick of the position\\n    /// @return fixedTokenGrowthInsideX128 Fixed Token Growth inside the given tick range\\n    /// @return variableTokenGrowthInsideX128 Variable Token Growth inside the given tick range\\n    /// @return feeGrowthInsideX128 Fee Growth Inside given tick range\\n    function computeGrowthInside(int24 tickLower, int24 tickUpper)\\n        external\\n        view\\n        returns (\\n            int256 fixedTokenGrowthInsideX128,\\n            int256 variableTokenGrowthInsideX128,\\n            uint256 feeGrowthInsideX128\\n        );\\n}\\n\",\"keccak256\":\"0x3b620f0e27837824c715ef2c39696d436e8ccf8b20ea67c0b02bd47002803e01\",\"license\":\"MIT\"},\"contracts/interfaces/rate_oracles/IRateOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @dev The RateOracle is used for two purposes on the Voltz Protocol\\n/// @dev Settlement: in order to be able to settle IRS positions after the termEndTimestamp of a given AMM\\n/// @dev Margin Engine Computations: getApyFromTo is used by the MarginCalculator and MarginEngine\\n/// @dev It is necessary to produce margin requirements for Trader and Liquidity Providers\\ninterface IRateOracle {\\n\\n    // events\\n    event MinSecondsSinceLastUpdateSet(uint256 _minSecondsSinceLastUpdate);\\n    event OracleBufferWrite(\\n        uint256 blockTimestampScaled,\\n        address source,\\n        uint16 index,\\n        uint32 blockTimestamp,\\n        uint256 observedValue,\\n        uint16 cardinality,\\n        uint16 cardinalityNext\\n    );\\n\\n    /// @notice Emitted by the rate oracle for increases to the number of observations that can be stored\\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\\n    event IncreaserateCardinalityNext(\\n        uint16 observationCardinalityNextOld,\\n        uint16 observationCardinalityNextNew\\n    );\\n\\n    // view functions\\n\\n    /// @notice Gets minimum number of seconds that need to pass since the last update to the rates array\\n    /// @dev This is a throttling mechanic that needs to ensure we don't run out of space in the rates array\\n    /// @dev The maximum size of the rates array is 65535 entries\\n    // AB: as long as this doesn't affect the termEndTimestamp rateValue too much\\n    // AB: can have a different minSecondsSinceLastUpdate close to termEndTimestamp to have more granularity for settlement purposes\\n    /// @return minSecondsSinceLastUpdate in seconds\\n    function minSecondsSinceLastUpdate() external view returns (uint256);\\n\\n    /// @notice Gets the address of the underlying token of the RateOracle\\n    /// @return underlying The address of the underlying token\\n    function underlying() external view returns (address);\\n\\n    /// @notice Gets the variable factor between termStartTimestamp and termEndTimestamp\\n    /// @return result The variable factor\\n    /// @dev If the current block timestamp is beyond the maturity of the AMM, then the variableFactor is getRateFromTo(termStartTimestamp, termEndTimestamp). Term end timestamps are cached for quick retrieval later.\\n    /// @dev If the current block timestamp is before the maturity of the AMM, then the variableFactor is getRateFromTo(termStartTimestamp,Time.blockTimestampScaled());\\n    function variableFactor(uint256 termStartTimestamp, uint256 termEndTimestamp) external returns(uint256 result);\\n\\n    /// @notice Gets the variable factor between termStartTimestamp and termEndTimestamp\\n    /// @return result The variable factor\\n    /// @dev If the current block timestamp is beyond the maturity of the AMM, then the variableFactor is getRateFromTo(termStartTimestamp, termEndTimestamp). No caching takes place.\\n    /// @dev If the current block timestamp is before the maturity of the AMM, then the variableFactor is getRateFromTo(termStartTimestamp,Time.blockTimestampScaled());\\n    function variableFactorNoCache(uint256 termStartTimestamp, uint256 termEndTimestamp) external view returns(uint256 result);\\n\\n    /// @notice Calculates the observed interest returned by the underlying in a given period\\n    /// @dev Reverts if we have no data point for either timestamp\\n    /// @param from The timestamp of the start of the period, in seconds\\n    /// @param to The timestamp of the end of the period, in seconds\\n    /// @return The \\\"floating rate\\\" expressed in Wad, e.g. 4% is encoded as 0.04*10**18 = 4*10*16\\n    function getRateFromTo(uint256 from, uint256 to)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @notice Calculates the observed APY returned by the rate oracle in a given period\\n    /// @param from The timestamp of the start of the period, in seconds\\n    /// @param to The timestamp of the end of the period, in seconds\\n    /// @dev Reverts if we have no data point for either timestamp\\n    //  how is the returned rate encoded? Floating rate?\\n    function getApyFromTo(uint256 from, uint256 to)\\n        external\\n        view\\n        returns (uint256 apyFromTo);\\n\\n    // non-view functions\\n\\n    /// @notice Sets minSecondsSinceLastUpdate: The minimum number of seconds in wei that need to pass since the last update to the rates array\\n    /// @dev Can only be set by the Factory Owner\\n    function setMinSecondsSinceLastUpdate(uint256 _minSecondsSinceLastUpdate) external;\\n\\n    /// @notice Increase the maximum number of rates observations that this RateOracle will store\\n    /// @dev This method is no-op if the RateOracle already has an observationCardinalityNext greater than or equal to\\n    /// the input observationCardinalityNext.\\n    /// @param rateCardinalityNext The desired minimum number of observations for the pool to store\\n    function increaseObservarionCardinalityNext(uint16 rateCardinalityNext) external;\\n\\n    /// @notice Writes a rate observation to the rates array given the current rate cardinality, rate index and rate cardinality next\\n    /// Write oracle entry is called whenever a new position is minted via the vamm or when a swap is initiated via the vamm\\n    /// That way the gas costs of Rate Oracle updates can be distributed across organic interactions with the protocol\\n    function writeOracleEntry() external;\\n\\n    /// @notice unique ID of the underlying yield bearing protocol (e.g. Aave v2 has id 1)\\n    /// @return yieldBearingProtocolID unique id of the underlying yield bearing protocol\\n    function underlyingYieldBearingProtocolID() external view returns(uint8 yieldBearingProtocolID);\\n}\\n\",\"keccak256\":\"0x637eb5529514a60f93f3f51bd61fbcc5fb8734a2a8d138908574be9126798762\",\"license\":\"MIT\"},\"contracts/utils/FixedPoint128.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @title FixedPoint128\\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\\nlibrary FixedPoint128 {\\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\\n}\\n\",\"keccak256\":\"0x54ecdc08e0ef6a0ef60b174017e09c4df5e7909a256f694a766a84aae1099581\",\"license\":\"MIT\"},\"contracts/utils/FixedPoint96.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @title FixedPoint96\\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\\n/// @dev Used in SqrtPriceMath.sol\\nlibrary FixedPoint96 {\\n    uint8 internal constant RESOLUTION = 96;\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n}\\n\",\"keccak256\":\"0xc3235c9d6fe645193e612a02409e7f502278b8c5dda21e76e351ab9562e56113\",\"license\":\"MIT\"},\"contracts/utils/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable no-inline-assembly\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = a * b\\n        // Compute the product mod 2**256 and mod 2**256 - 1\\n        // then use the Chinese Remainder Theorem to reconstruct\\n        // the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2**256 + prod0\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n\\n        unchecked {\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                require(denominator > 0, \\\"Division by zero\\\");\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1, \\\"overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            // uint256 twos = -denominator & denominator;\\n            // https://ethereum.stackexchange.com/questions/96642/unary-operator-cannot-be-applied-to-type-uint256\\n            uint256 twos = (type(uint256).max - denominator + 1) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = mulDiv(a, b, denominator);\\n        if (mulmod(a, b, denominator) > 0) {\\n            require(result < type(uint256).max, \\\"overflow\\\");\\n            result++;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc2cbf0b27af050b782002921643081333808425ad3e249a70309f9bcdf0a6382\",\"license\":\"MIT\"},\"contracts/utils/LiquidityMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Math library for liquidity\\nlibrary LiquidityMath {\\n    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\\n    /// @param x The liquidity before change\\n    /// @param y The delta by which liquidity should be changed\\n    /// @return z The liquidity delta\\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\\n        if (y < 0) {\\n            require((z = x - uint128(-y)) < x, \\\"LS\\\");\\n        } else {\\n            require((z = x + uint128(y)) >= x, \\\"LA\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x55378f4559d7a5913a557d62a1e98f57607117636093e95006e7e2bd081061ea\",\"license\":\"MIT\"},\"contracts/utils/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Safe casting methods\\n/// @notice Contains methods for safely casting between types\\nlibrary SafeCast {\\n    /// @notice Cast a uint256 to a uint160, revert on overflow\\n    /// @param y The uint256 to be downcasted\\n    /// @return z The downcasted integer, now type uint160\\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\\n        require((z = uint160(y)) == y, \\\"overflow in toUint160\\\");\\n    }\\n\\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\\n    /// @param y The int256 to be downcasted\\n    /// @return z The downcasted integer, now type int128\\n    function toInt128(int256 y) internal pure returns (int128 z) {\\n        require((z = int128(y)) == y, \\\"overflow in toInt128\\\");\\n    }\\n\\n    /// @notice Cast a uint256 to a int256, revert on overflow\\n    /// @param y The uint256 to be casted\\n    /// @return z The casted integer, now type int256\\n    function toInt256(uint256 y) internal pure returns (int256 z) {\\n        require(y < 2**255, \\\"overflow in toInt256\\\");\\n        z = int256(y);\\n    }\\n}\\n\",\"keccak256\":\"0xf412710fb4f2a80d08f1c76371b7c701a5d5542d6f3bc6ca129ea502f6dfd903\",\"license\":\"MIT\"},\"contracts/utils/SqrtPriceMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./SafeCast.sol\\\";\\n\\nimport \\\"./FullMath.sol\\\";\\nimport \\\"./UnsafeMath.sol\\\";\\nimport \\\"./FixedPoint96.sol\\\";\\n\\n/// @title Functions based on Q64.96 sqrt price and liquidity\\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\\nlibrary SqrtPriceMath {\\n    using SafeCast for uint256;\\n\\n    /// @notice Gets the next sqrt price given a delta of token0\\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\\n    /// price less in order to not send too much output.\\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param amount How much of token0 to add or remove from virtual reserves\\n    /// @param add Whether to add or remove the amount of token0\\n    /// @return The price after adding or removing amount, depending on add\\n    function getNextSqrtPriceFromAmount0RoundingUp(\\n        uint160 sqrtPX96,\\n        uint128 liquidity,\\n        uint256 amount,\\n        bool add\\n    ) internal pure returns (uint160) {\\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\\n        if (amount == 0) return sqrtPX96;\\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\\n\\n        if (add) {\\n            uint256 product;\\n            if ((product = amount * sqrtPX96) / amount == sqrtPX96) {\\n                uint256 denominator = numerator1 + product;\\n                if (denominator >= numerator1)\\n                    // always fits in 160 bits\\n                    return\\n                        uint160(\\n                            FullMath.mulDivRoundingUp(\\n                                numerator1,\\n                                sqrtPX96,\\n                                denominator\\n                            )\\n                        );\\n            }\\n\\n            return\\n                uint160(\\n                    UnsafeMath.divRoundingUp(\\n                        numerator1,\\n                        (numerator1 / sqrtPX96) + amount\\n                    )\\n                );\\n        } else {\\n            uint256 product;\\n            // if the product overflows, we know the denominator underflows\\n            // in addition, we must check that the denominator does not underflow\\n            require(\\n                (product = amount * sqrtPX96) / amount == sqrtPX96 &&\\n                    numerator1 > product,\\n                \\\"denominator underflows\\\"\\n            );\\n            uint256 denominator = numerator1 - product;\\n            return\\n                FullMath\\n                    .mulDivRoundingUp(numerator1, sqrtPX96, denominator)\\n                    .toUint160();\\n        }\\n    }\\n\\n    /// @notice Gets the next sqrt price given a delta of token1\\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\\n    /// price less in order to not send too much output.\\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param amount How much of token1 to add, or remove, from virtual reserves\\n    /// @param add Whether to add, or remove, the amount of token1\\n    /// @return The price after adding or removing `amount`\\n    function getNextSqrtPriceFromAmount1RoundingDown(\\n        uint160 sqrtPX96,\\n        uint128 liquidity,\\n        uint256 amount,\\n        bool add\\n    ) internal pure returns (uint160) {\\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\\n        // in both cases, avoid a mulDiv for most inputs\\n        if (add) {\\n            uint256 quotient = (\\n                amount <= type(uint160).max\\n                    ? (amount << FixedPoint96.RESOLUTION) / liquidity\\n                    : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\\n            );\\n\\n            return sqrtPX96 + quotient.toUint160();\\n        } else {\\n            uint256 quotient = (\\n                amount <= type(uint160).max\\n                    ? UnsafeMath.divRoundingUp(\\n                        amount << FixedPoint96.RESOLUTION,\\n                        liquidity\\n                    )\\n                    : FullMath.mulDivRoundingUp(\\n                        amount,\\n                        FixedPoint96.Q96,\\n                        liquidity\\n                    )\\n            );\\n\\n            require(sqrtPX96 > quotient, \\\"starting px must be > quotient\\\");\\n            // always fits 160 bits\\n            return uint160(sqrtPX96 - quotient);\\n        }\\n    }\\n\\n    /// @notice Gets the next sqrt price given an input amount of token0 or token1\\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param amountIn How much of token0, or token1, is being swapped in\\n    /// @param zeroForOne Whether the amount in is token0 or token1\\n    /// @return sqrtQX96 The price after adding the input amount to token0 or token1\\n    function getNextSqrtPriceFromInput(\\n        uint160 sqrtPX96,\\n        uint128 liquidity,\\n        uint256 amountIn,\\n        bool zeroForOne\\n    ) internal pure returns (uint160 sqrtQX96) {\\n        require(sqrtPX96 > 0, \\\"starting price must be > 0\\\");\\n        require(liquidity > 0, \\\"liquidity must be > 0\\\");\\n\\n        // round to make sure that we don't pass the target price\\n        return\\n            zeroForOne\\n                ? getNextSqrtPriceFromAmount0RoundingUp(\\n                    sqrtPX96,\\n                    liquidity,\\n                    amountIn,\\n                    true\\n                )\\n                : getNextSqrtPriceFromAmount1RoundingDown(\\n                    sqrtPX96,\\n                    liquidity,\\n                    amountIn,\\n                    true\\n                );\\n    }\\n\\n    /// @notice Gets the next sqrt price given an output amount of token0 or token1\\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\\n    /// @param sqrtPX96 The starting price before accounting for the output amount\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param amountOut How much of token0, or token1, is being swapped out\\n    /// @param zeroForOne Whether the amount out is token0 or token1\\n    /// @return sqrtQX96 The price after removing the output amount of token0 or token1\\n    function getNextSqrtPriceFromOutput(\\n        uint160 sqrtPX96,\\n        uint128 liquidity,\\n        uint256 amountOut,\\n        bool zeroForOne\\n    ) internal pure returns (uint160 sqrtQX96) {\\n        require(sqrtPX96 > 0, \\\"starting price must be > 0\\\");\\n        require(liquidity > 0, \\\"liquidity must be > 0\\\");\\n\\n        // round to make sure that we pass the target price\\n        return\\n            zeroForOne\\n                ? getNextSqrtPriceFromAmount1RoundingDown(\\n                    sqrtPX96,\\n                    liquidity,\\n                    amountOut,\\n                    false\\n                )\\n                : getNextSqrtPriceFromAmount0RoundingUp(\\n                    sqrtPX96,\\n                    liquidity,\\n                    amountOut,\\n                    false\\n                );\\n    }\\n\\n    /// @notice Gets the amount0 delta between two prices\\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\\n    /// @param sqrtRatioAX96 A sqrt price\\n    /// @param sqrtRatioBX96 Another sqrt price\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param roundUp Whether to round the amount up or down\\n    /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices\\n    function getAmount0Delta(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity,\\n        bool roundUp\\n    ) internal pure returns (uint256 amount0) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96)\\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\\n        uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\\n\\n        require(sqrtRatioAX96 > 0, \\\"sqrt price must be > 0\\\");\\n\\n        // test the effect of he unchecked blocks\\n        unchecked {\\n            return\\n                roundUp\\n                    ? UnsafeMath.divRoundingUp(\\n                        FullMath.mulDivRoundingUp(\\n                            numerator1,\\n                            numerator2,\\n                            sqrtRatioBX96\\n                        ),\\n                        sqrtRatioAX96\\n                    )\\n                    : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) /\\n                        sqrtRatioAX96;\\n        }\\n    }\\n\\n    /// @notice Gets the amount1 delta between two prices\\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\\n    /// @param sqrtRatioAX96 A sqrt price\\n    /// @param sqrtRatioBX96 Another sqrt price\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param roundUp Whether to round the amount up, or down\\n    /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices\\n    function getAmount1Delta(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity,\\n        bool roundUp\\n    ) internal pure returns (uint256 amount1) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96)\\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        unchecked {\\n            return\\n                roundUp\\n                    ? FullMath.mulDivRoundingUp(\\n                        liquidity,\\n                        sqrtRatioBX96 - sqrtRatioAX96,\\n                        FixedPoint96.Q96\\n                    )\\n                    : FullMath.mulDiv(\\n                        liquidity,\\n                        sqrtRatioBX96 - sqrtRatioAX96,\\n                        FixedPoint96.Q96\\n                    );\\n        }\\n    }\\n\\n    /// @notice Helper that gets signed token0 delta\\n    /// @param sqrtRatioAX96 A sqrt price\\n    /// @param sqrtRatioBX96 Another sqrt price\\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\\n    /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices\\n    function getAmount0Delta(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        int128 liquidity\\n    ) internal pure returns (int256 amount0) {\\n        return\\n            liquidity < 0\\n                ? -getAmount0Delta(\\n                    sqrtRatioAX96,\\n                    sqrtRatioBX96,\\n                    uint128(-liquidity),\\n                    false\\n                ).toInt256()\\n                : getAmount0Delta(\\n                    sqrtRatioAX96,\\n                    sqrtRatioBX96,\\n                    uint128(liquidity),\\n                    true\\n                ).toInt256();\\n    }\\n\\n    /// @notice Helper that gets signed token1 delta\\n    /// @param sqrtRatioAX96 A sqrt price\\n    /// @param sqrtRatioBX96 Another sqrt price\\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\\n    /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices\\n    function getAmount1Delta(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        int128 liquidity\\n    ) internal pure returns (int256 amount1) {\\n        return\\n            liquidity < 0\\n                ? -getAmount1Delta(\\n                    sqrtRatioAX96,\\n                    sqrtRatioBX96,\\n                    uint128(-liquidity),\\n                    false\\n                ).toInt256()\\n                : getAmount1Delta(\\n                    sqrtRatioAX96,\\n                    sqrtRatioBX96,\\n                    uint128(liquidity),\\n                    true\\n                ).toInt256();\\n    }\\n}\\n\",\"keccak256\":\"0x557e0417b51d9ea0ee00ea688f8a50ebac32a56a376f78f61ca4fd7cf5853321\",\"license\":\"MIT\"},\"contracts/utils/TickMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable no-inline-assembly\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -69100;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 2503036416286949174936592462;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO = 2507794810551837817144115957740;\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(int24 tick)\\n        internal\\n        pure\\n        returns (uint160 sqrtPriceX96)\\n    {\\n        uint256 absTick = tick < 0\\n            ? uint256(-int256(tick))\\n            : uint256(int256(tick));\\n        require(absTick <= uint256(int256(MAX_TICK)), \\\"T\\\");\\n\\n        uint256 ratio = absTick & 0x1 != 0\\n            ? 0xfffcb933bd6fad37aa2d162d1a594001\\n            : 0x100000000000000000000000000000000;\\n        if (absTick & 0x2 != 0)\\n            ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n        if (absTick & 0x4 != 0)\\n            ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n        if (absTick & 0x8 != 0)\\n            ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n        if (absTick & 0x10 != 0)\\n            ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n        if (absTick & 0x20 != 0)\\n            ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n        if (absTick & 0x40 != 0)\\n            ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n        if (absTick & 0x80 != 0)\\n            ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n        if (absTick & 0x100 != 0)\\n            ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n        if (absTick & 0x200 != 0)\\n            ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n        if (absTick & 0x400 != 0)\\n            ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n        if (absTick & 0x800 != 0)\\n            ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n        if (absTick & 0x1000 != 0)\\n            ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n        if (absTick & 0x2000 != 0)\\n            ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n        if (absTick & 0x4000 != 0)\\n            ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n        if (absTick & 0x8000 != 0)\\n            ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n        if (absTick & 0x10000 != 0)\\n            ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n        if (absTick & 0x20000 != 0)\\n            ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n        if (absTick & 0x40000 != 0)\\n            ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n        if (absTick & 0x80000 != 0)\\n            ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n        if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n        sqrtPriceX96 = uint160(\\n            (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\\n        );\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96)\\n        internal\\n        pure\\n        returns (int24 tick)\\n    {\\n        // second inequality must be < because the price can never reach the price at the max tick\\n        require(\\n            sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO,\\n            \\\"R\\\"\\n        );\\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n        uint256 r = ratio;\\n        uint256 msb = 0;\\n\\n        assembly {\\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(5, gt(r, 0xFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(4, gt(r, 0xFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(3, gt(r, 0xFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(2, gt(r, 0xF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(1, gt(r, 0x3))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := gt(r, 0x1)\\n            msb := or(msb, f)\\n        }\\n\\n        if (msb >= 128) r = ratio >> (msb - 127);\\n        else r = ratio << (127 - msb);\\n\\n        // solhint-disable-next-line var-name-mixedcase\\n        int256 log_2 = (int256(msb) - 128) << 64;\\n\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(63, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(62, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(61, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(60, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(59, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(58, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(57, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(56, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(55, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(54, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(53, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(52, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(51, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(50, f))\\n        }\\n\\n        // solhint-disable-next-line var-name-mixedcase\\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n        int24 tickLow = int24(\\n            (log_sqrt10001 - 3402992956809132418596140100660247210) >> 128\\n        );\\n        int24 tickHi = int24(\\n            (log_sqrt10001 + 291339464771989622907027621153398088495) >> 128\\n        );\\n\\n        tick = tickLow == tickHi\\n            ? tickLow\\n            : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96\\n            ? tickHi\\n            : tickLow;\\n    }\\n}\\n\",\"keccak256\":\"0x3c313710df16628248321eb1eb26980642e6c4f389e35b91aa115603899727bb\",\"license\":\"MIT\"},\"contracts/utils/UnsafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable no-inline-assembly\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Math functions that do not check inputs or outputs\\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\\nlibrary UnsafeMath {\\n    /// @notice Returns ceil(x / y)\\n    /// @dev division by 0 has unspecified behavior, and must be checked externally\\n    /// @param x The dividend\\n    /// @param y The divisor\\n    /// @return z The quotient, ceil(x / y)\\n    function divRoundingUp(uint256 x, uint256 y)\\n        internal\\n        pure\\n        returns (uint256 z)\\n    {\\n        assembly {\\n            z := add(div(x, y), gt(mod(x, y), 0))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8e79605e2d45f6fdd552a96e48e46d889ea61a4f06c6e9241d19ddca8531ec81\",\"license\":\"MIT\"},\"prb-math/contracts/PRBMath.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\n/// @notice Emitted when the result overflows uint256.\\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\\n\\n/// @notice Emitted when the result overflows uint256.\\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\\n\\n/// @notice Emitted when one of the inputs is type(int256).min.\\nerror PRBMath__MulDivSignedInputTooSmall();\\n\\n/// @notice Emitted when the intermediary absolute result overflows int256.\\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is MIN_SD59x18.\\nerror PRBMathSD59x18__AbsInputTooSmall();\\n\\n/// @notice Emitted when ceiling a number overflows SD59x18.\\nerror PRBMathSD59x18__CeilOverflow(int256 x);\\n\\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\\nerror PRBMathSD59x18__DivInputTooSmall();\\n\\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is greater than 133.084258667509499441.\\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\\n\\n/// @notice Emitted when the input is greater than 192.\\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\\n\\n/// @notice Emitted when flooring a number underflows SD59x18.\\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\\n\\n/// @notice Emitted when the product of the inputs is negative.\\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\\n\\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\\n\\n/// @notice Emitted when the input is less than or equal to zero.\\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\\n\\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\\nerror PRBMathSD59x18__MulInputTooSmall();\\n\\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is negative.\\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\\n\\n/// @notice Emitted when the calculating the square root overflows SD59x18.\\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\\n\\n/// @notice Emitted when addition overflows UD60x18.\\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\\n\\n/// @notice Emitted when ceiling a number overflows UD60x18.\\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\\n\\n/// @notice Emitted when the input is greater than 133.084258667509499441.\\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\\n\\n/// @notice Emitted when the input is greater than 192.\\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\\n\\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\\n\\n/// @notice Emitted when the input is less than 1.\\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\\n\\n/// @notice Emitted when the calculating the square root overflows UD60x18.\\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\\n\\n/// @notice Emitted when subtraction underflows UD60x18.\\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\\n\\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\\nlibrary PRBMath {\\n    /// STRUCTS ///\\n\\n    struct SD59x18 {\\n        int256 value;\\n    }\\n\\n    struct UD60x18 {\\n        uint256 value;\\n    }\\n\\n    /// STORAGE ///\\n\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n    /// @dev Largest power of two divisor of SCALE.\\n    uint256 internal constant SCALE_LPOTD = 262144;\\n\\n    /// @dev SCALE inverted mod 2^256.\\n    uint256 internal constant SCALE_INVERSE =\\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\\n\\n    /// FUNCTIONS ///\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    /// @dev Has to use 192.64-bit fixed-point numbers.\\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp2(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            // Start from 0.5 in the 192.64-bit fixed-point format.\\n            result = 0x800000000000000000000000000000000000000000000000;\\n\\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\\n            if (x & 0x8000000000000000 > 0) {\\n                result = (result * 0x16A09E667F3BCC909) >> 64;\\n            }\\n            if (x & 0x4000000000000000 > 0) {\\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\\n            }\\n            if (x & 0x2000000000000000 > 0) {\\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\\n            }\\n            if (x & 0x1000000000000000 > 0) {\\n                result = (result * 0x10B5586CF9890F62A) >> 64;\\n            }\\n            if (x & 0x800000000000000 > 0) {\\n                result = (result * 0x1059B0D31585743AE) >> 64;\\n            }\\n            if (x & 0x400000000000000 > 0) {\\n                result = (result * 0x102C9A3E778060EE7) >> 64;\\n            }\\n            if (x & 0x200000000000000 > 0) {\\n                result = (result * 0x10163DA9FB33356D8) >> 64;\\n            }\\n            if (x & 0x100000000000000 > 0) {\\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\\n            }\\n            if (x & 0x80000000000000 > 0) {\\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\\n            }\\n            if (x & 0x40000000000000 > 0) {\\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\\n            }\\n            if (x & 0x20000000000000 > 0) {\\n                result = (result * 0x100162F3904051FA1) >> 64;\\n            }\\n            if (x & 0x10000000000000 > 0) {\\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\\n            }\\n            if (x & 0x8000000000000 > 0) {\\n                result = (result * 0x100058BA01FB9F96D) >> 64;\\n            }\\n            if (x & 0x4000000000000 > 0) {\\n                result = (result * 0x10002C5CC37DA9492) >> 64;\\n            }\\n            if (x & 0x2000000000000 > 0) {\\n                result = (result * 0x1000162E525EE0547) >> 64;\\n            }\\n            if (x & 0x1000000000000 > 0) {\\n                result = (result * 0x10000B17255775C04) >> 64;\\n            }\\n            if (x & 0x800000000000 > 0) {\\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\\n            }\\n            if (x & 0x400000000000 > 0) {\\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\\n            }\\n            if (x & 0x200000000000 > 0) {\\n                result = (result * 0x10000162E43F4F831) >> 64;\\n            }\\n            if (x & 0x100000000000 > 0) {\\n                result = (result * 0x100000B1721BCFC9A) >> 64;\\n            }\\n            if (x & 0x80000000000 > 0) {\\n                result = (result * 0x10000058B90CF1E6E) >> 64;\\n            }\\n            if (x & 0x40000000000 > 0) {\\n                result = (result * 0x1000002C5C863B73F) >> 64;\\n            }\\n            if (x & 0x20000000000 > 0) {\\n                result = (result * 0x100000162E430E5A2) >> 64;\\n            }\\n            if (x & 0x10000000000 > 0) {\\n                result = (result * 0x1000000B172183551) >> 64;\\n            }\\n            if (x & 0x8000000000 > 0) {\\n                result = (result * 0x100000058B90C0B49) >> 64;\\n            }\\n            if (x & 0x4000000000 > 0) {\\n                result = (result * 0x10000002C5C8601CC) >> 64;\\n            }\\n            if (x & 0x2000000000 > 0) {\\n                result = (result * 0x1000000162E42FFF0) >> 64;\\n            }\\n            if (x & 0x1000000000 > 0) {\\n                result = (result * 0x10000000B17217FBB) >> 64;\\n            }\\n            if (x & 0x800000000 > 0) {\\n                result = (result * 0x1000000058B90BFCE) >> 64;\\n            }\\n            if (x & 0x400000000 > 0) {\\n                result = (result * 0x100000002C5C85FE3) >> 64;\\n            }\\n            if (x & 0x200000000 > 0) {\\n                result = (result * 0x10000000162E42FF1) >> 64;\\n            }\\n            if (x & 0x100000000 > 0) {\\n                result = (result * 0x100000000B17217F8) >> 64;\\n            }\\n            if (x & 0x80000000 > 0) {\\n                result = (result * 0x10000000058B90BFC) >> 64;\\n            }\\n            if (x & 0x40000000 > 0) {\\n                result = (result * 0x1000000002C5C85FE) >> 64;\\n            }\\n            if (x & 0x20000000 > 0) {\\n                result = (result * 0x100000000162E42FF) >> 64;\\n            }\\n            if (x & 0x10000000 > 0) {\\n                result = (result * 0x1000000000B17217F) >> 64;\\n            }\\n            if (x & 0x8000000 > 0) {\\n                result = (result * 0x100000000058B90C0) >> 64;\\n            }\\n            if (x & 0x4000000 > 0) {\\n                result = (result * 0x10000000002C5C860) >> 64;\\n            }\\n            if (x & 0x2000000 > 0) {\\n                result = (result * 0x1000000000162E430) >> 64;\\n            }\\n            if (x & 0x1000000 > 0) {\\n                result = (result * 0x10000000000B17218) >> 64;\\n            }\\n            if (x & 0x800000 > 0) {\\n                result = (result * 0x1000000000058B90C) >> 64;\\n            }\\n            if (x & 0x400000 > 0) {\\n                result = (result * 0x100000000002C5C86) >> 64;\\n            }\\n            if (x & 0x200000 > 0) {\\n                result = (result * 0x10000000000162E43) >> 64;\\n            }\\n            if (x & 0x100000 > 0) {\\n                result = (result * 0x100000000000B1721) >> 64;\\n            }\\n            if (x & 0x80000 > 0) {\\n                result = (result * 0x10000000000058B91) >> 64;\\n            }\\n            if (x & 0x40000 > 0) {\\n                result = (result * 0x1000000000002C5C8) >> 64;\\n            }\\n            if (x & 0x20000 > 0) {\\n                result = (result * 0x100000000000162E4) >> 64;\\n            }\\n            if (x & 0x10000 > 0) {\\n                result = (result * 0x1000000000000B172) >> 64;\\n            }\\n            if (x & 0x8000 > 0) {\\n                result = (result * 0x100000000000058B9) >> 64;\\n            }\\n            if (x & 0x4000 > 0) {\\n                result = (result * 0x10000000000002C5D) >> 64;\\n            }\\n            if (x & 0x2000 > 0) {\\n                result = (result * 0x1000000000000162E) >> 64;\\n            }\\n            if (x & 0x1000 > 0) {\\n                result = (result * 0x10000000000000B17) >> 64;\\n            }\\n            if (x & 0x800 > 0) {\\n                result = (result * 0x1000000000000058C) >> 64;\\n            }\\n            if (x & 0x400 > 0) {\\n                result = (result * 0x100000000000002C6) >> 64;\\n            }\\n            if (x & 0x200 > 0) {\\n                result = (result * 0x10000000000000163) >> 64;\\n            }\\n            if (x & 0x100 > 0) {\\n                result = (result * 0x100000000000000B1) >> 64;\\n            }\\n            if (x & 0x80 > 0) {\\n                result = (result * 0x10000000000000059) >> 64;\\n            }\\n            if (x & 0x40 > 0) {\\n                result = (result * 0x1000000000000002C) >> 64;\\n            }\\n            if (x & 0x20 > 0) {\\n                result = (result * 0x10000000000000016) >> 64;\\n            }\\n            if (x & 0x10 > 0) {\\n                result = (result * 0x1000000000000000B) >> 64;\\n            }\\n            if (x & 0x8 > 0) {\\n                result = (result * 0x10000000000000006) >> 64;\\n            }\\n            if (x & 0x4 > 0) {\\n                result = (result * 0x10000000000000003) >> 64;\\n            }\\n            if (x & 0x2 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n            if (x & 0x1 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n\\n            // We're doing two things at the same time:\\n            //\\n            //   1. Multiply the result by 2^n + 1, where \\\"2^n\\\" is the integer part and the one is added to account for\\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\\n            //      rather than 192.\\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\\n            //\\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \\\"ip\\\" is the integer part \\\"2^n\\\".\\n            result *= SCALE;\\n            result >>= (191 - (x >> 64));\\n        }\\n    }\\n\\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n    /// @dev See the note on msb in the \\\"Find First Set\\\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n    /// @param x The uint256 number for which to find the index of the most significant bit.\\n    /// @return msb The index of the most significant bit as an uint256.\\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n        if (x >= 2**128) {\\n            x >>= 128;\\n            msb += 128;\\n        }\\n        if (x >= 2**64) {\\n            x >>= 64;\\n            msb += 64;\\n        }\\n        if (x >= 2**32) {\\n            x >>= 32;\\n            msb += 32;\\n        }\\n        if (x >= 2**16) {\\n            x >>= 16;\\n            msb += 16;\\n        }\\n        if (x >= 2**8) {\\n            x >>= 8;\\n            msb += 8;\\n        }\\n        if (x >= 2**4) {\\n            x >>= 4;\\n            msb += 4;\\n        }\\n        if (x >= 2**2) {\\n            x >>= 2;\\n            msb += 2;\\n        }\\n        if (x >= 2**1) {\\n            // No need to shift x any more.\\n            msb += 1;\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\\u00f7denominator) with full precision.\\n    ///\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\\n    ///\\n    /// Requirements:\\n    /// - The denominator cannot be zero.\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The multiplicand as an uint256.\\n    /// @param y The multiplier as an uint256.\\n    /// @param denominator The divisor as an uint256.\\n    /// @return result The result as an uint256.\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2^256 + prod0.\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division.\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = prod0 / denominator;\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n        if (prod1 >= denominator) {\\n            revert PRBMath__MulDivOverflow(prod1, denominator);\\n        }\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0].\\n        uint256 remainder;\\n        assembly {\\n            // Compute remainder using mulmod.\\n            remainder := mulmod(x, y, denominator)\\n\\n            // Subtract 256 bit number from 512 bit number.\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n        // See https://cs.stackexchange.com/q/138556/92363.\\n        unchecked {\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 lpotdod = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by lpotdod.\\n                denominator := div(denominator, lpotdod)\\n\\n                // Divide [prod1 prod0] by lpotdod.\\n                prod0 := div(prod0, lpotdod)\\n\\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * lpotdod;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\\u00f71e18) with full precision.\\n    ///\\n    /// @dev Variant of \\\"mulDiv\\\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\\n    /// being rounded to 1e-18.  See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717.\\n    ///\\n    /// Requirements:\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - The body is purposely left uncommented; see the NatSpec comments in \\\"PRBMath.mulDiv\\\" to understand how this works.\\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\\n    ///     1. x * y = type(uint256).max * SCALE\\n    ///     2. (x * y) % SCALE >= SCALE / 2\\n    ///\\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        uint256 prod0;\\n        uint256 prod1;\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        if (prod1 >= SCALE) {\\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\\n        }\\n\\n        uint256 remainder;\\n        uint256 roundUpUnit;\\n        assembly {\\n            remainder := mulmod(x, y, SCALE)\\n            roundUpUnit := gt(remainder, 499999999999999999)\\n        }\\n\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = (prod0 / SCALE) + roundUpUnit;\\n                return result;\\n            }\\n        }\\n\\n        assembly {\\n            result := add(\\n                mul(\\n                    or(\\n                        div(sub(prod0, remainder), SCALE_LPOTD),\\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\\n                    ),\\n                    SCALE_INVERSE\\n                ),\\n                roundUpUnit\\n            )\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\\u00f7denominator) with full precision.\\n    ///\\n    /// @dev An extension of \\\"mulDiv\\\" for signed numbers. Works by computing the signs and the absolute values separately.\\n    ///\\n    /// Requirements:\\n    /// - None of the inputs can be type(int256).min.\\n    /// - The result must fit within int256.\\n    ///\\n    /// @param x The multiplicand as an int256.\\n    /// @param y The multiplier as an int256.\\n    /// @param denominator The divisor as an int256.\\n    /// @return result The result as an int256.\\n    function mulDivSigned(\\n        int256 x,\\n        int256 y,\\n        int256 denominator\\n    ) internal pure returns (int256 result) {\\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\\n            revert PRBMath__MulDivSignedInputTooSmall();\\n        }\\n\\n        // Get hold of the absolute values of x, y and the denominator.\\n        uint256 ax;\\n        uint256 ay;\\n        uint256 ad;\\n        unchecked {\\n            ax = x < 0 ? uint256(-x) : uint256(x);\\n            ay = y < 0 ? uint256(-y) : uint256(y);\\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\\n        }\\n\\n        // Compute the absolute value of (x*y)\\u00f7denominator. The result must fit within int256.\\n        uint256 rAbs = mulDiv(ax, ay, ad);\\n        if (rAbs > uint256(type(int256).max)) {\\n            revert PRBMath__MulDivSignedOverflow(rAbs);\\n        }\\n\\n        // Get the signs of x, y and the denominator.\\n        uint256 sx;\\n        uint256 sy;\\n        uint256 sd;\\n        assembly {\\n            sx := sgt(x, sub(0, 1))\\n            sy := sgt(y, sub(0, 1))\\n            sd := sgt(denominator, sub(0, 1))\\n        }\\n\\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\\n        // If yes, the result should be negative.\\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The uint256 number for which to calculate the square root.\\n    /// @return result The result as an uint256.\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\\n        uint256 xAux = uint256(x);\\n        result = 1;\\n        if (xAux >= 0x100000000000000000000000000000000) {\\n            xAux >>= 128;\\n            result <<= 64;\\n        }\\n        if (xAux >= 0x10000000000000000) {\\n            xAux >>= 64;\\n            result <<= 32;\\n        }\\n        if (xAux >= 0x100000000) {\\n            xAux >>= 32;\\n            result <<= 16;\\n        }\\n        if (xAux >= 0x10000) {\\n            xAux >>= 16;\\n            result <<= 8;\\n        }\\n        if (xAux >= 0x100) {\\n            xAux >>= 8;\\n            result <<= 4;\\n        }\\n        if (xAux >= 0x10) {\\n            xAux >>= 4;\\n            result <<= 2;\\n        }\\n        if (xAux >= 0x8) {\\n            result <<= 1;\\n        }\\n\\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\\n        unchecked {\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1; // Seven iterations should be enough\\n            uint256 roundedDownResult = x / result;\\n            return result >= roundedDownResult ? roundedDownResult : result;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xed164c95012964f5e125b5d2b2d00471a4bdee4def618cd1fcf341d196011b61\",\"license\":\"Unlicense\"},\"prb-math/contracts/PRBMathSD59x18.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\nimport \\\"./PRBMath.sol\\\";\\n\\n/// @title PRBMathSD59x18\\n/// @author Paul Razvan Berg\\n/// @notice Smart contract library for advanced fixed-point math that works with int256 numbers considered to have 18\\n/// trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have\\n/// a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers\\n/// are bound by the minimum and the maximum values permitted by the Solidity type int256.\\nlibrary PRBMathSD59x18 {\\n    /// @dev log2(e) as a signed 59.18-decimal fixed-point number.\\n    int256 internal constant LOG2_E = 1_442695040888963407;\\n\\n    /// @dev Half the SCALE number.\\n    int256 internal constant HALF_SCALE = 5e17;\\n\\n    /// @dev The maximum value a signed 59.18-decimal fixed-point number can have.\\n    int256 internal constant MAX_SD59x18 =\\n        57896044618658097711785492504343953926634992332820282019728_792003956564819967;\\n\\n    /// @dev The maximum whole value a signed 59.18-decimal fixed-point number can have.\\n    int256 internal constant MAX_WHOLE_SD59x18 =\\n        57896044618658097711785492504343953926634992332820282019728_000000000000000000;\\n\\n    /// @dev The minimum value a signed 59.18-decimal fixed-point number can have.\\n    int256 internal constant MIN_SD59x18 =\\n        -57896044618658097711785492504343953926634992332820282019728_792003956564819968;\\n\\n    /// @dev The minimum whole value a signed 59.18-decimal fixed-point number can have.\\n    int256 internal constant MIN_WHOLE_SD59x18 =\\n        -57896044618658097711785492504343953926634992332820282019728_000000000000000000;\\n\\n    /// @dev How many trailing decimals can be represented.\\n    int256 internal constant SCALE = 1e18;\\n\\n    /// INTERNAL FUNCTIONS ///\\n\\n    /// @notice Calculate the absolute value of x.\\n    ///\\n    /// @dev Requirements:\\n    /// - x must be greater than MIN_SD59x18.\\n    ///\\n    /// @param x The number to calculate the absolute value for.\\n    /// @param result The absolute value of x.\\n    function abs(int256 x) internal pure returns (int256 result) {\\n        unchecked {\\n            if (x == MIN_SD59x18) {\\n                revert PRBMathSD59x18__AbsInputTooSmall();\\n            }\\n            result = x < 0 ? -x : x;\\n        }\\n    }\\n\\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\\n    /// @param x The first operand as a signed 59.18-decimal fixed-point number.\\n    /// @param y The second operand as a signed 59.18-decimal fixed-point number.\\n    /// @return result The arithmetic average as a signed 59.18-decimal fixed-point number.\\n    function avg(int256 x, int256 y) internal pure returns (int256 result) {\\n        // The operations can never overflow.\\n        unchecked {\\n            int256 sum = (x >> 1) + (y >> 1);\\n            if (sum < 0) {\\n                // If at least one of x and y is odd, we add 1 to the result. This is because shifting negative numbers to the\\n                // right rounds down to infinity.\\n                assembly {\\n                    result := add(sum, and(or(x, y), 1))\\n                }\\n            } else {\\n                // If both x and y are odd, we add 1 to the result. This is because if both numbers are odd, the 0.5\\n                // remainder gets truncated twice.\\n                result = sum + (x & y & 1);\\n            }\\n        }\\n    }\\n\\n    /// @notice Yields the least greatest signed 59.18 decimal fixed-point number greater than or equal to x.\\n    ///\\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    ///\\n    /// Requirements:\\n    /// - x must be less than or equal to MAX_WHOLE_SD59x18.\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number to ceil.\\n    /// @param result The least integer greater than or equal to x, as a signed 58.18-decimal fixed-point number.\\n    function ceil(int256 x) internal pure returns (int256 result) {\\n        if (x > MAX_WHOLE_SD59x18) {\\n            revert PRBMathSD59x18__CeilOverflow(x);\\n        }\\n        unchecked {\\n            int256 remainder = x % SCALE;\\n            if (remainder == 0) {\\n                result = x;\\n            } else {\\n                // Solidity uses C fmod style, which returns a modulus with the same sign as x.\\n                result = x - remainder;\\n                if (x > 0) {\\n                    result += SCALE;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Divides two signed 59.18-decimal fixed-point numbers, returning a new signed 59.18-decimal fixed-point number.\\n    ///\\n    /// @dev Variant of \\\"mulDiv\\\" that works with signed numbers. Works by computing the signs and the absolute values separately.\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"PRBMath.mulDiv\\\".\\n    /// - None of the inputs can be MIN_SD59x18.\\n    /// - The denominator cannot be zero.\\n    /// - The result must fit within int256.\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"PRBMath.mulDiv\\\".\\n    ///\\n    /// @param x The numerator as a signed 59.18-decimal fixed-point number.\\n    /// @param y The denominator as a signed 59.18-decimal fixed-point number.\\n    /// @param result The quotient as a signed 59.18-decimal fixed-point number.\\n    function div(int256 x, int256 y) internal pure returns (int256 result) {\\n        if (x == MIN_SD59x18 || y == MIN_SD59x18) {\\n            revert PRBMathSD59x18__DivInputTooSmall();\\n        }\\n\\n        // Get hold of the absolute values of x and y.\\n        uint256 ax;\\n        uint256 ay;\\n        unchecked {\\n            ax = x < 0 ? uint256(-x) : uint256(x);\\n            ay = y < 0 ? uint256(-y) : uint256(y);\\n        }\\n\\n        // Compute the absolute value of (x*SCALE)\\u00f7y. The result must fit within int256.\\n        uint256 rAbs = PRBMath.mulDiv(ax, uint256(SCALE), ay);\\n        if (rAbs > uint256(MAX_SD59x18)) {\\n            revert PRBMathSD59x18__DivOverflow(rAbs);\\n        }\\n\\n        // Get the signs of x and y.\\n        uint256 sx;\\n        uint256 sy;\\n        assembly {\\n            sx := sgt(x, sub(0, 1))\\n            sy := sgt(y, sub(0, 1))\\n        }\\n\\n        // XOR over sx and sy. This is basically checking whether the inputs have the same sign. If yes, the result\\n        // should be positive. Otherwise, it should be negative.\\n        result = sx ^ sy == 1 ? -int256(rAbs) : int256(rAbs);\\n    }\\n\\n    /// @notice Returns Euler's number as a signed 59.18-decimal fixed-point number.\\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\\n    function e() internal pure returns (int256 result) {\\n        result = 2_718281828459045235;\\n    }\\n\\n    /// @notice Calculates the natural exponent of x.\\n    ///\\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    /// - x must be less than 133.084258667509499441.\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"exp2\\\".\\n    /// - For any x less than -41.446531673892822322, the result is zero.\\n    ///\\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\\n    function exp(int256 x) internal pure returns (int256 result) {\\n        // Without this check, the value passed to \\\"exp2\\\" would be less than -59.794705707972522261.\\n        if (x < -41_446531673892822322) {\\n            return 0;\\n        }\\n\\n        // Without this check, the value passed to \\\"exp2\\\" would be greater than 192.\\n        if (x >= 133_084258667509499441) {\\n            revert PRBMathSD59x18__ExpInputTooBig(x);\\n        }\\n\\n        // Do the fixed-point multiplication inline to save gas.\\n        unchecked {\\n            int256 doubleScaleProduct = x * LOG2_E;\\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\\n        }\\n    }\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    ///\\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\\n    ///\\n    /// Requirements:\\n    /// - x must be 192 or less.\\n    /// - The result must fit within MAX_SD59x18.\\n    ///\\n    /// Caveats:\\n    /// - For any x less than -59.794705707972522261, the result is zero.\\n    ///\\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\\n    function exp2(int256 x) internal pure returns (int256 result) {\\n        // This works because 2^(-x) = 1/2^x.\\n        if (x < 0) {\\n            // 2^59.794705707972522262 is the maximum number whose inverse does not truncate down to zero.\\n            if (x < -59_794705707972522261) {\\n                return 0;\\n            }\\n\\n            // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\\n            unchecked {\\n                result = 1e36 / exp2(-x);\\n            }\\n        } else {\\n            // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\\n            if (x >= 192e18) {\\n                revert PRBMathSD59x18__Exp2InputTooBig(x);\\n            }\\n\\n            unchecked {\\n                // Convert x to the 192.64-bit fixed-point format.\\n                uint256 x192x64 = (uint256(x) << 64) / uint256(SCALE);\\n\\n                // Safe to convert the result to int256 directly because the maximum input allowed is 192.\\n                result = int256(PRBMath.exp2(x192x64));\\n            }\\n        }\\n    }\\n\\n    /// @notice Yields the greatest signed 59.18 decimal fixed-point number less than or equal to x.\\n    ///\\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    ///\\n    /// Requirements:\\n    /// - x must be greater than or equal to MIN_WHOLE_SD59x18.\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number to floor.\\n    /// @param result The greatest integer less than or equal to x, as a signed 58.18-decimal fixed-point number.\\n    function floor(int256 x) internal pure returns (int256 result) {\\n        if (x < MIN_WHOLE_SD59x18) {\\n            revert PRBMathSD59x18__FloorUnderflow(x);\\n        }\\n        unchecked {\\n            int256 remainder = x % SCALE;\\n            if (remainder == 0) {\\n                result = x;\\n            } else {\\n                // Solidity uses C fmod style, which returns a modulus with the same sign as x.\\n                result = x - remainder;\\n                if (x < 0) {\\n                    result -= SCALE;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Yields the excess beyond the floor of x for positive numbers and the part of the number to the right\\n    /// of the radix point for negative numbers.\\n    /// @dev Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part\\n    /// @param x The signed 59.18-decimal fixed-point number to get the fractional part of.\\n    /// @param result The fractional part of x as a signed 59.18-decimal fixed-point number.\\n    function frac(int256 x) internal pure returns (int256 result) {\\n        unchecked {\\n            result = x % SCALE;\\n        }\\n    }\\n\\n    /// @notice Converts a number from basic integer form to signed 59.18-decimal fixed-point representation.\\n    ///\\n    /// @dev Requirements:\\n    /// - x must be greater than or equal to MIN_SD59x18 divided by SCALE.\\n    /// - x must be less than or equal to MAX_SD59x18 divided by SCALE.\\n    ///\\n    /// @param x The basic integer to convert.\\n    /// @param result The same number in signed 59.18-decimal fixed-point representation.\\n    function fromInt(int256 x) internal pure returns (int256 result) {\\n        unchecked {\\n            if (x < MIN_SD59x18 / SCALE) {\\n                revert PRBMathSD59x18__FromIntUnderflow(x);\\n            }\\n            if (x > MAX_SD59x18 / SCALE) {\\n                revert PRBMathSD59x18__FromIntOverflow(x);\\n            }\\n            result = x * SCALE;\\n        }\\n    }\\n\\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\\n    ///\\n    /// @dev Requirements:\\n    /// - x * y must fit within MAX_SD59x18, lest it overflows.\\n    /// - x * y cannot be negative.\\n    ///\\n    /// @param x The first operand as a signed 59.18-decimal fixed-point number.\\n    /// @param y The second operand as a signed 59.18-decimal fixed-point number.\\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\\n    function gm(int256 x, int256 y) internal pure returns (int256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        unchecked {\\n            // Checking for overflow this way is faster than letting Solidity do it.\\n            int256 xy = x * y;\\n            if (xy / x != y) {\\n                revert PRBMathSD59x18__GmOverflow(x, y);\\n            }\\n\\n            // The product cannot be negative.\\n            if (xy < 0) {\\n                revert PRBMathSD59x18__GmNegativeProduct(x, y);\\n            }\\n\\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\\n            // during multiplication. See the comments within the \\\"sqrt\\\" function.\\n            result = int256(PRBMath.sqrt(uint256(xy)));\\n        }\\n    }\\n\\n    /// @notice Calculates 1 / x, rounding toward zero.\\n    ///\\n    /// @dev Requirements:\\n    /// - x cannot be zero.\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the inverse.\\n    /// @return result The inverse as a signed 59.18-decimal fixed-point number.\\n    function inv(int256 x) internal pure returns (int256 result) {\\n        unchecked {\\n            // 1e36 is SCALE * SCALE.\\n            result = 1e36 / x;\\n        }\\n    }\\n\\n    /// @notice Calculates the natural logarithm of x.\\n    ///\\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    /// - This doesn't return exactly 1 for 2718281828459045235, for that we would need more fine-grained precision.\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the natural logarithm.\\n    /// @return result The natural logarithm as a signed 59.18-decimal fixed-point number.\\n    function ln(int256 x) internal pure returns (int256 result) {\\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\\n        // can return is 195205294292027477728.\\n        unchecked {\\n            result = (log2(x) * SCALE) / LOG2_E;\\n        }\\n    }\\n\\n    /// @notice Calculates the common logarithm of x.\\n    ///\\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the common logarithm.\\n    /// @return result The common logarithm as a signed 59.18-decimal fixed-point number.\\n    function log10(int256 x) internal pure returns (int256 result) {\\n        if (x <= 0) {\\n            revert PRBMathSD59x18__LogInputTooSmall(x);\\n        }\\n\\n        // Note that the \\\"mul\\\" in this block is the assembly mul operation, not the \\\"mul\\\" function defined in this contract.\\n        // prettier-ignore\\n        assembly {\\n            switch x\\n            case 1 { result := mul(SCALE, sub(0, 18)) }\\n            case 10 { result := mul(SCALE, sub(1, 18)) }\\n            case 100 { result := mul(SCALE, sub(2, 18)) }\\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\\n            case 1000000000000000000 { result := 0 }\\n            case 10000000000000000000 { result := SCALE }\\n            case 100000000000000000000 { result := mul(SCALE, 2) }\\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\\n            default {\\n                result := MAX_SD59x18\\n            }\\n        }\\n\\n        if (result == MAX_SD59x18) {\\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\\n            unchecked {\\n                result = (log2(x) * SCALE) / 3_321928094887362347;\\n            }\\n        }\\n    }\\n\\n    /// @notice Calculates the binary logarithm of x.\\n    ///\\n    /// @dev Based on the iterative approximation algorithm.\\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n    ///\\n    /// Requirements:\\n    /// - x must be greater than zero.\\n    ///\\n    /// Caveats:\\n    /// - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the binary logarithm.\\n    /// @return result The binary logarithm as a signed 59.18-decimal fixed-point number.\\n    function log2(int256 x) internal pure returns (int256 result) {\\n        if (x <= 0) {\\n            revert PRBMathSD59x18__LogInputTooSmall(x);\\n        }\\n        unchecked {\\n            // This works because log2(x) = -log2(1/x).\\n            int256 sign;\\n            if (x >= SCALE) {\\n                sign = 1;\\n            } else {\\n                sign = -1;\\n                // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\\n                assembly {\\n                    x := div(1000000000000000000000000000000000000, x)\\n                }\\n            }\\n\\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\\n            uint256 n = PRBMath.mostSignificantBit(uint256(x / SCALE));\\n\\n            // The integer part of the logarithm as a signed 59.18-decimal fixed-point number. The operation can't overflow\\n            // because n is maximum 255, SCALE is 1e18 and sign is either 1 or -1.\\n            result = int256(n) * SCALE;\\n\\n            // This is y = x * 2^(-n).\\n            int256 y = x >> n;\\n\\n            // If y = 1, the fractional part is zero.\\n            if (y == SCALE) {\\n                return result * sign;\\n            }\\n\\n            // Calculate the fractional part via the iterative approximation.\\n            // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n            for (int256 delta = int256(HALF_SCALE); delta > 0; delta >>= 1) {\\n                y = (y * y) / SCALE;\\n\\n                // Is y^2 > 2 and so in the range [2,4)?\\n                if (y >= 2 * SCALE) {\\n                    // Add the 2^(-m) factor to the logarithm.\\n                    result += delta;\\n\\n                    // Corresponds to z/2 on Wikipedia.\\n                    y >>= 1;\\n                }\\n            }\\n            result *= sign;\\n        }\\n    }\\n\\n    /// @notice Multiplies two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal\\n    /// fixed-point number.\\n    ///\\n    /// @dev Variant of \\\"mulDiv\\\" that works with signed numbers and employs constant folding, i.e. the denominator is\\n    /// always 1e18.\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"PRBMath.mulDivFixedPoint\\\".\\n    /// - None of the inputs can be MIN_SD59x18\\n    /// - The result must fit within MAX_SD59x18.\\n    ///\\n    /// Caveats:\\n    /// - The body is purposely left uncommented; see the NatSpec comments in \\\"PRBMath.mulDiv\\\" to understand how this works.\\n    ///\\n    /// @param x The multiplicand as a signed 59.18-decimal fixed-point number.\\n    /// @param y The multiplier as a signed 59.18-decimal fixed-point number.\\n    /// @return result The product as a signed 59.18-decimal fixed-point number.\\n    function mul(int256 x, int256 y) internal pure returns (int256 result) {\\n        if (x == MIN_SD59x18 || y == MIN_SD59x18) {\\n            revert PRBMathSD59x18__MulInputTooSmall();\\n        }\\n\\n        unchecked {\\n            uint256 ax;\\n            uint256 ay;\\n            ax = x < 0 ? uint256(-x) : uint256(x);\\n            ay = y < 0 ? uint256(-y) : uint256(y);\\n\\n            uint256 rAbs = PRBMath.mulDivFixedPoint(ax, ay);\\n            if (rAbs > uint256(MAX_SD59x18)) {\\n                revert PRBMathSD59x18__MulOverflow(rAbs);\\n            }\\n\\n            uint256 sx;\\n            uint256 sy;\\n            assembly {\\n                sx := sgt(x, sub(0, 1))\\n                sy := sgt(y, sub(0, 1))\\n            }\\n            result = sx ^ sy == 1 ? -int256(rAbs) : int256(rAbs);\\n        }\\n    }\\n\\n    /// @notice Returns PI as a signed 59.18-decimal fixed-point number.\\n    function pi() internal pure returns (int256 result) {\\n        result = 3_141592653589793238;\\n    }\\n\\n    /// @notice Raises x to the power of y.\\n    ///\\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"exp2\\\", \\\"log2\\\" and \\\"mul\\\".\\n    /// - z cannot be zero.\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"exp2\\\", \\\"log2\\\" and \\\"mul\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x Number to raise to given power y, as a signed 59.18-decimal fixed-point number.\\n    /// @param y Exponent to raise x to, as a signed 59.18-decimal fixed-point number.\\n    /// @return result x raised to power y, as a signed 59.18-decimal fixed-point number.\\n    function pow(int256 x, int256 y) internal pure returns (int256 result) {\\n        if (x == 0) {\\n            result = y == 0 ? SCALE : int256(0);\\n        } else {\\n            result = exp2(mul(log2(x), y));\\n        }\\n    }\\n\\n    /// @notice Raises x (signed 59.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\\n    /// famous algorithm \\\"exponentiation by squaring\\\".\\n    ///\\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"abs\\\" and \\\"PRBMath.mulDivFixedPoint\\\".\\n    /// - The result must fit within MAX_SD59x18.\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"PRBMath.mulDivFixedPoint\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x The base as a signed 59.18-decimal fixed-point number.\\n    /// @param y The exponent as an uint256.\\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\\n    function powu(int256 x, uint256 y) internal pure returns (int256 result) {\\n        uint256 xAbs = uint256(abs(x));\\n\\n        // Calculate the first iteration of the loop in advance.\\n        uint256 rAbs = y & 1 > 0 ? xAbs : uint256(SCALE);\\n\\n        // Equivalent to \\\"for(y /= 2; y > 0; y /= 2)\\\" but faster.\\n        uint256 yAux = y;\\n        for (yAux >>= 1; yAux > 0; yAux >>= 1) {\\n            xAbs = PRBMath.mulDivFixedPoint(xAbs, xAbs);\\n\\n            // Equivalent to \\\"y % 2 == 1\\\" but faster.\\n            if (yAux & 1 > 0) {\\n                rAbs = PRBMath.mulDivFixedPoint(rAbs, xAbs);\\n            }\\n        }\\n\\n        // The result must fit within the 59.18-decimal fixed-point representation.\\n        if (rAbs > uint256(MAX_SD59x18)) {\\n            revert PRBMathSD59x18__PowuOverflow(rAbs);\\n        }\\n\\n        // Is the base negative and the exponent an odd number?\\n        bool isNegative = x < 0 && y & 1 == 1;\\n        result = isNegative ? -int256(rAbs) : int256(rAbs);\\n    }\\n\\n    /// @notice Returns 1 as a signed 59.18-decimal fixed-point number.\\n    function scale() internal pure returns (int256 result) {\\n        result = SCALE;\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Requirements:\\n    /// - x cannot be negative.\\n    /// - x must be less than MAX_SD59x18 / SCALE.\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the square root.\\n    /// @return result The result as a signed 59.18-decimal fixed-point .\\n    function sqrt(int256 x) internal pure returns (int256 result) {\\n        unchecked {\\n            if (x < 0) {\\n                revert PRBMathSD59x18__SqrtNegativeInput(x);\\n            }\\n            if (x > MAX_SD59x18 / SCALE) {\\n                revert PRBMathSD59x18__SqrtOverflow(x);\\n            }\\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two signed\\n            // 59.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\\n            result = int256(PRBMath.sqrt(uint256(x * SCALE)));\\n        }\\n    }\\n\\n    /// @notice Converts a signed 59.18-decimal fixed-point number to basic integer form, rounding down in the process.\\n    /// @param x The signed 59.18-decimal fixed-point number to convert.\\n    /// @return result The same number in basic integer form.\\n    function toInt(int256 x) internal pure returns (int256 result) {\\n        unchecked {\\n            result = x / SCALE;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1886d687eace717c05b7dcc20e43a088df0e549df86b453c2222961b520308f0\",\"license\":\"Unlicense\"},\"prb-math/contracts/PRBMathUD60x18.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\nimport \\\"./PRBMath.sol\\\";\\n\\n/// @title PRBMathUD60x18\\n/// @author Paul Razvan Berg\\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\\n/// maximum values permitted by the Solidity type uint256.\\nlibrary PRBMathUD60x18 {\\n    /// @dev Half the SCALE number.\\n    uint256 internal constant HALF_SCALE = 5e17;\\n\\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\\n    uint256 internal constant LOG2_E = 1_442695040888963407;\\n\\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\\n    uint256 internal constant MAX_UD60x18 =\\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\\n\\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\\n    uint256 internal constant MAX_WHOLE_UD60x18 =\\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\\n\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        // The operations can never overflow.\\n        unchecked {\\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\\n        }\\n    }\\n\\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\\n    ///\\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    ///\\n    /// Requirements:\\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\\n    function ceil(uint256 x) internal pure returns (uint256 result) {\\n        if (x > MAX_WHOLE_UD60x18) {\\n            revert PRBMathUD60x18__CeilOverflow(x);\\n        }\\n        assembly {\\n            // Equivalent to \\\"x % SCALE\\\" but faster.\\n            let remainder := mod(x, SCALE)\\n\\n            // Equivalent to \\\"SCALE - remainder\\\" but faster.\\n            let delta := sub(SCALE, remainder)\\n\\n            // Equivalent to \\\"x + delta * (remainder > 0 ? 1 : 0)\\\" but faster.\\n            result := add(x, mul(delta, gt(remainder, 0)))\\n        }\\n    }\\n\\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\\n    ///\\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\\n    ///\\n    /// Requirements:\\n    /// - The denominator cannot be zero.\\n    ///\\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        result = PRBMath.mulDiv(x, SCALE, y);\\n    }\\n\\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\\n    function e() internal pure returns (uint256 result) {\\n        result = 2_718281828459045235;\\n    }\\n\\n    /// @notice Calculates the natural exponent of x.\\n    ///\\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    /// - x must be less than 133.084258667509499441.\\n    ///\\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp(uint256 x) internal pure returns (uint256 result) {\\n        // Without this check, the value passed to \\\"exp2\\\" would be greater than 192.\\n        if (x >= 133_084258667509499441) {\\n            revert PRBMathUD60x18__ExpInputTooBig(x);\\n        }\\n\\n        // Do the fixed-point multiplication inline to save gas.\\n        unchecked {\\n            uint256 doubleScaleProduct = x * LOG2_E;\\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\\n        }\\n    }\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    ///\\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\\n    ///\\n    /// Requirements:\\n    /// - x must be 192 or less.\\n    /// - The result must fit within MAX_UD60x18.\\n    ///\\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp2(uint256 x) internal pure returns (uint256 result) {\\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\\n        if (x >= 192e18) {\\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\\n        }\\n\\n        unchecked {\\n            // Convert x to the 192.64-bit fixed-point format.\\n            uint256 x192x64 = (x << 64) / SCALE;\\n\\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\\n            result = PRBMath.exp2(x192x64);\\n        }\\n    }\\n\\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\\n    function floor(uint256 x) internal pure returns (uint256 result) {\\n        assembly {\\n            // Equivalent to \\\"x % SCALE\\\" but faster.\\n            let remainder := mod(x, SCALE)\\n\\n            // Equivalent to \\\"x - remainder * (remainder > 0 ? 1 : 0)\\\" but faster.\\n            result := sub(x, mul(remainder, gt(remainder, 0)))\\n        }\\n    }\\n\\n    /// @notice Yields the excess beyond the floor of x.\\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\\n    function frac(uint256 x) internal pure returns (uint256 result) {\\n        assembly {\\n            result := mod(x, SCALE)\\n        }\\n    }\\n\\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\\n    ///\\n    /// @dev Requirements:\\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\\n    ///\\n    /// @param x The basic integer to convert.\\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            if (x > MAX_UD60x18 / SCALE) {\\n                revert PRBMathUD60x18__FromUintOverflow(x);\\n            }\\n            result = x * SCALE;\\n        }\\n    }\\n\\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\\n    ///\\n    /// @dev Requirements:\\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\\n    ///\\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        unchecked {\\n            // Checking for overflow this way is faster than letting Solidity do it.\\n            uint256 xy = x * y;\\n            if (xy / x != y) {\\n                revert PRBMathUD60x18__GmOverflow(x, y);\\n            }\\n\\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\\n            // during multiplication. See the comments within the \\\"sqrt\\\" function.\\n            result = PRBMath.sqrt(xy);\\n        }\\n    }\\n\\n    /// @notice Calculates 1 / x, rounding toward zero.\\n    ///\\n    /// @dev Requirements:\\n    /// - x cannot be zero.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\\n    function inv(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 1e36 is SCALE * SCALE.\\n            result = 1e36 / x;\\n        }\\n    }\\n\\n    /// @notice Calculates the natural logarithm of x.\\n    ///\\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function ln(uint256 x) internal pure returns (uint256 result) {\\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\\n        // can return is 196205294292027477728.\\n        unchecked {\\n            result = (log2(x) * SCALE) / LOG2_E;\\n        }\\n    }\\n\\n    /// @notice Calculates the common logarithm of x.\\n    ///\\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function log10(uint256 x) internal pure returns (uint256 result) {\\n        if (x < SCALE) {\\n            revert PRBMathUD60x18__LogInputTooSmall(x);\\n        }\\n\\n        // Note that the \\\"mul\\\" in this block is the assembly multiplication operation, not the \\\"mul\\\" function defined\\n        // in this contract.\\n        // prettier-ignore\\n        assembly {\\n            switch x\\n            case 1 { result := mul(SCALE, sub(0, 18)) }\\n            case 10 { result := mul(SCALE, sub(1, 18)) }\\n            case 100 { result := mul(SCALE, sub(2, 18)) }\\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\\n            case 1000000000000000000 { result := 0 }\\n            case 10000000000000000000 { result := SCALE }\\n            case 100000000000000000000 { result := mul(SCALE, 2) }\\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\\n            default {\\n                result := MAX_UD60x18\\n            }\\n        }\\n\\n        if (result == MAX_UD60x18) {\\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\\n            unchecked {\\n                result = (log2(x) * SCALE) / 3_321928094887362347;\\n            }\\n        }\\n    }\\n\\n    /// @notice Calculates the binary logarithm of x.\\n    ///\\n    /// @dev Based on the iterative approximation algorithm.\\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n    ///\\n    /// Requirements:\\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\\n    ///\\n    /// Caveats:\\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function log2(uint256 x) internal pure returns (uint256 result) {\\n        if (x < SCALE) {\\n            revert PRBMathUD60x18__LogInputTooSmall(x);\\n        }\\n        unchecked {\\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\\n\\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\\n            // because n is maximum 255 and SCALE is 1e18.\\n            result = n * SCALE;\\n\\n            // This is y = x * 2^(-n).\\n            uint256 y = x >> n;\\n\\n            // If y = 1, the fractional part is zero.\\n            if (y == SCALE) {\\n                return result;\\n            }\\n\\n            // Calculate the fractional part via the iterative approximation.\\n            // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\\n                y = (y * y) / SCALE;\\n\\n                // Is y^2 > 2 and so in the range [2,4)?\\n                if (y >= 2 * SCALE) {\\n                    // Add the 2^(-m) factor to the logarithm.\\n                    result += delta;\\n\\n                    // Corresponds to z/2 on Wikipedia.\\n                    y >>= 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\\n    /// fixed-point number.\\n    /// @dev See the documentation for the \\\"PRBMath.mulDivFixedPoint\\\" function.\\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        result = PRBMath.mulDivFixedPoint(x, y);\\n    }\\n\\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\\n    function pi() internal pure returns (uint256 result) {\\n        result = 3_141592653589793238;\\n    }\\n\\n    /// @notice Raises x to the power of y.\\n    ///\\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"exp2\\\", \\\"log2\\\" and \\\"mul\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"exp2\\\", \\\"log2\\\" and \\\"mul\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            result = y == 0 ? SCALE : uint256(0);\\n        } else {\\n            result = exp2(mul(log2(x), y));\\n        }\\n    }\\n\\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\\n    /// famous algorithm \\\"exponentiation by squaring\\\".\\n    ///\\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\\n    ///\\n    /// Requirements:\\n    /// - The result must fit within MAX_UD60x18.\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"mul\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The exponent as an uint256.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        // Calculate the first iteration of the loop in advance.\\n        result = y & 1 > 0 ? x : SCALE;\\n\\n        // Equivalent to \\\"for(y /= 2; y > 0; y /= 2)\\\" but faster.\\n        for (y >>= 1; y > 0; y >>= 1) {\\n            x = PRBMath.mulDivFixedPoint(x, x);\\n\\n            // Equivalent to \\\"y % 2 == 1\\\" but faster.\\n            if (y & 1 > 0) {\\n                result = PRBMath.mulDivFixedPoint(result, x);\\n            }\\n        }\\n    }\\n\\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\\n    function scale() internal pure returns (uint256 result) {\\n        result = SCALE;\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Requirements:\\n    /// - x must be less than MAX_UD60x18 / SCALE.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            if (x > MAX_UD60x18 / SCALE) {\\n                revert PRBMathUD60x18__SqrtOverflow(x);\\n            }\\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\\n            result = PRBMath.sqrt(x * SCALE);\\n        }\\n    }\\n\\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\\n    /// @return result The same number in basic integer form.\\n    function toUint(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = x / SCALE;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2180489de7680a79844dd5ef145f800e4f68e515e0e89409242f0187dbbd657b\",\"license\":\"Unlicense\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b50600054610100900460ff166200002f5760005460ff161562000039565b62000039620000f0565b620000a15760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b606482015260840160405180910390fd5b600054610100900460ff16158015620000c4576000805461ffff19166101011790555b60b480546001600160a01b031916331790558015620000e9576000805461ff00191690555b506200011d565b600062000108306200010e60201b6200150f1760201c565b15905090565b6001600160a01b03163b151590565b615252806200012d6000396000f3fe608060405234801561001057600080fd5b50600436106101755760003560e01c806322d23b211461017a5780632495a599146101a357806329c9a410146101b6578063534d3375146101cb5780635c975abb146101de578063633dd145146101f4578063652c30b71461020b578063715018a614610214578063754e2a8f1461021c5780637717797f1461022f5780637a55433c146102425780638da5cb5b146102555780639209e9ba1461025d57806393edb454146102d757806398f4b1b2146102e0578063b5c22d49146102f3578063b623f51914610306578063ba795d321461030f578063bfb5607d14610322578063c326189214610335578063c45a015514610348578063c7607a9c1461035b578063d1b565dc1461036e578063d50d881114610381578063e087caf114610389578063e098372c14610392578063e3f08374146103a5578063e9e441bb146103ad578063eb990c59146103c0578063efcfc3f9146103d3578063f2fde38b146103e6575b600080fd5b609b5461018d906001600160a01b031681565b60405161019a9190614e0e565b60405180910390f35b60985461018d906001600160a01b031681565b6101c96101c4366004614b0d565b6103f9565b005b6101c96101d9366004614a12565b610516565b60655460ff16604051901515815260200161019a565b6101fd60b05481565b60405190815260200161019a565b6101fd60995481565b6101c9610570565b6101c961022a366004614b71565b6105ab565b6101c961023d366004614abd565b6106a4565b6101c9610250366004614bbc565b610937565b61018d610b5b565b61027061026b366004614a73565b610b6a565b60405161019a91908151151581526020808301516001600160801b03169082015260408083015190820152606080830151908201526080808301519082015260a0808301519082015260c0808301519082015260e091820151918101919091526101000190565b6101fd609a5481565b60b65461018d906001600160a01b031681565b6101c9610301366004614c28565b610c38565b6101fd60b35481565b6101c961031d366004614dde565b610cff565b6101c9610330366004614d03565b610d68565b6101c9610343366004614dde565b610e50565b60b55461018d906001600160a01b031681565b6101c9610369366004614a12565b610eb9565b6101c961037c366004614bbc565b610f0a565b6101fd611152565b6101fd60975481565b609d5461018d906001600160a01b031681565b6101fd61117f565b6101c96103bb366004614dde565b6111a0565b6101c96103ce366004614a2e565b611209565b6101c96103e1366004614b71565b611429565b6101c96103f4366004614a12565b61146f565b609d546001600160a01b0316331461042457604051633dec6c6960e11b815260040160405180910390fd5b6000610433609c88888861151e565b9050610442818787600061157d565b811561045b5761045b610454836151b2565b8290611727565b6104668185856117a2565b60006104758288886000611845565b9050816001015481131561049c5760405163d9ce82ab60e01b815260040160405180910390fd5b600482015460058301546001840154604080516001600160a01b038d16815260028c810b60208301528b900b818301526060810194909452608084019290925260a0830152517fa6a26c171f0478962e0cfe711f994e7bb063211f49fe9387ff5d9f8c42b5abc99181900360c00190a15050505050505050565b3361051f610b5b565b6001600160a01b03161461054e5760405162461bcd60e51b815260040161054590614e6f565b60405180910390fd5b609b80546001600160a01b0319166001600160a01b0392909216919091179055565b33610579610b5b565b6001600160a01b03161461059f5760405162461bcd60e51b815260040161054590614e6f565b6105a96000611c0c565b565b336105b4610b5b565b6001600160a01b0316146105da5760405162461bcd60e51b815260040161054590614e6f565b801561065657609d54604051630867377160e41b8152600481018390526001600160a01b0390911690638673771090602401600060405180830381600087803b15801561062657600080fd5b505af115801561063a573d6000803e3d6000fd5b505060985461065692506001600160a01b031690508383611c5e565b604080513381526001600160a01b03841660208201529081018290527f4a18654a5039b989ca382f52bbf82bcdde698ffc4c11fe6c59652a4d1fe70f48906060015b60405180910390a15050565b80806106c357604051638acc6d7f60e01b815260040160405180910390fd5b6106cd8484611cd7565b60006106dc609c87878761151e565b90506106eb818686600061157d565b60008382600101546106fd9190614fcc565b121561074b5760405162461bcd60e51b815260206004820152601d60248201527f63616e2774207769746864726177206d6f7265207468616e20686176650000006044820152606401610545565b600083121561082e576001600160a01b03861633148015906107ec575060b5546040516351c4bc1f60e11b81526001600160a01b039091169063a389783e9061079a9089903390600401614e22565b60206040518083038186803b1580156107b257600080fd5b505afa1580156107c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107ea9190614b9c565b155b1561080a57604051637da45ce760e01b815260040160405180910390fd5b6108148184611727565b61081f818686611d98565b6108298684611dfb565b6108d6565b6108388184611727565b60b5546040516351c4bc1f60e11b81526000916001600160a01b03169063a389783e9061086b908a903390600401614e22565b60206040518083038186803b15801561088357600080fd5b505afa158015610897573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108bb9190614b9c565b156108c75750856108ca565b50335b6108d48185611dfb565b505b6001810154604080516001600160a01b0389168152600288810b602083015287900b818301526060810192909252517f9ed2335b5963496e2d16b7c4dbb12cd4000c2603f17e4df78f3c1973ce12a62a9181900360800190a1505050505050565b610942609a54611f72565b156109895760405162461bcd60e51b8152602060048201526017602482015276636c6f7365546f4f724265796f6e644d6174757269747960481b6044820152606401610545565b6109938383611cd7565b60006109a2609c83868661151e565b90506109b1818585600061157d565b60006109be828686611fbb565b9050806109de5760405163bf87c7d560e01b815260040160405180910390fd5b60006109f86109f08460010154611fef565b60975461203c565b9050670de0b6b3a76400008104610a18610a11826151b2565b8590611727565b835461010090046001600160801b031615610aa557609d548454604051631f2f089360e01b81526001600160a01b0390921691631f2f089391610a729189918c918c9161010090046001600160801b031690600401614e3c565b600060405180830381600087803b158015610a8c57600080fd5b505af1158015610aa0573d6000803e3d6000fd5b505050505b610ab184868989612048565b609854610ac8906001600160a01b03163383611c5e565b6004840154600585015460018601548654604080516001600160a01b038b16815260028d810b60208301528c900b918101919091526060810194909452608084019290925260a083015261010090046001600160801b031660c08201527f54e1aa9dab65a1673f75c6910ea071845b62a5cd1fa6a2bb09348ec2d00b14169060e00160405180910390a150505050505050565b6033546001600160a01b031690565b610bbd60405180610100016040528060001515815260200160006001600160801b031681526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b610bca609c85858561151e565b604080516101008082018352835460ff811615158352046001600160801b031660208201526001830154918101919091526002820154606082015260038201546080820152600482015460a0820152600582015460c082015260069091015460e082015290505b9392505050565b33610c41610b5b565b6001600160a01b031614610c675760405162461bcd60e51b815260040161054590614e6f565b8051609e556020810151609f55604081015160a0908155606082015160a155608082015160a25581015160a35560c081015160a45560e081015160a55561010081015160a65561012081015160a75561014081015160a85561016081015160a95561018081015160aa556101a081015160ab556101c081015160ac556101e081015160ad5561020081015160ae55610220015160af55565b33610d08610b5b565b6001600160a01b031614610d2e5760405162461bcd60e51b815260040161054590614e6f565b60b08054908290556040517f4006ccfc8bf8f1556fc00b810abde999309f22813206397ad6d10430152817ed906106989083908590614f87565b609d546001600160a01b03163314610d9357604051633dec6c6960e11b815260040160405180910390fd5b805160208201516040830151600092610dae92609c9261151e565b9050610dc58183602001518460400151600161157d565b6060820151610dd5908290612278565b60008260600151600f0b1315610df857610df88183602001518460400151612375565b7f3eabc3706d08c6a8e3a01e0c047428e62f14c7c20a7fb49b2492fe8ac59f8bcd8260000151836020015184604001518460000160019054906101000a90046001600160801b03166040516106989493929190614e3c565b33610e59610b5b565b6001600160a01b031614610e7f5760405162461bcd60e51b815260040161054590614e6f565b60b38054908290556040517f4918c9706535b0901b483e33d83971ada066b087344ed55e16428d25acdb6e11906106989083908590614f87565b33610ec2610b5b565b6001600160a01b031614610ee85760405162461bcd60e51b815260040161054590614e6f565b609d80546001600160a01b0319166001600160a01b0392909216919091179055565b60655460ff1615610f505760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b6044820152606401610545565b610f586123aa565b609a541115610f7a576040516301730b8160e11b815260040160405180910390fd5b610f848383611cd7565b6000610f93609c83868661151e565b805490915060ff1615610fda5760405162461bcd60e51b815260206004820152600f60248201526e185b1c9958591e481cd95d1d1b1959608a1b6044820152606401610545565b610fe7818585600061157d565b6004808201546005830154609954609a5460b6546040516325f258dd60e01b815260009661108896959493926001600160a01b0316916325f258dd91611031918691869101614f87565b602060405180830381600087803b15801561104b57600080fd5b505af115801561105f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110839190614df6565b6123b5565b90506110b1826004015461109b906151b2565b83600501546110a9906151b2565b8491906117a2565b6110bb8282611727565b6110cc82805460ff19166001179055565b6004820154600583015460018401548454604080516001600160a01b038916815260028b810b60208301528a900b818301526060810195909552608085019390935260a084019190915260ff16151560c0830152517ff8509b713e5189b4a0db0a68c687471fa8aeae7a70dbb0981f9e390e400631709181900360e00190a15050505050565b600060b35442611162919061512c565b60b254101561117857611173612420565b905090565b5060b15490565b600060b3544261118f919061512c565b60b2541015611178576111786124be565b336111a9610b5b565b6001600160a01b0316146111cf5760405162461bcd60e51b815260040161054590614e6f565b60978054908290556040517fb3eb2e4cbd291aa9b5b858b0d00e57a006f03b5a24ce306afc163d07ae1fc53e906106989083908590614f87565b600054610100900460ff166112245760005460ff161561122c565b61122c6124cf565b61128f5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608401610545565b600054610100900460ff161580156112b1576000805461ffff19166101011790555b6001600160a01b0385166112f85760405162461bcd60e51b815260206004820152600e60248201526d1555081b5d5cdd081899481cd95d60921b6044820152606401610545565b6001600160a01b03841661133f5760405162461bcd60e51b815260206004820152600e60248201526d1493c81b5d5cdd081899481cd95d60921b6044820152606401610545565b8261137d5760405162461bcd60e51b815260206004820152600e60248201526d1514c81b5d5cdd081899481cd95d60921b6044820152606401610545565b816113bb5760405162461bcd60e51b815260206004820152600e60248201526d1511481b5d5cdd081899481cd95d60921b6044820152606401610545565b609880546001600160a01b038088166001600160a01b0319928316179092556099859055609a84905560b680549287169282169290921790915560b58054909116331790556114086124e0565b61141061250f565b8015611422576000805461ff00191690555b5050505050565b609b546001600160a01b0316331461145457604051635d8a367560e01b815260040160405180910390fd5b60985461146b906001600160a01b03168383611c5e565b5050565b33611478610b5b565b6001600160a01b03161461149e5760405162461bcd60e51b815260040161054590614e6f565b6001600160a01b0381166115035760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610545565b61150c81611c0c565b50565b6001600160a01b03163b151590565b6040805160609490941b6001600160601b031916602080860191909152600293840b60e890811b60348701529290930b90911b60378401528051601a818503018152603a90930181528251928201929092206000908152929052902090565b835461010090046001600160801b03161561167957609d54604051631e47919f60e11b8152600285810b600483015284900b6024820152600091829182916001600160a01b031690633c8f233e9060440160606040518083038186803b1580156115e657600080fd5b505afa1580156115fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061161e9190614bfb565b9194509250905060008061163389868661253e565b909250905060006116448a8561268d565b90506116518a84846117a2565b60028a0186905560038a018590556116698a82611727565b5050506006870155506117219050565b801561172157609d54604051631e47919f60e11b8152600285810b600483015284900b6024820152600091829182916001600160a01b031690633c8f233e9060440160606040518083038186803b1580156116d357600080fd5b505afa1580156116e7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061170b9190614bfb565b60028a0192909255600389015560068801555050505b50505050565b604080516101008082018352845460ff811615158352046001600160801b0316602082015260018401549181018290526002840154606082015260038401546080820152600484015460a0820152600584015460c0820152600684015460e082015290611795908390614fcc565b8360010181905550505050565b811515806117af57508015155b1561184057604080516101008082018352855460ff811615158352046001600160801b031660208201526001850154918101919091526002840154606082015260038401546080820152600484015460a08201819052600585015460c0830152600685015460e0830152611824908490614fcc565b600485015560c0810151611839908390614fcc565b6005850155505b505050565b60006118518484611cd7565b600080609d60009054906101000a90046001600160a01b03166001600160a01b03166380a0f76c6040518163ffffffff1660e01b815260040160606040518083038186803b1580156118a257600080fd5b505afa1580156118b6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118da9190614d98565b5060b654609954609a546040516325f258dd60e01b81529496509294506000936001600160a01b03909216926325f258dd9261191a929190600401614f87565b602060405180830381600087803b15801561193457600080fd5b505af1158015611948573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061196c9190614df6565b885490915061010090046001600160801b031615611bea576119d96040518060e00160405280600060020b8152602001600081526020016000815260200160006001600160a01b03168152602001600081526020016000815260200160006001600160a01b031681525090565b8760020b8360020b126119ff578660020b8360020b126119f95786611a01565b82611a01565b875b600290810b900b80825289546000918291611a2d91908b9061010090046001600160801b031687612708565b91509150808b60050154611a419190614fcc565b602084015260048b0154611a56908390614fcc565b604084015282518b54611a7a91908c9061010090046001600160801b031687612708565b60058d01549193509150611a8f908290614fcc565b608084015260048b0154611aa4908390614fcc565b60a08401526000611ab48b6127b8565b90506000611ac18b6127b8565b90506000856020015113611af457816001600160a01b0316886001600160a01b031610611aee5781611b15565b87611b15565b806001600160a01b0316886001600160a01b031611611b135780611b15565b875b6001600160a01b031660608601526080850151600012611b5457816001600160a01b0316886001600160a01b031610611b4e5781611b75565b87611b75565b806001600160a01b0316886001600160a01b031611611b735780611b75565b875b6001600160a01b031660c0860152604085015160208601516060870151600092611ba29290918e90612bc2565b90506000611bbe8760a0015188608001518e8a60c00151612bc2565b905080821115611bd957509850611c04975050505050505050565b9950611c0498505050505050505050565b611bfe886004015489600501548786612bc2565b93505050505b949350505050565b603380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b600060405163a9059cbb60e01b81526001600160a01b03841660048201528260248201526000806044836000895af1915050611c9981612bf6565b6117215760405162461bcd60e51b815260206004820152600f60248201526e1514905394d1915497d19052531151608a1b6044820152606401610545565b8060020b8260020b12611d125760405162461bcd60e51b8152602060048201526003602482015262544c5560e81b6044820152606401610545565b62010deb19600283900b1215611d505760405162461bcd60e51b8152602060048201526003602482015262544c4d60e81b6044820152606401610545565b611d5d62010deb19615198565b60020b8160020b131561146b5760405162461bcd60e51b815260206004820152600360248201526254554d60e81b6044820152606401610545565b609a54611da36123aa565b10611df057825460ff16611dca5760405163169b07f760e21b815260040160405180910390fd5b60008360010154121561184057604051630a5f871f60e21b815260040160405180910390fd5b611840838383612375565b6000811315611e1c5760985461146b906001600160a01b0316833084612c3b565b6098546040516370a0823160e01b81526000916001600160a01b0316906370a0823190611e4d903090600401614e0e565b60206040518083038186803b158015611e6557600080fd5b505afa158015611e79573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e9d9190614df6565b905080611ea9836151b2565b1115611f52576000611eba836151b2565b90508115611ee657611ecc828261512c565b609854909150611ee6906001600160a01b03168584611c5e565b609b546040516318399f4d60e31b81526001600160a01b038681166004830152602482018490529091169063c1ccfa6890604401600060405180830381600087803b158015611f3457600080fd5b505af1158015611f48573d6000803e3d6000fd5b5050505050505050565b61184083611f5f846151b2565b6098546001600160a01b03169190611c5e565b600080611f7d6123aa565b9050828110611f8f5760019150611fb5565b6000611f9b828561512c565b905069124bc0ddd92e560000008111611fb357600192505b505b50919050565b600080611fcb8585856001611845565b90508085600101541215611fe25760019150611fe7565b600091505b509392505050565b60007812725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f2182111561202e57604051633492ffd960e01b815260048101839052602401610545565b50670de0b6b3a76400000290565b6000610c318383612cc8565b6120528282611cd7565b60058401541561172157600080600080600088600501541290508015612165576040805160c0810182526001600160a01b038916815260058a0154602082015260009181016120ae6b0816769404766de590afe04e6001615038565b6001600160a01b0390811682526001602083015260028a810b604080850191909152908a900b606090930192909252609d549151638ef10c0360e01b81529293501690638ef10c0390612105908490600401614f2f565b606060405180830381600087803b15801561211f57600080fd5b505af1158015612133573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121579190614bfb565b919650945092506122549050565b6040805160c0810182526001600160a01b038916815260058a0154602082015260009181016121a260016c1fa71f3f5f68a90479ee3f8fec61510c565b6001600160a01b0390811682526001602083015260028a810b604080850191909152908a900b606090930192909252609d549151638ef10c0360e01b81529293501690638ef10c03906121f9908490600401614f2f565b606060405180830381600087803b15801561221357600080fd5b505af1158015612227573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061224b9190614bfb565b91965094509250505b811561226d5761226d612266836151b2565b8990611727565b611f488885856117a2565b604080516101008082018352845460ff811615158352046001600160801b031660208201526001840154918101919091526002830154606082015260038301546080820152600483015460a0820152600583015460c0820152600683015460e08201526000600f83900b61233357600082602001516001600160801b0316116123285760405162461bcd60e51b815260206004820152600260248201526104e560f41b6044820152606401610545565b506020810151612344565b612341826020015184612d8b565b90505b82600f0b6000146117215783546001600160801b03821661010002610100600160881b031990911617845550505050565b60006123848484846000611845565b90508084600101541361172157604051630a53e22f60e41b815260040160405180910390fd5b600061117342611fef565b6000806123c187612e4b565b905060006123ce87612e4b565b905060006123e7836123e260018a8a612ec8565b612f93565b905060006123f58387612f93565b905060006124038284614fcc565b9050670de0b6b3a764000081055b9b9a5050505050505050505050565b60b05460009042908290612434908361512c565b60b6546040516393556dbd60e01b81529192506001600160a01b0316906393556dbd906124679084908690600401614f87565b60206040518083038186803b15801561247f57600080fd5b505afa158015612493573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124b79190614df6565b9250505090565b6124c6612420565b60b1554260b255565b60006124da3061150f565b15905090565b600054610100900460ff166125075760405162461bcd60e51b815260040161054590614ec2565b6105a9613058565b600054610100900460ff166125365760405162461bcd60e51b815260040161054590614ec2565b6105a9613088565b604080516101008082018352855460ff811615158352046001600160801b0316602082015260018501549181019190915260028401546060820181905260038501546080830152600485015460a0830152600585015460c0830152600685015460e0830152600091829182906125b490876150a5565b905060008113156125e2576125db8183602001516001600160801b0316600160801b6130bb565b9350612612565b6126066125ee826151b2565b83602001516001600160801b0316600160801b6130bb565b61260f906151b2565b93505b600082608001518661262491906150a5565b905060008113156126525761264b8184602001516001600160801b0316600160801b6130bb565b9350612682565b61267661265e826151b2565b84602001516001600160801b0316600160801b6130bb565b61267f906151b2565b93505b505050935093915050565b604080516101008082018352845460ff811615158352046001600160801b0316602082018190526001850154928201929092526002840154606082015260038401546080820152600484015460a0820152600584015460c0820152600684015460e08201819052600092611c0491850390600160801b6130bb565b6000808460020b8660020b1415612724575060009050806127af565b600061275c612732886127b8565b61273b886127b8565b8860020b8a60020b1261274e57876131b3565b61275788615172565b6131b3565b9050600061279661276c896127b8565b612775896127b8565b8960020b8b60020b126127905761278b89615172565b6131fa565b886131fa565b90506127a9828287609954609a5461322e565b93509150505b94509492505050565b60008060008360020b126127cf578260020b6127dc565b8260020b6127dc906151b2565b90506127eb62010deb19615198565b60020b8111156128215760405162461bcd60e51b81526020600482015260016024820152601560fa1b6044820152606401610545565b60006001821661283557600160801b612847565b6ffffcb933bd6fad37aa2d162d1a5940015b6001600160881b03169050600282161561287c576080612877826ffff97272373d413259a46990580e213a615086565b901c90505b60048216156128a65760806128a1826ffff2e50f5f656932ef12357cf3c7fdcc615086565b901c90505b60088216156128d05760806128cb826fffe5caca7e10e4e61c3624eaa0941cd0615086565b901c90505b60108216156128fa5760806128f5826fffcb9843d60f6159c9db58835c926644615086565b901c90505b602082161561292457608061291f826fff973b41fa98c081472e6896dfb254c0615086565b901c90505b604082161561294e576080612949826fff2ea16466c96a3843ec78b326b52861615086565b901c90505b6080821615612978576080612973826ffe5dee046a99a2a811c461f1969c3053615086565b901c90505b6101008216156129a357608061299e826ffcbe86c7900a88aedcffc83b479aa3a4615086565b901c90505b6102008216156129ce5760806129c9826ff987a7253ac413176f2b074cf7815e54615086565b901c90505b6104008216156129f95760806129f4826ff3392b0822b70005940c7a398e4b70f3615086565b901c90505b610800821615612a24576080612a1f826fe7159475a2c29b7443b29c7fa6e889d9615086565b901c90505b611000821615612a4f576080612a4a826fd097f3bdfd2022b8845ad8f792aa5825615086565b901c90505b612000821615612a7a576080612a75826fa9f746462d870fdf8a65dc1f90e061e5615086565b901c90505b614000821615612aa5576080612aa0826f70d869a156d2a1b890bb3df62baf32f7615086565b901c90505b618000821615612ad0576080612acb826f31be135f97d08fd981231505542fcfa6615086565b901c90505b62010000821615612afc576080612af7826f09aa508b5b7a84e1c677de54f3e99bc9615086565b901c90505b62020000821615612b27576080612b22826e5d6af8dedb81196699c329225ee604615086565b901c90505b62040000821615612b51576080612b4c826d2216e584f5fa1ea926041bedfe98615086565b901c90505b62080000821615612b79576080612b74826b048a170391f7dc42444e8fa2615086565b901c90505b60008460020b1315612b9457612b9181600019615072565b90505b612ba2600160201b8261515e565b15612bae576001612bb1565b60005b611c049060ff16602083901c61505a565b6000612bcf8585856132f9565b90506000612bdf86868686613479565b905080821015612bed578091505b50949350505050565b60003d82612c0857806000803e806000fd5b8060208114612c20578015612c315760009250611fb3565b816000803e60005115159250611fb3565b5060019392505050565b60006040516323b872dd60e01b81526001600160a01b03851660048201526001600160a01b038416602482015282604482015260008060648360008a5af1915050612c8581612bf6565b6114225760405162461bcd60e51b81526020600482015260146024820152731514905394d1915497d19493d357d1905253115160621b6044820152606401610545565b60008080600019848609848602925082811083820303915050670de0b6b3a76400008110612d0c5760405163698d9a0160e11b815260048101829052602401610545565b600080670de0b6b3a76400008688099150506706f05b59d3b1ffff811182612d465780670de0b6b3a7640000850401945050505050612d85565b620400008285030493909111909103600160ee1b02919091177faccb18165bd6fe31ae1cf318dc5b51eee0e1ba569b88cd74c1773b91fac10669020190505b92915050565b60008082600f0b1215612df8576001600160801b038316612dab83615172565b612db590856150e4565b9150816001600160801b031610612df35760405162461bcd60e51b81526020600482015260026024820152614c5360f01b6044820152606401610545565b612d85565b6001600160801b038316612e0c838561500d565b9150816001600160801b03161015612d855760405162461bcd60e51b81526020600482015260026024820152614c4160f01b6044820152606401610545565b60007809392ee8e921d5d073aff322e62439fcf32d7f344649470f8f19821215612e8b5760405163e608e18b60e01b815260048101839052602401610545565b7809392ee8e921d5d073aff322e62439fcf32d7f344649470f9082131561202e576040516371f72a3160e01b815260048101839052602401610545565b6000828211612ee95760405162461bcd60e51b815260040161054590614ea4565b82612ef26123aa565b1015612f285760405162461bcd60e51b8152602060048201526005602482015264422e543c5360d81b6044820152606401610545565b60008480612f3d575082612f3a6123aa565b10155b15612f5357612f4c848461512c565b9050612f69565b83612f5c6123aa565b612f66919061512c565b90505b6000612f7482613631565b9050612f898168056bc75e2d63100000613644565b9695505050505050565b6000600160ff1b831480612faa5750600160ff1b82145b15612fc857604051630d01a11b60e21b815260040160405180910390fd5b60008060008512612fd95784612fde565b846000035b915060008412612fee5783612ff3565b836000035b905060006130018383612cc8565b90506001600160ff1b0381111561302e5760405163bf79e8d960e01b815260048101829052602401610545565b600019808713908613808218600114613047578261304c565b826000035b98975050505050505050565b600054610100900460ff1661307f5760405162461bcd60e51b815260040161054590614ec2565b6105a933611c0c565b600054610100900460ff166130af5760405162461bcd60e51b815260040161054590614ec2565b6065805460ff19169055565b60008080600019858709858702925082811083820303915050806000141561312b57600084116131205760405162461bcd60e51b815260206004820152601060248201526f4469766973696f6e206279207a65726f60801b6044820152606401610545565b508290049050610c31565b80841161314a5760405162461bcd60e51b815260040161054590614f0d565b60008486880960026001871981018816978890046003810283188082028403028082028403028082028403028082028403028082028403029081029092039091026000889003889004909101858311909403939093029303949094049190911702949350505050565b60008082600f0b126131d9576131d46131cf8585856001613659565b61376e565b611c04565b6131f16131cf85856131ea86615172565b6000613659565b611c04906151b2565b60008082600f0b12613216576131d46131cf85858560016137be565b6131f16131cf858561322786615172565b60006137be565b6000808613158015613241575060008512155b80613259575060008612158015613259575060008513155b8061326b57508515801561326b575084155b613288576040516301161e4160e01b815260040160405180910390fd5b600061329387612e4b565b905060006132a087612e4b565b90508484116132c15760405162461bcd60e51b815260040161054590614ea4565b60006132d08383898989613837565b905060006132e08483898961389f565b670de0b6b3a764000090059a9950505050505050505050565b600080841215801561330c575060008312155b1561331957506000610c31565b600061332485612e4b565b9050600061333185612e4b565b90506000609954609a54613345919061512c565b9050600061335d846123e26001609954609a54612ec8565b9050600061342d846123e285609a546133746123aa565b60008e128d61338161117f565b6040805161024081018252609e548152609f54602082015260a080549282019290925260a154606082015260a254608082015260a3549181019190915260a45460c082015260a55460e082015260a65461010082015260a75461012082015260a85461014082015260a95461016082015260aa5461018082015260ab546101a082015260ac546101c082015260ad546101e082015260ae5461020082015260af546102208201526138f7565b9050600061343b8284614fcc565b9050600081121561346757613460613452826151b2565b670de0b6b3a7640000900490565b965061346c565b600096505b5050505050509392505050565b60008361348857506000611c04565b6000806000808713156134ec5760008813156134aa5760009350505050611c04565b85156134bd57505060a65460aa546134c6565b505060a85460ac545b6134e587868484609a546134d86123aa565b60a55460ae54600161398e565b925061353b565b85156134ff57505060a75460ab54613508565b505060a95460ad545b61352f613514886151b2565b868484609a546135226123aa565b60a55460ae54600061398e565b613538906151b2565b92505b6000613546886151b2565b60b654609954609a546040516325f258dd60e01b81529394506000936135e693899387936001600160a01b03909216926325f258dd926135899291600401614f87565b602060405180830381600087803b1580156135a357600080fd5b505af11580156135b7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906135db9190614df6565b609954609a5461322e565b905060006135f4838b614fcc565b90506000613602838d614fcc565b905061360f81838c6132f9565b60af549098508810156136225760af5497505b50505050505050949350505050565b6000612d85826a1a1601fc4ea7109e0000005b6000610c3183670de0b6b3a764000084613b3b565b6000836001600160a01b0316856001600160a01b03161115613679579293925b600160601b600160e01b03606084901b166000613696878761510c565b6001600160a01b031690506000876001600160a01b0316116136f35760405162461bcd60e51b8152602060048201526016602482015275073717274207072696365206d757374206265203e20360541b6044820152606401610545565b8361373757866001600160a01b03166137168383896001600160a01b03166130bb565b8161373157634e487b7160e01b600052601260045260246000fd5b04613763565b61376361374e8383896001600160a01b0316613ba8565b886001600160a01b0316808204910615150190565b979650505050505050565b6000600160ff1b82106137ba5760405162461bcd60e51b815260206004820152601460248201527337bb32b9333637bb9034b7103a37a4b73a191a9b60611b6044820152606401610545565b5090565b6000836001600160a01b0316856001600160a01b031611156137de579293925b8161380b57613806836001600160801b03168686036001600160a01b0316600160601b6130bb565b61382e565b61382e836001600160801b03168686036001600160a01b0316600160601b613ba8565b95945050505050565b600061385d60405180606001604052806000815260200160008152602001600081525090565b61386d876123e260008787612ec8565b81526138798686612f93565b60208201819052815161388c9190614fcc565b6040909101819052905095945050505050565b60008282116138c05760405162461bcd60e51b815260040161054590614ea4565b60006138d2866123e260018787612ec8565b905060006138e086836150a5565b9050613763816138f260018888612ec8565b613c09565b60008061390389613631565b9050851561394a57841561392f57613928613922898987600188613ccf565b8261203c565b9150613982565b6139286139226139438a8a88600189613ccf565b855161203c565b841561396157613928613922898987600088613ccf565b61397f6139226139758a8a88600089613ccf565b856020015161203c565b91505b50979650505050505050565b60006139df6040518061012001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b613a006139ec6001611fef565b8b6001600160a01b0316600160601b6130bb565b8152613a20613a0f6001611fef565b8251613a1b908061203c565b613644565b60208201819052613a31908a61203c565b60408201819052881115613a4757604081018890525b613a5a613a54878961512c565b86613644565b6060820152613a75613a6b856151b2565b8260600151612f93565b60808201819052613a8590613efa565b613a8f6001612e4b565b613a9991906150a5565b60a082018190526040820151613aae9161203c565b60c08201528215613af3578060c0015181602001511115613ae7578060c001518160200151613add919061512c565b60e0820152613b0d565b600060e0820152613b0d565b8060c001518160200151613b07919061505a565b60e08201525b613b23613b198c611fef565b8260e0015161203c565b6101008201819052670de0b6b3a76400009004612411565b600080806000198587098587029250828110838203039150508060001415613b8457838281613b7a57634e487b7160e01b600052601260045260246000fd5b0492505050610c31565b83811061314a578084604051631dcf306360e21b8152600401610545929190614f87565b6000613bb58484846130bb565b905060008280613bd557634e487b7160e01b600052601260045260246000fd5b8486091115610c31576000198110613bff5760405162461bcd60e51b815260040161054590614f0d565b8061382e81615143565b6000600160ff1b831480613c205750600160ff1b82145b15613c3e5760405163b3c754a360e01b815260040160405180910390fd5b60008060008512613c4f5784613c54565b846000035b915060008412613c645783613c69565b836000035b90506000613c8083670de0b6b3a764000084613b3b565b90506001600160ff1b03811115613cad57604051637cb4bef560e01b815260048101829052602401610545565b600019808713908613808218600114613cc6578261304c565b61304c836151b2565b6000613d206040518061012001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6000613d3484608001516123e26004612e4b565b90506000613d4a85606001516123e26004612e4b565b9050613d57898987613f6a565b808452613d646001612e4b565b613d6e91906150a5565b60208401526040850151613d83908290613c09565b836040018181525050613da7613da186604001518560200151612f93565b83613c09565b60608401528251613dc390613dbd908490612f93565b88612f93565b608084015260408501516020840151613ddc9190612f93565b60a084018190526080840151613df191613c09565b60c08401526040830151613e2a90613e16613e0c6002612e4b565b8660c00151612f93565b613e209190614fcc565b6123e26002612e4b565b60e08401528515613e5557613e4a8560a001516123e28560e0015161408a565b610100840152613e71565b613e6a8560c001516123e28560e0015161408a565b6101008401525b600086613ea957613ea484606001518561010001518660c001518760400151613e9a9190614fcc565b6123e291906150a5565b613ed5565b613ed584606001518561010001518660c001518760400151613ecb9190614fcc565b6123e29190614fcc565b90506000811215613ee95760009450613eed565b8094505b5050505095945050505050565b600068023f2fa8f6da5b9d3119821215613f1657506000919050565b680736ea4425c11ac6318212613f42576040516399bb754160e01b815260048101839052602401610545565b6714057b7ef767814f8202610c31670de0b6b3a76400006706f05b59d3b20000830105614100565b6000808411613fba5760405162461bcd60e51b815260206004820152601c60248201527b07465726d456e6454696d657374616d70206d757374206265203e20360241b6044820152606401610545565b8383111561400a5760405162461bcd60e51b815260206004820152601d60248201527f656e6454696d65206d757374206265203e2063757272656e7454696d650000006044820152606401610545565b60808201516140505760405162461bcd60e51b81526020600482015260126024820152711c185c985b595d195c9cc81b9bdd081cd95d60721b6044820152606401610545565b608082015160e08301516000614069613da187896150a5565b9050600061407f614079856151b2565b83612f93565b905061304c81613efa565b6000808212156140b05760405163608c83ff60e11b815260048101839052602401610545565b7809392ee8e921d5d073aff322e62439fcf32d7f344649470f908213156140ed57604051632c482c3960e01b815260048101839052602401610545565b612d85670de0b6b3a764000083026141a5565b6000808212156141615768033dd1780914b971141982121561412457506000919050565b61413082600003614100565b6a0c097ce7bc90715b34b9f160241b8161415a57634e487b7160e01b600052601260045260246000fd5b0592915050565b680a688906bd8b000000821261418d5760405163e69458f960e01b815260048101839052602401610545565b670de0b6b3a7640000604083901b04610c3181614380565b6000816141b457506000919050565b50600181600160801b81106141ce5760409190911b9060801c5b600160401b81106141e45760209190911b9060401c5b600160201b81106141fa5760109190911b9060201c5b62010000811061420f5760089190911b9060101c5b61010081106142235760049190911b9060081c5b601081106142365760029190911b9060041c5b6008811061424657600182901b91505b600182848161426557634e487b7160e01b600052601260045260246000fd5b048301901c9150600182848161428b57634e487b7160e01b600052601260045260246000fd5b048301901c915060018284816142b157634e487b7160e01b600052601260045260246000fd5b048301901c915060018284816142d757634e487b7160e01b600052601260045260246000fd5b048301901c915060018284816142fd57634e487b7160e01b600052601260045260246000fd5b048301901c9150600182848161432357634e487b7160e01b600052601260045260246000fd5b048301901c9150600182848161434957634e487b7160e01b600052601260045260246000fd5b048301901c9150600082848161436f57634e487b7160e01b600052601260045260246000fd5b04905080831015610c315782611c04565b600160bf1b6001603f1b8216156143a05768016a09e667f3bcc9090260401c5b6001603e1b8216156143bb576801306fe0a31b7152df0260401c5b6001603d1b8216156143d6576801172b83c7d517adce0260401c5b6001603c1b8216156143f15768010b5586cf9890f62a0260401c5b6001603b1b82161561440c576801059b0d31585743ae0260401c5b6001603a1b82161561442757680102c9a3e778060ee70260401c5b600160391b8216156144425768010163da9fb33356d80260401c5b600160381b82161561445d57680100b1afa5abcbed610260401c5b600160371b8216156144785768010058c86da1c09ea20260401c5b600160361b821615614493576801002c605e2e8cec500260401c5b600160351b8216156144ae57680100162f3904051fa10260401c5b600160341b8216156144c9576801000b175effdc76ba0260401c5b600160331b8216156144e457680100058ba01fb9f96d0260401c5b600160321b8216156144ff5768010002c5cc37da94920260401c5b600160311b82161561451a576801000162e525ee05470260401c5b600160301b8216156145355768010000b17255775c040260401c5b6001602f1b821615614550576801000058b91b5bc9ae0260401c5b6001602e1b82161561456b57680100002c5c89d5ec6d0260401c5b6001602d1b8216156145865768010000162e43f4f8310260401c5b6001602c1b8216156145a157680100000b1721bcfc9a0260401c5b6001602b1b8216156145bc5768010000058b90cf1e6e0260401c5b6001602a1b8216156145d7576801000002c5c863b73f0260401c5b600160291b8216156145f257680100000162e430e5a20260401c5b600160281b82161561460d576801000000b1721835510260401c5b600160271b82161561462857680100000058b90c0b490260401c5b600160261b8216156146435768010000002c5c8601cc0260401c5b600160251b82161561465e576801000000162e42fff00260401c5b600160241b8216156146795768010000000b17217fbb0260401c5b600160231b821615614694576801000000058b90bfce0260401c5b600160221b8216156146af57680100000002c5c85fe30260401c5b600160211b8216156146ca5768010000000162e42ff10260401c5b600160201b8216156146e557680100000000b17217f80260401c5b63800000008216156147005768010000000058b90bfc0260401c5b634000000082161561471b576801000000002c5c85fe0260401c5b632000000082161561473657680100000000162e42ff0260401c5b6310000000821615614751576801000000000b17217f0260401c5b630800000082161561476c57680100000000058b90c00260401c5b63040000008216156147875768010000000002c5c8600260401c5b63020000008216156147a2576801000000000162e4300260401c5b63010000008216156147bd5768010000000000b172180260401c5b628000008216156147d7576801000000000058b90c0260401c5b624000008216156147f157680100000000002c5c860260401c5b6220000082161561480b5768010000000000162e430260401c5b6210000082161561482557680100000000000b17210260401c5b6208000082161561483f5768010000000000058b910260401c5b62040000821615614859576801000000000002c5c80260401c5b6202000082161561487357680100000000000162e40260401c5b6201000082161561488c5761b172600160401b010260401c5b6180008216156148a4576158b9600160401b010260401c5b6140008216156148bc57612c5d600160401b010260401c5b6120008216156148d45761162e600160401b010260401c5b6110008216156148ec57610b17600160401b010260401c5b6108008216156149045761058c600160401b010260401c5b61040082161561491c576102c6600160401b010260401c5b61020082161561493457610163600160401b010260401c5b61010082161561494b5760b1600160401b010260401c5b6080821615614961576059600160401b010260401c5b604082161561497757602c600160401b010260401c5b602082161561498d576016600160401b010260401c5b60108216156149a357600b600160401b010260401c5b60088216156149b9576006600160401b010260401c5b60048216156149cf576003600160401b010260401c5b60028216156149e5576001600160401b010260401c5b60018216156149fb576001600160401b010260401c5b670de0b6b3a76400000260409190911c60bf031c90565b600060208284031215614a23578081fd5b8135610c31816151f8565b60008060008060808587031215614a43578283fd5b8435614a4e816151f8565b93506020850135614a5e816151f8565b93969395505050506040820135916060013590565b600080600060608486031215614a87578283fd5b8335614a92816151f8565b92506020840135614aa28161520d565b91506040840135614ab28161520d565b809150509250925092565b60008060008060808587031215614ad2578384fd5b8435614add816151f8565b93506020850135614aed8161520d565b92506040850135614afd8161520d565b9396929550929360600135925050565b60008060008060008060c08789031215614b25578182fd5b8635614b30816151f8565b95506020870135614b408161520d565b94506040870135614b508161520d565b959894975094956060810135955060808101359460a0909101359350915050565b60008060408385031215614b83578081fd5b8235614b8e816151f8565b946020939093013593505050565b600060208284031215614bad578081fd5b81518015158114610c31578182fd5b600080600060608486031215614bd0578081fd5b8335614bdb8161520d565b92506020840135614beb8161520d565b91506040840135614ab2816151f8565b600080600060608486031215614c0f578081fd5b8351925060208401519150604084015190509250925092565b60006102408284031215614c3a578081fd5b614c42614f95565b823581526020808401359082015260408084013590820152606080840135908201526080808401359082015260a0808401359082015260c0808401359082015260e08084013590820152610100808401359082015261012080840135908201526101408084013590820152610160808401359082015261018080840135908201526101a080840135908201526101c080840135908201526101e080840135908201526102008084013590820152610220928301359281019290925250919050565b600060808284031215614d14578081fd5b604051608081016001600160401b0381118282101715614d4257634e487b7160e01b83526041600452602483fd5b6040528235614d50816151f8565b81526020830135614d608161520d565b60208201526040830135614d738161520d565b60408201526060830135600f81900b8114614d8c578283fd5b60608201529392505050565b600080600060608486031215614dac578081fd5b8351614db7816151f8565b6020850151909350614dc88161520d565b604085015190925060ff81168114614ab2578182fd5b600060208284031215614def578081fd5b5035919050565b600060208284031215614e07578081fd5b5051919050565b6001600160a01b0391909116815260200190565b6001600160a01b0392831681529116602082015260400190565b6001600160a01b03949094168452600292830b6020850152910b60408301526001600160801b0316606082015260800190565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b602080825260049082015263453c3d5360e01b604082015260600190565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b6020808252600890820152676f766572666c6f7760c01b604082015260600190565b600060c08201905060018060a01b038084511683526020840151602084015280604085015116604084015250606083015115156060830152608083015160020b608083015260a083015160020b60a083015292915050565b918252602082015260400190565b60405161024081016001600160401b0381118282101715614fc657634e487b7160e01b600052604160045260246000fd5b60405290565b600080821280156001600160ff1b0384900385131615614fee57614fee6151cc565b600160ff1b8390038412811615615007576150076151cc565b50500190565b60006001600160801b0382811684821680830382111561502f5761502f6151cc565b01949350505050565b60006001600160a01b0382811684821680830382111561502f5761502f6151cc565b6000821982111561506d5761506d6151cc565b500190565b600082615081576150816151e2565b500490565b60008160001904831182151516156150a0576150a06151cc565b500290565b60008083128015600160ff1b8501841216156150c3576150c36151cc565b6001600160ff1b03840183138116156150de576150de6151cc565b50500390565b60006001600160801b0383811690831681811015615104576151046151cc565b039392505050565b60006001600160a01b0383811690831681811015615104576151046151cc565b60008282101561513e5761513e6151cc565b500390565b6000600019821415615157576151576151cc565b5060010190565b60008261516d5761516d6151e2565b500690565b6000600f82900b60016001607f1b0319811415615191576151916151cc565b9003919050565b60008160020b627fffff19811415615191576151916151cc565b6000600160ff1b8214156151c8576151c86151cc565b0390565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fd5b6001600160a01b038116811461150c57600080fd5b8060020b811461150c57600080fdfea2646970667358221220338cacc19a358a4559f503d74ecca14a2c2d8259f96fc66f1c16a10dd8b604f964736f6c63430008040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101755760003560e01c806322d23b211461017a5780632495a599146101a357806329c9a410146101b6578063534d3375146101cb5780635c975abb146101de578063633dd145146101f4578063652c30b71461020b578063715018a614610214578063754e2a8f1461021c5780637717797f1461022f5780637a55433c146102425780638da5cb5b146102555780639209e9ba1461025d57806393edb454146102d757806398f4b1b2146102e0578063b5c22d49146102f3578063b623f51914610306578063ba795d321461030f578063bfb5607d14610322578063c326189214610335578063c45a015514610348578063c7607a9c1461035b578063d1b565dc1461036e578063d50d881114610381578063e087caf114610389578063e098372c14610392578063e3f08374146103a5578063e9e441bb146103ad578063eb990c59146103c0578063efcfc3f9146103d3578063f2fde38b146103e6575b600080fd5b609b5461018d906001600160a01b031681565b60405161019a9190614e0e565b60405180910390f35b60985461018d906001600160a01b031681565b6101c96101c4366004614b0d565b6103f9565b005b6101c96101d9366004614a12565b610516565b60655460ff16604051901515815260200161019a565b6101fd60b05481565b60405190815260200161019a565b6101fd60995481565b6101c9610570565b6101c961022a366004614b71565b6105ab565b6101c961023d366004614abd565b6106a4565b6101c9610250366004614bbc565b610937565b61018d610b5b565b61027061026b366004614a73565b610b6a565b60405161019a91908151151581526020808301516001600160801b03169082015260408083015190820152606080830151908201526080808301519082015260a0808301519082015260c0808301519082015260e091820151918101919091526101000190565b6101fd609a5481565b60b65461018d906001600160a01b031681565b6101c9610301366004614c28565b610c38565b6101fd60b35481565b6101c961031d366004614dde565b610cff565b6101c9610330366004614d03565b610d68565b6101c9610343366004614dde565b610e50565b60b55461018d906001600160a01b031681565b6101c9610369366004614a12565b610eb9565b6101c961037c366004614bbc565b610f0a565b6101fd611152565b6101fd60975481565b609d5461018d906001600160a01b031681565b6101fd61117f565b6101c96103bb366004614dde565b6111a0565b6101c96103ce366004614a2e565b611209565b6101c96103e1366004614b71565b611429565b6101c96103f4366004614a12565b61146f565b609d546001600160a01b0316331461042457604051633dec6c6960e11b815260040160405180910390fd5b6000610433609c88888861151e565b9050610442818787600061157d565b811561045b5761045b610454836151b2565b8290611727565b6104668185856117a2565b60006104758288886000611845565b9050816001015481131561049c5760405163d9ce82ab60e01b815260040160405180910390fd5b600482015460058301546001840154604080516001600160a01b038d16815260028c810b60208301528b900b818301526060810194909452608084019290925260a0830152517fa6a26c171f0478962e0cfe711f994e7bb063211f49fe9387ff5d9f8c42b5abc99181900360c00190a15050505050505050565b3361051f610b5b565b6001600160a01b03161461054e5760405162461bcd60e51b815260040161054590614e6f565b60405180910390fd5b609b80546001600160a01b0319166001600160a01b0392909216919091179055565b33610579610b5b565b6001600160a01b03161461059f5760405162461bcd60e51b815260040161054590614e6f565b6105a96000611c0c565b565b336105b4610b5b565b6001600160a01b0316146105da5760405162461bcd60e51b815260040161054590614e6f565b801561065657609d54604051630867377160e41b8152600481018390526001600160a01b0390911690638673771090602401600060405180830381600087803b15801561062657600080fd5b505af115801561063a573d6000803e3d6000fd5b505060985461065692506001600160a01b031690508383611c5e565b604080513381526001600160a01b03841660208201529081018290527f4a18654a5039b989ca382f52bbf82bcdde698ffc4c11fe6c59652a4d1fe70f48906060015b60405180910390a15050565b80806106c357604051638acc6d7f60e01b815260040160405180910390fd5b6106cd8484611cd7565b60006106dc609c87878761151e565b90506106eb818686600061157d565b60008382600101546106fd9190614fcc565b121561074b5760405162461bcd60e51b815260206004820152601d60248201527f63616e2774207769746864726177206d6f7265207468616e20686176650000006044820152606401610545565b600083121561082e576001600160a01b03861633148015906107ec575060b5546040516351c4bc1f60e11b81526001600160a01b039091169063a389783e9061079a9089903390600401614e22565b60206040518083038186803b1580156107b257600080fd5b505afa1580156107c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107ea9190614b9c565b155b1561080a57604051637da45ce760e01b815260040160405180910390fd5b6108148184611727565b61081f818686611d98565b6108298684611dfb565b6108d6565b6108388184611727565b60b5546040516351c4bc1f60e11b81526000916001600160a01b03169063a389783e9061086b908a903390600401614e22565b60206040518083038186803b15801561088357600080fd5b505afa158015610897573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108bb9190614b9c565b156108c75750856108ca565b50335b6108d48185611dfb565b505b6001810154604080516001600160a01b0389168152600288810b602083015287900b818301526060810192909252517f9ed2335b5963496e2d16b7c4dbb12cd4000c2603f17e4df78f3c1973ce12a62a9181900360800190a1505050505050565b610942609a54611f72565b156109895760405162461bcd60e51b8152602060048201526017602482015276636c6f7365546f4f724265796f6e644d6174757269747960481b6044820152606401610545565b6109938383611cd7565b60006109a2609c83868661151e565b90506109b1818585600061157d565b60006109be828686611fbb565b9050806109de5760405163bf87c7d560e01b815260040160405180910390fd5b60006109f86109f08460010154611fef565b60975461203c565b9050670de0b6b3a76400008104610a18610a11826151b2565b8590611727565b835461010090046001600160801b031615610aa557609d548454604051631f2f089360e01b81526001600160a01b0390921691631f2f089391610a729189918c918c9161010090046001600160801b031690600401614e3c565b600060405180830381600087803b158015610a8c57600080fd5b505af1158015610aa0573d6000803e3d6000fd5b505050505b610ab184868989612048565b609854610ac8906001600160a01b03163383611c5e565b6004840154600585015460018601548654604080516001600160a01b038b16815260028d810b60208301528c900b918101919091526060810194909452608084019290925260a083015261010090046001600160801b031660c08201527f54e1aa9dab65a1673f75c6910ea071845b62a5cd1fa6a2bb09348ec2d00b14169060e00160405180910390a150505050505050565b6033546001600160a01b031690565b610bbd60405180610100016040528060001515815260200160006001600160801b031681526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b610bca609c85858561151e565b604080516101008082018352835460ff811615158352046001600160801b031660208201526001830154918101919091526002820154606082015260038201546080820152600482015460a0820152600582015460c082015260069091015460e082015290505b9392505050565b33610c41610b5b565b6001600160a01b031614610c675760405162461bcd60e51b815260040161054590614e6f565b8051609e556020810151609f55604081015160a0908155606082015160a155608082015160a25581015160a35560c081015160a45560e081015160a55561010081015160a65561012081015160a75561014081015160a85561016081015160a95561018081015160aa556101a081015160ab556101c081015160ac556101e081015160ad5561020081015160ae55610220015160af55565b33610d08610b5b565b6001600160a01b031614610d2e5760405162461bcd60e51b815260040161054590614e6f565b60b08054908290556040517f4006ccfc8bf8f1556fc00b810abde999309f22813206397ad6d10430152817ed906106989083908590614f87565b609d546001600160a01b03163314610d9357604051633dec6c6960e11b815260040160405180910390fd5b805160208201516040830151600092610dae92609c9261151e565b9050610dc58183602001518460400151600161157d565b6060820151610dd5908290612278565b60008260600151600f0b1315610df857610df88183602001518460400151612375565b7f3eabc3706d08c6a8e3a01e0c047428e62f14c7c20a7fb49b2492fe8ac59f8bcd8260000151836020015184604001518460000160019054906101000a90046001600160801b03166040516106989493929190614e3c565b33610e59610b5b565b6001600160a01b031614610e7f5760405162461bcd60e51b815260040161054590614e6f565b60b38054908290556040517f4918c9706535b0901b483e33d83971ada066b087344ed55e16428d25acdb6e11906106989083908590614f87565b33610ec2610b5b565b6001600160a01b031614610ee85760405162461bcd60e51b815260040161054590614e6f565b609d80546001600160a01b0319166001600160a01b0392909216919091179055565b60655460ff1615610f505760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b6044820152606401610545565b610f586123aa565b609a541115610f7a576040516301730b8160e11b815260040160405180910390fd5b610f848383611cd7565b6000610f93609c83868661151e565b805490915060ff1615610fda5760405162461bcd60e51b815260206004820152600f60248201526e185b1c9958591e481cd95d1d1b1959608a1b6044820152606401610545565b610fe7818585600061157d565b6004808201546005830154609954609a5460b6546040516325f258dd60e01b815260009661108896959493926001600160a01b0316916325f258dd91611031918691869101614f87565b602060405180830381600087803b15801561104b57600080fd5b505af115801561105f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110839190614df6565b6123b5565b90506110b1826004015461109b906151b2565b83600501546110a9906151b2565b8491906117a2565b6110bb8282611727565b6110cc82805460ff19166001179055565b6004820154600583015460018401548454604080516001600160a01b038916815260028b810b60208301528a900b818301526060810195909552608085019390935260a084019190915260ff16151560c0830152517ff8509b713e5189b4a0db0a68c687471fa8aeae7a70dbb0981f9e390e400631709181900360e00190a15050505050565b600060b35442611162919061512c565b60b254101561117857611173612420565b905090565b5060b15490565b600060b3544261118f919061512c565b60b2541015611178576111786124be565b336111a9610b5b565b6001600160a01b0316146111cf5760405162461bcd60e51b815260040161054590614e6f565b60978054908290556040517fb3eb2e4cbd291aa9b5b858b0d00e57a006f03b5a24ce306afc163d07ae1fc53e906106989083908590614f87565b600054610100900460ff166112245760005460ff161561122c565b61122c6124cf565b61128f5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608401610545565b600054610100900460ff161580156112b1576000805461ffff19166101011790555b6001600160a01b0385166112f85760405162461bcd60e51b815260206004820152600e60248201526d1555081b5d5cdd081899481cd95d60921b6044820152606401610545565b6001600160a01b03841661133f5760405162461bcd60e51b815260206004820152600e60248201526d1493c81b5d5cdd081899481cd95d60921b6044820152606401610545565b8261137d5760405162461bcd60e51b815260206004820152600e60248201526d1514c81b5d5cdd081899481cd95d60921b6044820152606401610545565b816113bb5760405162461bcd60e51b815260206004820152600e60248201526d1511481b5d5cdd081899481cd95d60921b6044820152606401610545565b609880546001600160a01b038088166001600160a01b0319928316179092556099859055609a84905560b680549287169282169290921790915560b58054909116331790556114086124e0565b61141061250f565b8015611422576000805461ff00191690555b5050505050565b609b546001600160a01b0316331461145457604051635d8a367560e01b815260040160405180910390fd5b60985461146b906001600160a01b03168383611c5e565b5050565b33611478610b5b565b6001600160a01b03161461149e5760405162461bcd60e51b815260040161054590614e6f565b6001600160a01b0381166115035760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610545565b61150c81611c0c565b50565b6001600160a01b03163b151590565b6040805160609490941b6001600160601b031916602080860191909152600293840b60e890811b60348701529290930b90911b60378401528051601a818503018152603a90930181528251928201929092206000908152929052902090565b835461010090046001600160801b03161561167957609d54604051631e47919f60e11b8152600285810b600483015284900b6024820152600091829182916001600160a01b031690633c8f233e9060440160606040518083038186803b1580156115e657600080fd5b505afa1580156115fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061161e9190614bfb565b9194509250905060008061163389868661253e565b909250905060006116448a8561268d565b90506116518a84846117a2565b60028a0186905560038a018590556116698a82611727565b5050506006870155506117219050565b801561172157609d54604051631e47919f60e11b8152600285810b600483015284900b6024820152600091829182916001600160a01b031690633c8f233e9060440160606040518083038186803b1580156116d357600080fd5b505afa1580156116e7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061170b9190614bfb565b60028a0192909255600389015560068801555050505b50505050565b604080516101008082018352845460ff811615158352046001600160801b0316602082015260018401549181018290526002840154606082015260038401546080820152600484015460a0820152600584015460c0820152600684015460e082015290611795908390614fcc565b8360010181905550505050565b811515806117af57508015155b1561184057604080516101008082018352855460ff811615158352046001600160801b031660208201526001850154918101919091526002840154606082015260038401546080820152600484015460a08201819052600585015460c0830152600685015460e0830152611824908490614fcc565b600485015560c0810151611839908390614fcc565b6005850155505b505050565b60006118518484611cd7565b600080609d60009054906101000a90046001600160a01b03166001600160a01b03166380a0f76c6040518163ffffffff1660e01b815260040160606040518083038186803b1580156118a257600080fd5b505afa1580156118b6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118da9190614d98565b5060b654609954609a546040516325f258dd60e01b81529496509294506000936001600160a01b03909216926325f258dd9261191a929190600401614f87565b602060405180830381600087803b15801561193457600080fd5b505af1158015611948573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061196c9190614df6565b885490915061010090046001600160801b031615611bea576119d96040518060e00160405280600060020b8152602001600081526020016000815260200160006001600160a01b03168152602001600081526020016000815260200160006001600160a01b031681525090565b8760020b8360020b126119ff578660020b8360020b126119f95786611a01565b82611a01565b875b600290810b900b80825289546000918291611a2d91908b9061010090046001600160801b031687612708565b91509150808b60050154611a419190614fcc565b602084015260048b0154611a56908390614fcc565b604084015282518b54611a7a91908c9061010090046001600160801b031687612708565b60058d01549193509150611a8f908290614fcc565b608084015260048b0154611aa4908390614fcc565b60a08401526000611ab48b6127b8565b90506000611ac18b6127b8565b90506000856020015113611af457816001600160a01b0316886001600160a01b031610611aee5781611b15565b87611b15565b806001600160a01b0316886001600160a01b031611611b135780611b15565b875b6001600160a01b031660608601526080850151600012611b5457816001600160a01b0316886001600160a01b031610611b4e5781611b75565b87611b75565b806001600160a01b0316886001600160a01b031611611b735780611b75565b875b6001600160a01b031660c0860152604085015160208601516060870151600092611ba29290918e90612bc2565b90506000611bbe8760a0015188608001518e8a60c00151612bc2565b905080821115611bd957509850611c04975050505050505050565b9950611c0498505050505050505050565b611bfe886004015489600501548786612bc2565b93505050505b949350505050565b603380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b600060405163a9059cbb60e01b81526001600160a01b03841660048201528260248201526000806044836000895af1915050611c9981612bf6565b6117215760405162461bcd60e51b815260206004820152600f60248201526e1514905394d1915497d19052531151608a1b6044820152606401610545565b8060020b8260020b12611d125760405162461bcd60e51b8152602060048201526003602482015262544c5560e81b6044820152606401610545565b62010deb19600283900b1215611d505760405162461bcd60e51b8152602060048201526003602482015262544c4d60e81b6044820152606401610545565b611d5d62010deb19615198565b60020b8160020b131561146b5760405162461bcd60e51b815260206004820152600360248201526254554d60e81b6044820152606401610545565b609a54611da36123aa565b10611df057825460ff16611dca5760405163169b07f760e21b815260040160405180910390fd5b60008360010154121561184057604051630a5f871f60e21b815260040160405180910390fd5b611840838383612375565b6000811315611e1c5760985461146b906001600160a01b0316833084612c3b565b6098546040516370a0823160e01b81526000916001600160a01b0316906370a0823190611e4d903090600401614e0e565b60206040518083038186803b158015611e6557600080fd5b505afa158015611e79573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e9d9190614df6565b905080611ea9836151b2565b1115611f52576000611eba836151b2565b90508115611ee657611ecc828261512c565b609854909150611ee6906001600160a01b03168584611c5e565b609b546040516318399f4d60e31b81526001600160a01b038681166004830152602482018490529091169063c1ccfa6890604401600060405180830381600087803b158015611f3457600080fd5b505af1158015611f48573d6000803e3d6000fd5b5050505050505050565b61184083611f5f846151b2565b6098546001600160a01b03169190611c5e565b600080611f7d6123aa565b9050828110611f8f5760019150611fb5565b6000611f9b828561512c565b905069124bc0ddd92e560000008111611fb357600192505b505b50919050565b600080611fcb8585856001611845565b90508085600101541215611fe25760019150611fe7565b600091505b509392505050565b60007812725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f2182111561202e57604051633492ffd960e01b815260048101839052602401610545565b50670de0b6b3a76400000290565b6000610c318383612cc8565b6120528282611cd7565b60058401541561172157600080600080600088600501541290508015612165576040805160c0810182526001600160a01b038916815260058a0154602082015260009181016120ae6b0816769404766de590afe04e6001615038565b6001600160a01b0390811682526001602083015260028a810b604080850191909152908a900b606090930192909252609d549151638ef10c0360e01b81529293501690638ef10c0390612105908490600401614f2f565b606060405180830381600087803b15801561211f57600080fd5b505af1158015612133573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121579190614bfb565b919650945092506122549050565b6040805160c0810182526001600160a01b038916815260058a0154602082015260009181016121a260016c1fa71f3f5f68a90479ee3f8fec61510c565b6001600160a01b0390811682526001602083015260028a810b604080850191909152908a900b606090930192909252609d549151638ef10c0360e01b81529293501690638ef10c03906121f9908490600401614f2f565b606060405180830381600087803b15801561221357600080fd5b505af1158015612227573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061224b9190614bfb565b91965094509250505b811561226d5761226d612266836151b2565b8990611727565b611f488885856117a2565b604080516101008082018352845460ff811615158352046001600160801b031660208201526001840154918101919091526002830154606082015260038301546080820152600483015460a0820152600583015460c0820152600683015460e08201526000600f83900b61233357600082602001516001600160801b0316116123285760405162461bcd60e51b815260206004820152600260248201526104e560f41b6044820152606401610545565b506020810151612344565b612341826020015184612d8b565b90505b82600f0b6000146117215783546001600160801b03821661010002610100600160881b031990911617845550505050565b60006123848484846000611845565b90508084600101541361172157604051630a53e22f60e41b815260040160405180910390fd5b600061117342611fef565b6000806123c187612e4b565b905060006123ce87612e4b565b905060006123e7836123e260018a8a612ec8565b612f93565b905060006123f58387612f93565b905060006124038284614fcc565b9050670de0b6b3a764000081055b9b9a5050505050505050505050565b60b05460009042908290612434908361512c565b60b6546040516393556dbd60e01b81529192506001600160a01b0316906393556dbd906124679084908690600401614f87565b60206040518083038186803b15801561247f57600080fd5b505afa158015612493573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124b79190614df6565b9250505090565b6124c6612420565b60b1554260b255565b60006124da3061150f565b15905090565b600054610100900460ff166125075760405162461bcd60e51b815260040161054590614ec2565b6105a9613058565b600054610100900460ff166125365760405162461bcd60e51b815260040161054590614ec2565b6105a9613088565b604080516101008082018352855460ff811615158352046001600160801b0316602082015260018501549181019190915260028401546060820181905260038501546080830152600485015460a0830152600585015460c0830152600685015460e0830152600091829182906125b490876150a5565b905060008113156125e2576125db8183602001516001600160801b0316600160801b6130bb565b9350612612565b6126066125ee826151b2565b83602001516001600160801b0316600160801b6130bb565b61260f906151b2565b93505b600082608001518661262491906150a5565b905060008113156126525761264b8184602001516001600160801b0316600160801b6130bb565b9350612682565b61267661265e826151b2565b84602001516001600160801b0316600160801b6130bb565b61267f906151b2565b93505b505050935093915050565b604080516101008082018352845460ff811615158352046001600160801b0316602082018190526001850154928201929092526002840154606082015260038401546080820152600484015460a0820152600584015460c0820152600684015460e08201819052600092611c0491850390600160801b6130bb565b6000808460020b8660020b1415612724575060009050806127af565b600061275c612732886127b8565b61273b886127b8565b8860020b8a60020b1261274e57876131b3565b61275788615172565b6131b3565b9050600061279661276c896127b8565b612775896127b8565b8960020b8b60020b126127905761278b89615172565b6131fa565b886131fa565b90506127a9828287609954609a5461322e565b93509150505b94509492505050565b60008060008360020b126127cf578260020b6127dc565b8260020b6127dc906151b2565b90506127eb62010deb19615198565b60020b8111156128215760405162461bcd60e51b81526020600482015260016024820152601560fa1b6044820152606401610545565b60006001821661283557600160801b612847565b6ffffcb933bd6fad37aa2d162d1a5940015b6001600160881b03169050600282161561287c576080612877826ffff97272373d413259a46990580e213a615086565b901c90505b60048216156128a65760806128a1826ffff2e50f5f656932ef12357cf3c7fdcc615086565b901c90505b60088216156128d05760806128cb826fffe5caca7e10e4e61c3624eaa0941cd0615086565b901c90505b60108216156128fa5760806128f5826fffcb9843d60f6159c9db58835c926644615086565b901c90505b602082161561292457608061291f826fff973b41fa98c081472e6896dfb254c0615086565b901c90505b604082161561294e576080612949826fff2ea16466c96a3843ec78b326b52861615086565b901c90505b6080821615612978576080612973826ffe5dee046a99a2a811c461f1969c3053615086565b901c90505b6101008216156129a357608061299e826ffcbe86c7900a88aedcffc83b479aa3a4615086565b901c90505b6102008216156129ce5760806129c9826ff987a7253ac413176f2b074cf7815e54615086565b901c90505b6104008216156129f95760806129f4826ff3392b0822b70005940c7a398e4b70f3615086565b901c90505b610800821615612a24576080612a1f826fe7159475a2c29b7443b29c7fa6e889d9615086565b901c90505b611000821615612a4f576080612a4a826fd097f3bdfd2022b8845ad8f792aa5825615086565b901c90505b612000821615612a7a576080612a75826fa9f746462d870fdf8a65dc1f90e061e5615086565b901c90505b614000821615612aa5576080612aa0826f70d869a156d2a1b890bb3df62baf32f7615086565b901c90505b618000821615612ad0576080612acb826f31be135f97d08fd981231505542fcfa6615086565b901c90505b62010000821615612afc576080612af7826f09aa508b5b7a84e1c677de54f3e99bc9615086565b901c90505b62020000821615612b27576080612b22826e5d6af8dedb81196699c329225ee604615086565b901c90505b62040000821615612b51576080612b4c826d2216e584f5fa1ea926041bedfe98615086565b901c90505b62080000821615612b79576080612b74826b048a170391f7dc42444e8fa2615086565b901c90505b60008460020b1315612b9457612b9181600019615072565b90505b612ba2600160201b8261515e565b15612bae576001612bb1565b60005b611c049060ff16602083901c61505a565b6000612bcf8585856132f9565b90506000612bdf86868686613479565b905080821015612bed578091505b50949350505050565b60003d82612c0857806000803e806000fd5b8060208114612c20578015612c315760009250611fb3565b816000803e60005115159250611fb3565b5060019392505050565b60006040516323b872dd60e01b81526001600160a01b03851660048201526001600160a01b038416602482015282604482015260008060648360008a5af1915050612c8581612bf6565b6114225760405162461bcd60e51b81526020600482015260146024820152731514905394d1915497d19493d357d1905253115160621b6044820152606401610545565b60008080600019848609848602925082811083820303915050670de0b6b3a76400008110612d0c5760405163698d9a0160e11b815260048101829052602401610545565b600080670de0b6b3a76400008688099150506706f05b59d3b1ffff811182612d465780670de0b6b3a7640000850401945050505050612d85565b620400008285030493909111909103600160ee1b02919091177faccb18165bd6fe31ae1cf318dc5b51eee0e1ba569b88cd74c1773b91fac10669020190505b92915050565b60008082600f0b1215612df8576001600160801b038316612dab83615172565b612db590856150e4565b9150816001600160801b031610612df35760405162461bcd60e51b81526020600482015260026024820152614c5360f01b6044820152606401610545565b612d85565b6001600160801b038316612e0c838561500d565b9150816001600160801b03161015612d855760405162461bcd60e51b81526020600482015260026024820152614c4160f01b6044820152606401610545565b60007809392ee8e921d5d073aff322e62439fcf32d7f344649470f8f19821215612e8b5760405163e608e18b60e01b815260048101839052602401610545565b7809392ee8e921d5d073aff322e62439fcf32d7f344649470f9082131561202e576040516371f72a3160e01b815260048101839052602401610545565b6000828211612ee95760405162461bcd60e51b815260040161054590614ea4565b82612ef26123aa565b1015612f285760405162461bcd60e51b8152602060048201526005602482015264422e543c5360d81b6044820152606401610545565b60008480612f3d575082612f3a6123aa565b10155b15612f5357612f4c848461512c565b9050612f69565b83612f5c6123aa565b612f66919061512c565b90505b6000612f7482613631565b9050612f898168056bc75e2d63100000613644565b9695505050505050565b6000600160ff1b831480612faa5750600160ff1b82145b15612fc857604051630d01a11b60e21b815260040160405180910390fd5b60008060008512612fd95784612fde565b846000035b915060008412612fee5783612ff3565b836000035b905060006130018383612cc8565b90506001600160ff1b0381111561302e5760405163bf79e8d960e01b815260048101829052602401610545565b600019808713908613808218600114613047578261304c565b826000035b98975050505050505050565b600054610100900460ff1661307f5760405162461bcd60e51b815260040161054590614ec2565b6105a933611c0c565b600054610100900460ff166130af5760405162461bcd60e51b815260040161054590614ec2565b6065805460ff19169055565b60008080600019858709858702925082811083820303915050806000141561312b57600084116131205760405162461bcd60e51b815260206004820152601060248201526f4469766973696f6e206279207a65726f60801b6044820152606401610545565b508290049050610c31565b80841161314a5760405162461bcd60e51b815260040161054590614f0d565b60008486880960026001871981018816978890046003810283188082028403028082028403028082028403028082028403028082028403029081029092039091026000889003889004909101858311909403939093029303949094049190911702949350505050565b60008082600f0b126131d9576131d46131cf8585856001613659565b61376e565b611c04565b6131f16131cf85856131ea86615172565b6000613659565b611c04906151b2565b60008082600f0b12613216576131d46131cf85858560016137be565b6131f16131cf858561322786615172565b60006137be565b6000808613158015613241575060008512155b80613259575060008612158015613259575060008513155b8061326b57508515801561326b575084155b613288576040516301161e4160e01b815260040160405180910390fd5b600061329387612e4b565b905060006132a087612e4b565b90508484116132c15760405162461bcd60e51b815260040161054590614ea4565b60006132d08383898989613837565b905060006132e08483898961389f565b670de0b6b3a764000090059a9950505050505050505050565b600080841215801561330c575060008312155b1561331957506000610c31565b600061332485612e4b565b9050600061333185612e4b565b90506000609954609a54613345919061512c565b9050600061335d846123e26001609954609a54612ec8565b9050600061342d846123e285609a546133746123aa565b60008e128d61338161117f565b6040805161024081018252609e548152609f54602082015260a080549282019290925260a154606082015260a254608082015260a3549181019190915260a45460c082015260a55460e082015260a65461010082015260a75461012082015260a85461014082015260a95461016082015260aa5461018082015260ab546101a082015260ac546101c082015260ad546101e082015260ae5461020082015260af546102208201526138f7565b9050600061343b8284614fcc565b9050600081121561346757613460613452826151b2565b670de0b6b3a7640000900490565b965061346c565b600096505b5050505050509392505050565b60008361348857506000611c04565b6000806000808713156134ec5760008813156134aa5760009350505050611c04565b85156134bd57505060a65460aa546134c6565b505060a85460ac545b6134e587868484609a546134d86123aa565b60a55460ae54600161398e565b925061353b565b85156134ff57505060a75460ab54613508565b505060a95460ad545b61352f613514886151b2565b868484609a546135226123aa565b60a55460ae54600061398e565b613538906151b2565b92505b6000613546886151b2565b60b654609954609a546040516325f258dd60e01b81529394506000936135e693899387936001600160a01b03909216926325f258dd926135899291600401614f87565b602060405180830381600087803b1580156135a357600080fd5b505af11580156135b7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906135db9190614df6565b609954609a5461322e565b905060006135f4838b614fcc565b90506000613602838d614fcc565b905061360f81838c6132f9565b60af549098508810156136225760af5497505b50505050505050949350505050565b6000612d85826a1a1601fc4ea7109e0000005b6000610c3183670de0b6b3a764000084613b3b565b6000836001600160a01b0316856001600160a01b03161115613679579293925b600160601b600160e01b03606084901b166000613696878761510c565b6001600160a01b031690506000876001600160a01b0316116136f35760405162461bcd60e51b8152602060048201526016602482015275073717274207072696365206d757374206265203e20360541b6044820152606401610545565b8361373757866001600160a01b03166137168383896001600160a01b03166130bb565b8161373157634e487b7160e01b600052601260045260246000fd5b04613763565b61376361374e8383896001600160a01b0316613ba8565b886001600160a01b0316808204910615150190565b979650505050505050565b6000600160ff1b82106137ba5760405162461bcd60e51b815260206004820152601460248201527337bb32b9333637bb9034b7103a37a4b73a191a9b60611b6044820152606401610545565b5090565b6000836001600160a01b0316856001600160a01b031611156137de579293925b8161380b57613806836001600160801b03168686036001600160a01b0316600160601b6130bb565b61382e565b61382e836001600160801b03168686036001600160a01b0316600160601b613ba8565b95945050505050565b600061385d60405180606001604052806000815260200160008152602001600081525090565b61386d876123e260008787612ec8565b81526138798686612f93565b60208201819052815161388c9190614fcc565b6040909101819052905095945050505050565b60008282116138c05760405162461bcd60e51b815260040161054590614ea4565b60006138d2866123e260018787612ec8565b905060006138e086836150a5565b9050613763816138f260018888612ec8565b613c09565b60008061390389613631565b9050851561394a57841561392f57613928613922898987600188613ccf565b8261203c565b9150613982565b6139286139226139438a8a88600189613ccf565b855161203c565b841561396157613928613922898987600088613ccf565b61397f6139226139758a8a88600089613ccf565b856020015161203c565b91505b50979650505050505050565b60006139df6040518061012001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b613a006139ec6001611fef565b8b6001600160a01b0316600160601b6130bb565b8152613a20613a0f6001611fef565b8251613a1b908061203c565b613644565b60208201819052613a31908a61203c565b60408201819052881115613a4757604081018890525b613a5a613a54878961512c565b86613644565b6060820152613a75613a6b856151b2565b8260600151612f93565b60808201819052613a8590613efa565b613a8f6001612e4b565b613a9991906150a5565b60a082018190526040820151613aae9161203c565b60c08201528215613af3578060c0015181602001511115613ae7578060c001518160200151613add919061512c565b60e0820152613b0d565b600060e0820152613b0d565b8060c001518160200151613b07919061505a565b60e08201525b613b23613b198c611fef565b8260e0015161203c565b6101008201819052670de0b6b3a76400009004612411565b600080806000198587098587029250828110838203039150508060001415613b8457838281613b7a57634e487b7160e01b600052601260045260246000fd5b0492505050610c31565b83811061314a578084604051631dcf306360e21b8152600401610545929190614f87565b6000613bb58484846130bb565b905060008280613bd557634e487b7160e01b600052601260045260246000fd5b8486091115610c31576000198110613bff5760405162461bcd60e51b815260040161054590614f0d565b8061382e81615143565b6000600160ff1b831480613c205750600160ff1b82145b15613c3e5760405163b3c754a360e01b815260040160405180910390fd5b60008060008512613c4f5784613c54565b846000035b915060008412613c645783613c69565b836000035b90506000613c8083670de0b6b3a764000084613b3b565b90506001600160ff1b03811115613cad57604051637cb4bef560e01b815260048101829052602401610545565b600019808713908613808218600114613cc6578261304c565b61304c836151b2565b6000613d206040518061012001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6000613d3484608001516123e26004612e4b565b90506000613d4a85606001516123e26004612e4b565b9050613d57898987613f6a565b808452613d646001612e4b565b613d6e91906150a5565b60208401526040850151613d83908290613c09565b836040018181525050613da7613da186604001518560200151612f93565b83613c09565b60608401528251613dc390613dbd908490612f93565b88612f93565b608084015260408501516020840151613ddc9190612f93565b60a084018190526080840151613df191613c09565b60c08401526040830151613e2a90613e16613e0c6002612e4b565b8660c00151612f93565b613e209190614fcc565b6123e26002612e4b565b60e08401528515613e5557613e4a8560a001516123e28560e0015161408a565b610100840152613e71565b613e6a8560c001516123e28560e0015161408a565b6101008401525b600086613ea957613ea484606001518561010001518660c001518760400151613e9a9190614fcc565b6123e291906150a5565b613ed5565b613ed584606001518561010001518660c001518760400151613ecb9190614fcc565b6123e29190614fcc565b90506000811215613ee95760009450613eed565b8094505b5050505095945050505050565b600068023f2fa8f6da5b9d3119821215613f1657506000919050565b680736ea4425c11ac6318212613f42576040516399bb754160e01b815260048101839052602401610545565b6714057b7ef767814f8202610c31670de0b6b3a76400006706f05b59d3b20000830105614100565b6000808411613fba5760405162461bcd60e51b815260206004820152601c60248201527b07465726d456e6454696d657374616d70206d757374206265203e20360241b6044820152606401610545565b8383111561400a5760405162461bcd60e51b815260206004820152601d60248201527f656e6454696d65206d757374206265203e2063757272656e7454696d650000006044820152606401610545565b60808201516140505760405162461bcd60e51b81526020600482015260126024820152711c185c985b595d195c9cc81b9bdd081cd95d60721b6044820152606401610545565b608082015160e08301516000614069613da187896150a5565b9050600061407f614079856151b2565b83612f93565b905061304c81613efa565b6000808212156140b05760405163608c83ff60e11b815260048101839052602401610545565b7809392ee8e921d5d073aff322e62439fcf32d7f344649470f908213156140ed57604051632c482c3960e01b815260048101839052602401610545565b612d85670de0b6b3a764000083026141a5565b6000808212156141615768033dd1780914b971141982121561412457506000919050565b61413082600003614100565b6a0c097ce7bc90715b34b9f160241b8161415a57634e487b7160e01b600052601260045260246000fd5b0592915050565b680a688906bd8b000000821261418d5760405163e69458f960e01b815260048101839052602401610545565b670de0b6b3a7640000604083901b04610c3181614380565b6000816141b457506000919050565b50600181600160801b81106141ce5760409190911b9060801c5b600160401b81106141e45760209190911b9060401c5b600160201b81106141fa5760109190911b9060201c5b62010000811061420f5760089190911b9060101c5b61010081106142235760049190911b9060081c5b601081106142365760029190911b9060041c5b6008811061424657600182901b91505b600182848161426557634e487b7160e01b600052601260045260246000fd5b048301901c9150600182848161428b57634e487b7160e01b600052601260045260246000fd5b048301901c915060018284816142b157634e487b7160e01b600052601260045260246000fd5b048301901c915060018284816142d757634e487b7160e01b600052601260045260246000fd5b048301901c915060018284816142fd57634e487b7160e01b600052601260045260246000fd5b048301901c9150600182848161432357634e487b7160e01b600052601260045260246000fd5b048301901c9150600182848161434957634e487b7160e01b600052601260045260246000fd5b048301901c9150600082848161436f57634e487b7160e01b600052601260045260246000fd5b04905080831015610c315782611c04565b600160bf1b6001603f1b8216156143a05768016a09e667f3bcc9090260401c5b6001603e1b8216156143bb576801306fe0a31b7152df0260401c5b6001603d1b8216156143d6576801172b83c7d517adce0260401c5b6001603c1b8216156143f15768010b5586cf9890f62a0260401c5b6001603b1b82161561440c576801059b0d31585743ae0260401c5b6001603a1b82161561442757680102c9a3e778060ee70260401c5b600160391b8216156144425768010163da9fb33356d80260401c5b600160381b82161561445d57680100b1afa5abcbed610260401c5b600160371b8216156144785768010058c86da1c09ea20260401c5b600160361b821615614493576801002c605e2e8cec500260401c5b600160351b8216156144ae57680100162f3904051fa10260401c5b600160341b8216156144c9576801000b175effdc76ba0260401c5b600160331b8216156144e457680100058ba01fb9f96d0260401c5b600160321b8216156144ff5768010002c5cc37da94920260401c5b600160311b82161561451a576801000162e525ee05470260401c5b600160301b8216156145355768010000b17255775c040260401c5b6001602f1b821615614550576801000058b91b5bc9ae0260401c5b6001602e1b82161561456b57680100002c5c89d5ec6d0260401c5b6001602d1b8216156145865768010000162e43f4f8310260401c5b6001602c1b8216156145a157680100000b1721bcfc9a0260401c5b6001602b1b8216156145bc5768010000058b90cf1e6e0260401c5b6001602a1b8216156145d7576801000002c5c863b73f0260401c5b600160291b8216156145f257680100000162e430e5a20260401c5b600160281b82161561460d576801000000b1721835510260401c5b600160271b82161561462857680100000058b90c0b490260401c5b600160261b8216156146435768010000002c5c8601cc0260401c5b600160251b82161561465e576801000000162e42fff00260401c5b600160241b8216156146795768010000000b17217fbb0260401c5b600160231b821615614694576801000000058b90bfce0260401c5b600160221b8216156146af57680100000002c5c85fe30260401c5b600160211b8216156146ca5768010000000162e42ff10260401c5b600160201b8216156146e557680100000000b17217f80260401c5b63800000008216156147005768010000000058b90bfc0260401c5b634000000082161561471b576801000000002c5c85fe0260401c5b632000000082161561473657680100000000162e42ff0260401c5b6310000000821615614751576801000000000b17217f0260401c5b630800000082161561476c57680100000000058b90c00260401c5b63040000008216156147875768010000000002c5c8600260401c5b63020000008216156147a2576801000000000162e4300260401c5b63010000008216156147bd5768010000000000b172180260401c5b628000008216156147d7576801000000000058b90c0260401c5b624000008216156147f157680100000000002c5c860260401c5b6220000082161561480b5768010000000000162e430260401c5b6210000082161561482557680100000000000b17210260401c5b6208000082161561483f5768010000000000058b910260401c5b62040000821615614859576801000000000002c5c80260401c5b6202000082161561487357680100000000000162e40260401c5b6201000082161561488c5761b172600160401b010260401c5b6180008216156148a4576158b9600160401b010260401c5b6140008216156148bc57612c5d600160401b010260401c5b6120008216156148d45761162e600160401b010260401c5b6110008216156148ec57610b17600160401b010260401c5b6108008216156149045761058c600160401b010260401c5b61040082161561491c576102c6600160401b010260401c5b61020082161561493457610163600160401b010260401c5b61010082161561494b5760b1600160401b010260401c5b6080821615614961576059600160401b010260401c5b604082161561497757602c600160401b010260401c5b602082161561498d576016600160401b010260401c5b60108216156149a357600b600160401b010260401c5b60088216156149b9576006600160401b010260401c5b60048216156149cf576003600160401b010260401c5b60028216156149e5576001600160401b010260401c5b60018216156149fb576001600160401b010260401c5b670de0b6b3a76400000260409190911c60bf031c90565b600060208284031215614a23578081fd5b8135610c31816151f8565b60008060008060808587031215614a43578283fd5b8435614a4e816151f8565b93506020850135614a5e816151f8565b93969395505050506040820135916060013590565b600080600060608486031215614a87578283fd5b8335614a92816151f8565b92506020840135614aa28161520d565b91506040840135614ab28161520d565b809150509250925092565b60008060008060808587031215614ad2578384fd5b8435614add816151f8565b93506020850135614aed8161520d565b92506040850135614afd8161520d565b9396929550929360600135925050565b60008060008060008060c08789031215614b25578182fd5b8635614b30816151f8565b95506020870135614b408161520d565b94506040870135614b508161520d565b959894975094956060810135955060808101359460a0909101359350915050565b60008060408385031215614b83578081fd5b8235614b8e816151f8565b946020939093013593505050565b600060208284031215614bad578081fd5b81518015158114610c31578182fd5b600080600060608486031215614bd0578081fd5b8335614bdb8161520d565b92506020840135614beb8161520d565b91506040840135614ab2816151f8565b600080600060608486031215614c0f578081fd5b8351925060208401519150604084015190509250925092565b60006102408284031215614c3a578081fd5b614c42614f95565b823581526020808401359082015260408084013590820152606080840135908201526080808401359082015260a0808401359082015260c0808401359082015260e08084013590820152610100808401359082015261012080840135908201526101408084013590820152610160808401359082015261018080840135908201526101a080840135908201526101c080840135908201526101e080840135908201526102008084013590820152610220928301359281019290925250919050565b600060808284031215614d14578081fd5b604051608081016001600160401b0381118282101715614d4257634e487b7160e01b83526041600452602483fd5b6040528235614d50816151f8565b81526020830135614d608161520d565b60208201526040830135614d738161520d565b60408201526060830135600f81900b8114614d8c578283fd5b60608201529392505050565b600080600060608486031215614dac578081fd5b8351614db7816151f8565b6020850151909350614dc88161520d565b604085015190925060ff81168114614ab2578182fd5b600060208284031215614def578081fd5b5035919050565b600060208284031215614e07578081fd5b5051919050565b6001600160a01b0391909116815260200190565b6001600160a01b0392831681529116602082015260400190565b6001600160a01b03949094168452600292830b6020850152910b60408301526001600160801b0316606082015260800190565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b602080825260049082015263453c3d5360e01b604082015260600190565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b6020808252600890820152676f766572666c6f7760c01b604082015260600190565b600060c08201905060018060a01b038084511683526020840151602084015280604085015116604084015250606083015115156060830152608083015160020b608083015260a083015160020b60a083015292915050565b918252602082015260400190565b60405161024081016001600160401b0381118282101715614fc657634e487b7160e01b600052604160045260246000fd5b60405290565b600080821280156001600160ff1b0384900385131615614fee57614fee6151cc565b600160ff1b8390038412811615615007576150076151cc565b50500190565b60006001600160801b0382811684821680830382111561502f5761502f6151cc565b01949350505050565b60006001600160a01b0382811684821680830382111561502f5761502f6151cc565b6000821982111561506d5761506d6151cc565b500190565b600082615081576150816151e2565b500490565b60008160001904831182151516156150a0576150a06151cc565b500290565b60008083128015600160ff1b8501841216156150c3576150c36151cc565b6001600160ff1b03840183138116156150de576150de6151cc565b50500390565b60006001600160801b0383811690831681811015615104576151046151cc565b039392505050565b60006001600160a01b0383811690831681811015615104576151046151cc565b60008282101561513e5761513e6151cc565b500390565b6000600019821415615157576151576151cc565b5060010190565b60008261516d5761516d6151e2565b500690565b6000600f82900b60016001607f1b0319811415615191576151916151cc565b9003919050565b60008160020b627fffff19811415615191576151916151cc565b6000600160ff1b8214156151c8576151c86151cc565b0390565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fd5b6001600160a01b038116811461150c57600080fd5b8060020b811461150c57600080fdfea2646970667358221220338cacc19a358a4559f503d74ecca14a2c2d8259f96fc66f1c16a10dd8b604f964736f6c63430008040033",
  "devdoc": {
    "errors": {
      "MarginLessThanMinimum()": [
        {
          "details": "Cannot have less margin than the minimum requirement"
        }
      ],
      "PositionNetZero()": [
        {
          "details": "No need to unwind a net zero position"
        }
      ],
      "PositionNotSettled()": [
        {
          "details": "Position must be settled after AMM has reached maturity"
        }
      ],
      "WithdrawalExceedsCurrentMargin()": [
        {
          "details": "We can't withdraw more margin than we have"
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "collectProtocol(address,uint256)": {
        "params": {
          "amount": "the amount in terms of underlying tokens collected from the protocol's earnings",
          "recipient": "the address which collects the protocol generated fees"
        }
      },
      "constructor": {
        "custom:oz-upgrades-unsafe-allow": "constructor"
      },
      "getHistoricalApy()": {
        "details": "The lookback window used by this function is determined by the secondsAgo state variable"
      },
      "getHistoricalApyReadOnly()": {
        "details": "The lookback window used by this function is determined by the secondsAgo state variable"
      },
      "getPosition(address,int24,int24)": {
        "params": {
          "_owner": "The address of the position owner",
          "tickLower": "The lower tick boundary of the position",
          "tickUpper": "The upper tick boundary of the position Returns position The Position.Info corresponding to the requested position"
        }
      },
      "initialize(address,address,uint256,uint256)": {
        "details": "\"constructor\" for proxy instances"
      },
      "liquidatePosition(int24,int24,address)": {
        "details": "Steps to liquidate: update position's fixed and variable token balances to account for balances accumulated throughout the trades made since the last mint/burn/poke,Check if the position is liquidatable by calling the isLiquidatablePosition function of the calculator, revert if that is not the case,Calculate the liquidation reward = current margin of the position * liquidatorReward, subtract the liquidator reward from the position margin,Burn the position's liquidity, unwind unnetted fixed and variable balances of a position, transfer the reward to the liquidator"
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "paused()": {
        "details": "Returns true if the contract is paused, and false otherwise."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "setCacheMaxAgeInSeconds(uint256)": {
        "params": {
          "_cacheMaxAgeInSeconds": "The new maximum age that the historical APY cache can be before being considered stale"
        }
      },
      "setMarginCalculatorParameters((uint256,uint256,int256,int256,int256,int256,int256,int256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))": {
        "details": "marginCalculatorParameteres is of type MarginCalculatorParameters (refer to the definition of the struct for elaboration on what each parameter means)",
        "params": {
          "_marginCalculatorParameters": "the MarginCalculatorParameters to set"
        }
      },
      "setSecondsAgo(uint256)": {
        "details": "Can only be set by the Factory Owner",
        "params": {
          "_secondsAgo": "the duration of the lookback window in seconds"
        }
      },
      "setVAMM(address)": {
        "details": "the VAMM is responsible for price discovery, whereas the management of the underlying collateral and liquidations are handled by the Margin Engine"
      },
      "settlePosition(int24,int24,address)": {
        "details": "Can be called by anyoneA position cannot be settled before maturitySteps to settle a position:1. Retrieve the current fixed and variable token growth inside the tick range of a position2. Calculate accumulated fixed and variable balances of the position since the last mint/poke/burn3. Update the postion's fixed and variable token balances4. Update the postion's fixed and varaible token growth inside last to enable future updates5. Calculates the settlement cashflow from all of the IRS contracts the position has entered since entering the AMM6. Updates the fixed and variable token balances of the position to be zero, adds the settlement cashflow to the position's current margin"
      },
      "transferMarginToFCMTrader(address,uint256)": {
        "details": "post maturity date of the MarginEngine, the traders from the Full Collateralisation module will be able to settle with the MarginEngineto ensure their fixed yield is guaranteed, in order to collect the funds from the MarginEngine, the FCM needs to invoke the transferMarginToFCMTrader function whcih is only callable by the FCM attached to a particular Margin Engine"
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      },
      "updatePositionMargin(address,int24,int24,int256)": {
        "details": "if the position has positive liquidity then before the margin update, we call the updatePositionTokenBalancesAndAccountForFees functon that calculates up to datemargin, fixed and variable token balances by taking into account the fee income from their tick range and fixed and variable deltas settled along their tick rangemarginDelta is the delta applied to the current margin of a positioin, if the marginDelta is negative, the position is withdrawing margin, if the marginDelta is positive, the position is depositing funds in terms of the underlying tokensif marginDelta is negative, we need to check if the msg.sender is either the _owner of the position or the msg.sender is apporved by the _owner to act on their behalf in Voltz Protocolthe approval logic is implemented in the Factory.solif marginDelta is negative, we additionally need to check if post the initial margin requirement is still satisfied post withdrawalif marginDelta is positive, the depositor of the margin is either the msg.sender or the owner who interacted through an approved peripheral contract"
      },
      "updatePositionPostVAMMInducedMintBurn((address,int24,int24,int128))": {
        "details": "Steps taken:1. Update position liquidity based on params.liquidityDelta2. Update fixed and variable token balances of the position based on how much has been accumulated since the last mint/burn/poke3. Update position's margin by taking into account the position accumulated fees since the last mint/burn/poke4. Update fixed and variable token growth + fee growth in the position info struct for future interactions with the position",
        "params": {
          "params": "necessary for the purposes of referencing the position being updated (owner, tickLower, tickUpper, _) and the liquidity delta that needs to be applied to position._liquidity"
        }
      },
      "updatePositionPostVAMMInducedSwap(address,int24,int24,int256,int256,uint256)": {
        "details": "Since every position can also engage in swaps with the VAMM, this function needs to be invoked after non-external calls are made to the VAMM's swap functionThis purpose of this function is to:1. updatePositionTokenBalancesAndAccountForFees2. update position margin to account for fees paid to execute the swap3. calculate the position margin requrement given the swap, check if the position marigin satisfies the most up to date requirement4. if all the requirements are satisfied then position gets updated to take into account the swap that it just entered, if the minimum margin requirement is not satisfied then the transaction will revert"
      }
    },
    "stateVariables": {
      "factory": {
        "details": "the factory that deployed the master Margin Engine"
      },
      "fcm": {
        "details": "The FCM is a smart contract that acts as an intermediary Position between the Voltz Core and traders who wish to take fully collateralised fixed taker positionsAn example FCM is the AaveFCM.sol module which inherits from the IFCM interface, it lets fixed takers deposit underlying yield bearing tokens (e.g.) aUSDC as margin to enter into a fixed taker swap without the need to worry about liquidationssince the MarginEngine is confident the FCM is always fully collateralised, it does not let liquidators liquidate the FCM Position",
        "return": "The Full Collateralisation Module linked to the MarginEngine",
        "returns": {
          "_0": "The Full Collateralisation Module linked to the MarginEngine"
        }
      },
      "liquidatorRewardWad": {
        "details": "liquidatorReward (in wad) is the percentage of the margin (of a liquidated position) that is sent to the liquidatorfollowing a successful liquidation that results in a trader/position unwind; example value:  2 * 10**16 => 2% of position margin is used to cover liquidator reward",
        "return": "Liquidator Reward in Wad",
        "returns": {
          "_0": "Liquidator Reward in Wad"
        }
      },
      "rateOracle": {
        "return": "The underlying ERC20 token (e.g. USDC)",
        "returns": {
          "_0": "The underlying ERC20 token (e.g. USDC)"
        }
      },
      "secondsAgo": {
        "details": "The historical APY of the Rate Oracle is necessary for MarginEngine computationsThe look-back window is seconds from the current timestampThis value is only settable by the the Factory owner and may be unique for each MarginEngineWhen setting secondAgo, the setter needs to take into consideration the underlying volatility of the APYs in the reference yield-bearing pool (e.g. Aave v2 USDC)"
      },
      "termEndTimestampWad": {
        "return": "Term End Timestamp in Wad",
        "returns": {
          "_0": "Term End Timestamp in Wad"
        }
      },
      "termStartTimestampWad": {
        "return": "Term Start Timestamp in Wad",
        "returns": {
          "_0": "Term Start Timestamp in Wad"
        }
      },
      "underlyingToken": {
        "return": "The underlying ERC20 token (e.g. USDC)",
        "returns": {
          "_0": "The underlying ERC20 token (e.g. USDC)"
        }
      },
      "vamm": {
        "details": "The VAMM is responsible for pricing only (determining the effective fixed rate at which a given Interest Rate Swap notional will be executed)",
        "return": "The VAMM",
        "returns": {
          "_0": "The VAMM"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "AmountSignsSame()": [
        {
          "notice": "amount0 and amount1 must have different signs"
        }
      ],
      "CannotLiquidate()": [
        {
          "notice": "The position/trader needs to be below the liquidation threshold to be liquidated"
        }
      ],
      "CannotSettleBeforeMaturity()": [
        {
          "notice": "Positions and Traders cannot be settled before the applicable interest rate swap has matured"
        }
      ],
      "InvalidMarginDelta()": [
        {
          "notice": "Margin delta must not equal zero"
        }
      ],
      "MarginRequirementNotMet()": [
        {
          "notice": "The resulting margin does not meet minimum requirements"
        }
      ],
      "OnlyOwnerCanUpdatePosition()": [
        {
          "notice": "Only the position/trade owner can update the LP/Trader margin"
        }
      ],
      "PRBMathSD59x18__DivInputTooSmall()": [
        {
          "notice": "Emitted when one of the inputs is MIN_SD59x18."
        }
      ],
      "PRBMathSD59x18__DivOverflow(uint256)": [
        {
          "notice": "Emitted when one of the intermediary unsigned results overflows SD59x18."
        }
      ],
      "PRBMathSD59x18__Exp2InputTooBig(int256)": [
        {
          "notice": "Emitted when the input is greater than 192."
        }
      ],
      "PRBMathSD59x18__ExpInputTooBig(int256)": [
        {
          "notice": "Emitted when the input is greater than 133.084258667509499441."
        }
      ],
      "PRBMathSD59x18__FromIntOverflow(int256)": [
        {
          "notice": "Emitted when converting a basic integer to the fixed-point format overflows SD59x18."
        }
      ],
      "PRBMathSD59x18__FromIntUnderflow(int256)": [
        {
          "notice": "Emitted when converting a basic integer to the fixed-point format underflows SD59x18."
        }
      ],
      "PRBMathSD59x18__MulInputTooSmall()": [
        {
          "notice": "Emitted when one of the inputs is MIN_SD59x18."
        }
      ],
      "PRBMathSD59x18__MulOverflow(uint256)": [
        {
          "notice": "Emitted when the intermediary absolute result overflows SD59x18."
        }
      ],
      "PRBMathSD59x18__SqrtNegativeInput(int256)": [
        {
          "notice": "Emitted when the input is negative."
        }
      ],
      "PRBMathSD59x18__SqrtOverflow(int256)": [
        {
          "notice": "Emitted when the calculating the square root overflows SD59x18."
        }
      ],
      "PRBMathUD60x18__FromUintOverflow(uint256)": [
        {
          "notice": "Emitted when converting a basic integer to the fixed-point format format overflows UD60x18."
        }
      ],
      "PRBMath__MulDivFixedPointOverflow(uint256)": [
        {
          "notice": "Emitted when the result overflows uint256."
        }
      ],
      "PRBMath__MulDivOverflow(uint256,uint256)": [
        {
          "notice": "Emitted when the result overflows uint256."
        }
      ]
    },
    "kind": "user",
    "methods": {
      "collectProtocol(address,uint256)": {
        "notice": "function that can only be called by the owner enables collection of protocol generated fees from any give margin engine"
      },
      "factory()": {
        "notice": "The Factory"
      },
      "fcm()": {
        "notice": "The Full Collateralisation Module (FCM)"
      },
      "getHistoricalApy()": {
        "notice": "Computes the historical APY value of the RateOracle"
      },
      "getHistoricalApyReadOnly()": {
        "notice": "Computes the historical APY value of the RateOracle"
      },
      "getPosition(address,int24,int24)": {
        "notice": "Returns the information about a position by the position's key"
      },
      "liquidatePosition(int24,int24,address)": {
        "notice": "Liquidate a Position"
      },
      "liquidatorRewardWad()": {
        "notice": "The liquidator Reward Percentage (in Wad)"
      },
      "rateOracle()": {
        "notice": "The rateOracle contract which lets the protocol access historical apys in the yield bearing pools it is built on top of"
      },
      "secondsAgo()": {
        "notice": "Gets the look-back window size that's used to request the historical APY from the rate Oracle"
      },
      "setCacheMaxAgeInSeconds(uint256)": {
        "notice": "Sets the maximum age that the cached historical APY value"
      },
      "setFCM(address)": {
        "notice": "sets the Full Collateralisation Module"
      },
      "setLiquidatorReward(uint256)": {
        "notice": "Sets the liquidator reward: proportion of liquidated position's margin paid as a reward to the liquidator"
      },
      "setMarginCalculatorParameters((uint256,uint256,int256,int256,int256,int256,int256,int256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))": {
        "notice": "Set the MarginCalculatorParameters (each margin engine can have its own custom set of margin calculator parameters)"
      },
      "setSecondsAgo(uint256)": {
        "notice": "Sets secondsAgo: The look-back window size used to calculate the historical APY for margin purposes"
      },
      "setVAMM(address)": {
        "notice": "sets the Virtual Automated Market Maker (VAMM) attached to the MarginEngine"
      },
      "settlePosition(int24,int24,address)": {
        "notice": "Settles a Position"
      },
      "termEndTimestampWad()": {
        "notice": "The unix termEndTimestamp of the MarginEngine in Wad"
      },
      "termStartTimestampWad()": {
        "notice": "The unix termStartTimestamp of the MarginEngine in Wad"
      },
      "transferMarginToFCMTrader(address,uint256)": {
        "notice": "transfers margin in terms of underlying tokens to a trader from the Full Collateralisation Module"
      },
      "underlyingToken()": {
        "notice": "The address of the underlying (non-yield bearing) token - e.g. USDC"
      },
      "updatePositionMargin(address,int24,int24,int256)": {
        "notice": "updates the margin account of a position which can be uniquily identified with its _owner, tickLower, tickUpper"
      },
      "updatePositionPostVAMMInducedMintBurn((address,int24,int24,int128))": {
        "notice": "Update a Position post VAMM induced mint or burn"
      },
      "vamm()": {
        "notice": "VAMM (Virtual Automated Market Maker) linked to the MarginEngine"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 130,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 133,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 592,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "__gap",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 10,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "_owner",
        "offset": 0,
        "slot": "51",
        "type": "t_address"
      },
      {
        "astId": 122,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "__gap",
        "offset": 0,
        "slot": "52",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 218,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "_paused",
        "offset": 0,
        "slot": "101",
        "type": "t_bool"
      },
      {
        "astId": 307,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "__gap",
        "offset": 0,
        "slot": "102",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 2496,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "liquidatorRewardWad",
        "offset": 0,
        "slot": "151",
        "type": "t_uint256"
      },
      {
        "astId": 2500,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "underlyingToken",
        "offset": 0,
        "slot": "152",
        "type": "t_contract(IERC20Minimal)9332"
      },
      {
        "astId": 2504,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "termStartTimestampWad",
        "offset": 0,
        "slot": "153",
        "type": "t_uint256"
      },
      {
        "astId": 2508,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "termEndTimestampWad",
        "offset": 0,
        "slot": "154",
        "type": "t_uint256"
      },
      {
        "astId": 2513,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "fcm",
        "offset": 0,
        "slot": "155",
        "type": "t_contract(IFCM)9379"
      },
      {
        "astId": 2518,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "positions",
        "offset": 0,
        "slot": "156",
        "type": "t_mapping(t_bytes32,t_struct(Info)7461_storage)"
      },
      {
        "astId": 2522,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "vamm",
        "offset": 0,
        "slot": "157",
        "type": "t_contract(IVAMM)10331"
      },
      {
        "astId": 2525,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "marginCalculatorParameters",
        "offset": 0,
        "slot": "158",
        "type": "t_struct(MarginCalculatorParameters)9595_storage"
      },
      {
        "astId": 2529,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "secondsAgo",
        "offset": 0,
        "slot": "176",
        "type": "t_uint256"
      },
      {
        "astId": 2531,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "cachedHistoricalApy",
        "offset": 0,
        "slot": "177",
        "type": "t_uint256"
      },
      {
        "astId": 2533,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "cachedHistoricalApyRefreshTimestamp",
        "offset": 0,
        "slot": "178",
        "type": "t_uint256"
      },
      {
        "astId": 2535,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "cacheMaxAgeInSeconds",
        "offset": 0,
        "slot": "179",
        "type": "t_uint256"
      },
      {
        "astId": 2537,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "deployer",
        "offset": 0,
        "slot": "180",
        "type": "t_address"
      },
      {
        "astId": 2542,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "factory",
        "offset": 0,
        "slot": "181",
        "type": "t_contract(IFactory)9514"
      },
      {
        "astId": 2547,
        "contract": "contracts/MarginEngine.sol:MarginEngine",
        "label": "rateOracle",
        "offset": 0,
        "slot": "182",
        "type": "t_contract(IRateOracle)10545"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IERC20Minimal)9332": {
        "encoding": "inplace",
        "label": "contract IERC20Minimal",
        "numberOfBytes": "20"
      },
      "t_contract(IFCM)9379": {
        "encoding": "inplace",
        "label": "contract IFCM",
        "numberOfBytes": "20"
      },
      "t_contract(IFactory)9514": {
        "encoding": "inplace",
        "label": "contract IFactory",
        "numberOfBytes": "20"
      },
      "t_contract(IRateOracle)10545": {
        "encoding": "inplace",
        "label": "contract IRateOracle",
        "numberOfBytes": "20"
      },
      "t_contract(IVAMM)10331": {
        "encoding": "inplace",
        "label": "contract IVAMM",
        "numberOfBytes": "20"
      },
      "t_int256": {
        "encoding": "inplace",
        "label": "int256",
        "numberOfBytes": "32"
      },
      "t_mapping(t_bytes32,t_struct(Info)7461_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct Position.Info)",
        "numberOfBytes": "32",
        "value": "t_struct(Info)7461_storage"
      },
      "t_struct(Info)7461_storage": {
        "encoding": "inplace",
        "label": "struct Position.Info",
        "members": [
          {
            "astId": 7446,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "isSettled",
            "offset": 0,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 7448,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "_liquidity",
            "offset": 1,
            "slot": "0",
            "type": "t_uint128"
          },
          {
            "astId": 7450,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "margin",
            "offset": 0,
            "slot": "1",
            "type": "t_int256"
          },
          {
            "astId": 7452,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "fixedTokenGrowthInsideLastX128",
            "offset": 0,
            "slot": "2",
            "type": "t_int256"
          },
          {
            "astId": 7454,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "variableTokenGrowthInsideLastX128",
            "offset": 0,
            "slot": "3",
            "type": "t_int256"
          },
          {
            "astId": 7456,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "fixedTokenBalance",
            "offset": 0,
            "slot": "4",
            "type": "t_int256"
          },
          {
            "astId": 7458,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "variableTokenBalance",
            "offset": 0,
            "slot": "5",
            "type": "t_int256"
          },
          {
            "astId": 7460,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "feeGrowthInsideLastX128",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "224"
      },
      "t_struct(MarginCalculatorParameters)9595_storage": {
        "encoding": "inplace",
        "label": "struct IMarginEngine.MarginCalculatorParameters",
        "members": [
          {
            "astId": 9543,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "apyUpperMultiplierWad",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 9546,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "apyLowerMultiplierWad",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 9549,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "sigmaSquaredWad",
            "offset": 0,
            "slot": "2",
            "type": "t_int256"
          },
          {
            "astId": 9552,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "alphaWad",
            "offset": 0,
            "slot": "3",
            "type": "t_int256"
          },
          {
            "astId": 9555,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "betaWad",
            "offset": 0,
            "slot": "4",
            "type": "t_int256"
          },
          {
            "astId": 9558,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "xiUpperWad",
            "offset": 0,
            "slot": "5",
            "type": "t_int256"
          },
          {
            "astId": 9561,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "xiLowerWad",
            "offset": 0,
            "slot": "6",
            "type": "t_int256"
          },
          {
            "astId": 9564,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "tMaxWad",
            "offset": 0,
            "slot": "7",
            "type": "t_int256"
          },
          {
            "astId": 9567,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "devMulLeftUnwindLMWad",
            "offset": 0,
            "slot": "8",
            "type": "t_uint256"
          },
          {
            "astId": 9570,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "devMulRightUnwindLMWad",
            "offset": 0,
            "slot": "9",
            "type": "t_uint256"
          },
          {
            "astId": 9573,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "devMulLeftUnwindIMWad",
            "offset": 0,
            "slot": "10",
            "type": "t_uint256"
          },
          {
            "astId": 9576,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "devMulRightUnwindIMWad",
            "offset": 0,
            "slot": "11",
            "type": "t_uint256"
          },
          {
            "astId": 9579,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "fixedRateDeviationMinLeftUnwindLMWad",
            "offset": 0,
            "slot": "12",
            "type": "t_uint256"
          },
          {
            "astId": 9582,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "fixedRateDeviationMinRightUnwindLMWad",
            "offset": 0,
            "slot": "13",
            "type": "t_uint256"
          },
          {
            "astId": 9585,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "fixedRateDeviationMinLeftUnwindIMWad",
            "offset": 0,
            "slot": "14",
            "type": "t_uint256"
          },
          {
            "astId": 9588,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "fixedRateDeviationMinRightUnwindIMWad",
            "offset": 0,
            "slot": "15",
            "type": "t_uint256"
          },
          {
            "astId": 9591,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "gammaWad",
            "offset": 0,
            "slot": "16",
            "type": "t_uint256"
          },
          {
            "astId": 9594,
            "contract": "contracts/MarginEngine.sol:MarginEngine",
            "label": "minMarginToIncentiviseLiquidators",
            "offset": 0,
            "slot": "17",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "576"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}
