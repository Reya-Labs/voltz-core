{
  "address": "0x54B868B03c68A1307B24fB0A4b60b18A0714a94C",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_aaveLendingPool",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "underlying",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "AavePoolGetReserveNormalizedIncomeReturnedZero",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "x",
          "type": "uint256"
        }
      ],
      "name": "PRBMathUD60x18__Exp2InputTooBig",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "x",
          "type": "uint256"
        }
      ],
      "name": "PRBMathUD60x18__FromUintOverflow",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "x",
          "type": "uint256"
        }
      ],
      "name": "PRBMathUD60x18__LogInputTooSmall",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "prod1",
          "type": "uint256"
        }
      ],
      "name": "PRBMath__MulDivFixedPointOverflow",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "prod1",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "denominator",
          "type": "uint256"
        }
      ],
      "name": "PRBMath__MulDivOverflow",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "observationCardinalityNextOld",
          "type": "uint16"
        },
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "observationCardinalityNextNew",
          "type": "uint16"
        }
      ],
      "name": "IncreaserateCardinalityNext",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_minSecondsSinceLastUpdate",
          "type": "uint256"
        }
      ],
      "name": "MinSecondsSinceLastUpdateSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "blockTimestampScaled",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "source",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "index",
          "type": "uint16"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "blockTimestamp",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "observedValue",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "cardinality",
          "type": "uint16"
        },
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "cardinalityNext",
          "type": "uint16"
        }
      ],
      "name": "OracleBufferWrite",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "ONE_WEI",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "aaveLendingPool",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "from",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "to",
          "type": "uint256"
        }
      ],
      "name": "getApyFromTo",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "apyFromToWad",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_from",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_to",
          "type": "uint256"
        }
      ],
      "name": "getRateFromTo",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "rateCardinalityNext",
          "type": "uint16"
        }
      ],
      "name": "increaseObservationCardinalityNext",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "beforeOrAtRateValueRay",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "apyFromBeforeOrAtToAtOrAfterWad",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "timeDeltaBeforeOrAtToQueriedTimeWad",
          "type": "uint256"
        }
      ],
      "name": "interpolateRateValue",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "rateValueRay",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "minSecondsSinceLastUpdate",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "observations",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "blockTimestamp",
          "type": "uint32"
        },
        {
          "internalType": "uint216",
          "name": "observedValue",
          "type": "uint216"
        },
        {
          "internalType": "bool",
          "name": "initialized",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "oracleVars",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "rateIndex",
          "type": "uint16"
        },
        {
          "internalType": "uint16",
          "name": "rateCardinality",
          "type": "uint16"
        },
        {
          "internalType": "uint16",
          "name": "rateCardinalityNext",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_minSecondsSinceLastUpdate",
          "type": "uint256"
        }
      ],
      "name": "setMinSecondsSinceLastUpdate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "name": "settlementRateCache",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "underlying",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "underlyingYieldBearingProtocolID",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "termStartTimestampInWeiSeconds",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "termEndTimestampInWeiSeconds",
          "type": "uint256"
        }
      ],
      "name": "variableFactor",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "resultWad",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "termStartTimestampInWeiSeconds",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "termEndTimestampInWeiSeconds",
          "type": "uint256"
        }
      ],
      "name": "variableFactorNoCache",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "resultWad",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "writeOracleEntry",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x1d1c5e134283f6e30a1e9c418f918d05a57663a6cc504aac6e79dac834c21acb",
  "receipt": {
    "to": null,
    "from": "0xF8F6B70a36f4398f0853a311dC6699Aba8333Cc1",
    "contractAddress": "0x54B868B03c68A1307B24fB0A4b60b18A0714a94C",
    "transactionIndex": 0,
    "gasUsed": "2301298",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000002000000000000800000000000000000000000000000100400000000000000000020000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000400000000000000000000",
    "blockHash": "0xab58492440449dd9d1df106698104fb3ce1b86750d556af87a720fc6f1ac02a2",
    "transactionHash": "0x1d1c5e134283f6e30a1e9c418f918d05a57663a6cc504aac6e79dac834c21acb",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 30116774,
        "transactionHash": "0x1d1c5e134283f6e30a1e9c418f918d05a57663a6cc504aac6e79dac834c21acb",
        "address": "0x54B868B03c68A1307B24fB0A4b60b18A0714a94C",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000f8f6b70a36f4398f0853a311dc6699aba8333cc1"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0xab58492440449dd9d1df106698104fb3ce1b86750d556af87a720fc6f1ac02a2"
      }
    ],
    "blockNumber": 30116774,
    "cumulativeGasUsed": "2301298",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xE0fBa4Fc209b4948668006B2bE61711b7f465bAe",
    "0x13512979ADE267AB5100878E2e0f485B568328a4"
  ],
  "numDeployments": 1,
  "solcInputHash": "9f9566c0cdca10f3ecaa77aa61f80c3b",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_aaveLendingPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AavePoolGetReserveNormalizedIncomeReturnedZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"PRBMathUD60x18__Exp2InputTooBig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"PRBMathUD60x18__FromUintOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"PRBMathUD60x18__LogInputTooSmall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prod1\",\"type\":\"uint256\"}],\"name\":\"PRBMath__MulDivFixedPointOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prod1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"PRBMath__MulDivOverflow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"observationCardinalityNextOld\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"observationCardinalityNextNew\",\"type\":\"uint16\"}],\"name\":\"IncreaserateCardinalityNext\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_minSecondsSinceLastUpdate\",\"type\":\"uint256\"}],\"name\":\"MinSecondsSinceLastUpdateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockTimestampScaled\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"blockTimestamp\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"observedValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"cardinality\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"cardinalityNext\",\"type\":\"uint16\"}],\"name\":\"OracleBufferWrite\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ONE_WEI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aaveLendingPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"getApyFromTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"apyFromToWad\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getRateFromTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"rateCardinalityNext\",\"type\":\"uint16\"}],\"name\":\"increaseObservationCardinalityNext\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"beforeOrAtRateValueRay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"apyFromBeforeOrAtToAtOrAfterWad\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeDeltaBeforeOrAtToQueriedTimeWad\",\"type\":\"uint256\"}],\"name\":\"interpolateRateValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rateValueRay\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSecondsSinceLastUpdate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"observations\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"blockTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint216\",\"name\":\"observedValue\",\"type\":\"uint216\"},{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleVars\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"rateIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rateCardinality\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rateCardinalityNext\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minSecondsSinceLastUpdate\",\"type\":\"uint256\"}],\"name\":\"setMinSecondsSinceLastUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"settlementRateCache\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingYieldBearingProtocolID\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"termStartTimestampInWeiSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"termEndTimestampInWeiSeconds\",\"type\":\"uint256\"}],\"name\":\"variableFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"resultWad\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"termStartTimestampInWeiSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"termEndTimestampInWeiSeconds\",\"type\":\"uint256\"}],\"name\":\"variableFactorNoCache\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"resultWad\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"writeOracleEntry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"AavePoolGetReserveNormalizedIncomeReturnedZero()\":[{\"details\":\"getReserveNormalizedIncome() returned zero for underlying asset. Oracle only supports active Aave-V2 assets.\"}]},\"kind\":\"dev\",\"methods\":{\"getApyFromTo(uint256,uint256)\":{\"details\":\"Reverts if we have no data point for either timestamp\",\"params\":{\"from\":\"The timestamp of the start of the period, in seconds\",\"to\":\"The timestamp of the end of the period, in seconds\"}},\"getRateFromTo(uint256,uint256)\":{\"details\":\"Reverts if we have no data point for either timestamp\",\"params\":{\"_from\":\"The timestamp of the start of the period, in seconds\",\"_to\":\"The timestamp of the end of the period, in seconds\"},\"returns\":{\"_0\":\"The \\\"floating rate\\\" expressed in Wad, e.g. 4% is encoded as 0.04*10**18 = 4*10**16\"}},\"increaseObservationCardinalityNext(uint16)\":{\"details\":\"This method is no-op if the RateOracle already has an observationCardinalityNext greater than or equal to the input observationCardinalityNext.\",\"params\":{\"rateCardinalityNext\":\"The desired minimum number of observations for the pool to store\"}},\"interpolateRateValue(uint256,uint256,uint256)\":{\"details\":\"Given [beforeOrAt, atOrAfter] where the timestamp for which the counterfactual is calculated is within that range (but does not touch any of the bounds)We can calculate the apy for [beforeOrAt, atOrAfter] --> refer to this value as apyFromBeforeOrAtToAtOrAfterThen we want a counterfactual rate value which results in apy_before_after if the apy is calculated between [beforeOrAt, timestampForCounterfactual]Hence (1+rateValueWei/beforeOrAtRateValueWei)^(1/timeInYears) = apyFromBeforeOrAtToAtOrAfterHence rateValueWei = beforeOrAtRateValueWei * (1+apyFromBeforeOrAtToAtOrAfter)^timeInYears - 1)\",\"params\":{\"apyFromBeforeOrAtToAtOrAfterWad\":\"Apy in the period between the timestamp of the beforeOrAt Rate and the atOrAfter Rate\",\"beforeOrAtRateValueRay\":\"Rate Value (in ray) before the timestamp for which we want to calculate the counterfactual rate value\",\"timeDeltaBeforeOrAtToQueriedTimeWad\":\"Time Delta (in wei seconds) between the timestamp of the beforeOrAt Rate and the atOrAfter Rate\"},\"returns\":{\"rateValueRay\":\"Counterfactual (interpolated) rate value in ray\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"setMinSecondsSinceLastUpdate(uint256)\":{\"details\":\"Can only be set by the Factory Owner\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"variableFactor(uint256,uint256)\":{\"details\":\"If the current block timestamp is beyond the maturity of the AMM, then the variableFactor is getRateFromTo(termStartTimestamp, termEndTimestamp). Term end timestamps are cached for quick retrieval later.If the current block timestamp is before the maturity of the AMM, then the variableFactor is getRateFromTo(termStartTimestamp,Time.blockTimestampScaled());\",\"returns\":{\"resultWad\":\"The variable factor\"}},\"variableFactorNoCache(uint256,uint256)\":{\"details\":\"If the current block timestamp is beyond the maturity of the AMM, then the variableFactor is getRateFromTo(termStartTimestamp, termEndTimestamp). No caching takes place.If the current block timestamp is before the maturity of the AMM, then the variableFactor is getRateFromTo(termStartTimestamp,Time.blockTimestampScaled());\",\"returns\":{\"resultWad\":\"The variable factor\"}}},\"stateVariables\":{\"aaveLendingPool\":{\"return\":\"Address of the Aave Lending Pool\",\"returns\":{\"_0\":\"Address of the Aave Lending Pool\"}},\"underlyingYieldBearingProtocolID\":{\"return\":\"yieldBearingProtocolID unique id of the underlying yield bearing protocol\",\"returns\":{\"_0\":\"yieldBearingProtocolID unique id of the underlying yield bearing protocol\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"PRBMathUD60x18__Exp2InputTooBig(uint256)\":[{\"notice\":\"Emitted when the input is greater than 192.\"}],\"PRBMathUD60x18__FromUintOverflow(uint256)\":[{\"notice\":\"Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\"}],\"PRBMathUD60x18__LogInputTooSmall(uint256)\":[{\"notice\":\"Emitted when the input is less than 1.\"}],\"PRBMath__MulDivFixedPointOverflow(uint256)\":[{\"notice\":\"Emitted when the result overflows uint256.\"}],\"PRBMath__MulDivOverflow(uint256,uint256)\":[{\"notice\":\"Emitted when the result overflows uint256.\"}]},\"events\":{\"IncreaserateCardinalityNext(uint16,uint16)\":{\"notice\":\"Emitted by the rate oracle for increases to the number of observations that can be stored\"}},\"kind\":\"user\",\"methods\":{\"aaveLendingPool()\":{\"notice\":\"Gets the address of the Aave Lending Pool\"},\"getApyFromTo(uint256,uint256)\":{\"notice\":\"Calculates the observed APY returned by the rate oracle in a given period\"},\"getRateFromTo(uint256,uint256)\":{\"notice\":\"Calculates the observed interest returned by the underlying in a given period\"},\"increaseObservationCardinalityNext(uint16)\":{\"notice\":\"Increase the maximum number of rates observations that this RateOracle will store\"},\"interpolateRateValue(uint256,uint256,uint256)\":{\"notice\":\"Calculates the interpolated (counterfactual) rate value\"},\"observations(uint256)\":{\"notice\":\"the observations tracked over time by this oracle\"},\"setMinSecondsSinceLastUpdate(uint256)\":{\"notice\":\"Sets minSecondsSinceLastUpdate: The minimum number of seconds in wei that need to pass since the last update to the rates array\"},\"settlementRateCache(uint32,uint32)\":{\"notice\":\"a cache of settlement rates for interest rate swaps associated with this rate oracle, indexed by start time and then end time\"},\"underlying()\":{\"notice\":\"Gets the address of the underlying token of the RateOracle\"},\"underlyingYieldBearingProtocolID()\":{\"notice\":\"unique ID of the underlying yield bearing protocol (e.g. Aave v2 has id 1)\"},\"variableFactor(uint256,uint256)\":{\"notice\":\"Gets the variable factor between termStartTimestamp and termEndTimestamp\"},\"variableFactorNoCache(uint256,uint256)\":{\"notice\":\"Gets the variable factor between termStartTimestamp and termEndTimestamp\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/rate_oracles/AaveRateOracle.sol\":\"AaveRateOracle\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x24e0364e503a9bbde94c715d26573a76f14cd2a202d45f96f52134ab806b67b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa2f576be637946f767aa56601c26d717f48a0aff44f82e46f13807eea1009a21\",\"license\":\"MIT\"},\"contracts/aave/AaveDataTypes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary AaveDataTypes {\\n    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\\n    struct ReserveData {\\n        //stores the reserve configuration\\n        ReserveConfigurationMap configuration;\\n        //the liquidity index. Expressed in ray\\n        uint128 liquidityIndex;\\n        //variable borrow index. Expressed in ray\\n        uint128 variableBorrowIndex;\\n        //the current supply rate. Expressed in ray\\n        uint128 currentLiquidityRate;\\n        //the current variable borrow rate. Expressed in ray\\n        uint128 currentVariableBorrowRate;\\n        //the current stable borrow rate. Expressed in ray\\n        uint128 currentStableBorrowRate;\\n        uint40 lastUpdateTimestamp;\\n        //tokens addresses\\n        address aTokenAddress;\\n        address stableDebtTokenAddress;\\n        address variableDebtTokenAddress;\\n        //address of the interest rate strategy\\n        address interestRateStrategyAddress;\\n        //the id of the reserve. Represents the position in the list of the active reserves\\n        uint8 id;\\n    }\\n\\n    struct ReserveConfigurationMap {\\n        //bit 0-15: LTV\\n        //bit 16-31: Liq. threshold\\n        //bit 32-47: Liq. bonus\\n        //bit 48-55: Decimals\\n        //bit 56: Reserve is active\\n        //bit 57: reserve is frozen\\n        //bit 58: borrowing is enabled\\n        //bit 59: stable rate borrowing enabled\\n        //bit 60-63: reserved\\n        //bit 64-79: reserve factor\\n        uint256 data;\\n    }\\n}\\n\",\"keccak256\":\"0xfd619b7aa5608a3d6d5c80fbdc6db40e12dd7d7c1dcbf2408a0883b61e4e854f\",\"license\":\"MIT\"},\"contracts/core_libraries/FixedAndVariableMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"prb-math/contracts/PRBMathSD59x18.sol\\\";\\nimport \\\"prb-math/contracts/PRBMathUD60x18.sol\\\";\\nimport \\\"./Time.sol\\\";\\n\\n/// @title A utility library for mathematics of fixed and variable token amounts.\\nlibrary FixedAndVariableMath {\\n    /// @notice Number of wei-seconds in a year\\n    /// @dev Ignoring leap years since we're only using it to calculate the eventual APY rate\\n\\n    // suggestion: do this conversion with PRB.fromUnit()\\n    uint256 public constant SECONDS_IN_YEAR_IN_WAD = 31536000 * 10**18;\\n    uint256 public constant ONE_HUNDRED_IN_WAD = 100 * 10**18;\\n\\n    /// @notice amount0 and amount1 must have different signs\\n    error AmountSignsSame();\\n\\n    /// @notice Caclulate the remaining cashflow to settle a position\\n    /// @param fixedTokenBalance The current balance of the fixed side of the position\\n    /// @param variableTokenBalance The current balance of the variable side of the position\\n    /// @param termStartTimestampWad When did the position begin, in seconds\\n    /// @param termEndTimestampWad When does the position reach maturity, in seconds\\n    /// @param variableFactorToMaturityWad What factor expresses the current remaining variable rate, up to position maturity? (in WAD)\\n    /// @return cashflow The remaining cashflow of the position\\n    function calculateSettlementCashflow(\\n        int256 fixedTokenBalance,\\n        int256 variableTokenBalance,\\n        uint256 termStartTimestampWad,\\n        uint256 termEndTimestampWad,\\n        uint256 variableFactorToMaturityWad\\n    ) internal view returns (int256 cashflow) {\\n        /// @dev convert fixed and variable token balances to their respective fixed token representations\\n\\n        int256 fixedTokenBalanceWad = PRBMathSD59x18.fromInt(fixedTokenBalance);\\n        int256 variableTokenBalanceWad = PRBMathSD59x18.fromInt(\\n            variableTokenBalance\\n        );\\n\\n        int256 fixedCashflowWad = PRBMathSD59x18.mul(\\n            fixedTokenBalanceWad,\\n            int256(\\n                fixedFactor(true, termStartTimestampWad, termEndTimestampWad)\\n            )\\n        );\\n\\n        int256 variableCashflowWad = PRBMathSD59x18.mul(\\n            variableTokenBalanceWad,\\n            int256(variableFactorToMaturityWad)\\n        );\\n\\n        int256 cashflowWad = fixedCashflowWad + variableCashflowWad;\\n\\n        /// @dev convert back to non-fixed point representation\\n        cashflow = PRBMathSD59x18.toInt(cashflowWad);\\n    }\\n\\n    /// @notice Divide a given time in seconds by the number of seconds in a year\\n    /// @param timeInSecondsAsWad A time in seconds in Wad (i.e. scaled up by 10^18)\\n    /// @return timeInYearsWad An annualised factor of timeInSeconds, also in Wad\\n    function accrualFact(uint256 timeInSecondsAsWad)\\n        internal\\n        pure\\n        returns (uint256 timeInYearsWad)\\n    {\\n        timeInYearsWad = PRBMathUD60x18.div(\\n            timeInSecondsAsWad,\\n            SECONDS_IN_YEAR_IN_WAD\\n        );\\n    }\\n\\n    /// @notice Calculate the fixed factor for a position - that is, the percentage earned over\\n    /// the specified period of time, assuming 1% per year\\n    /// @param atMaturity Whether to calculate the factor at maturity (true), or now (false)\\n    /// @param termStartTimestampWad When does the period of time begin, in wei-seconds\\n    /// @param termEndTimestampWad When does the period of time end, in wei-seconds\\n    /// @return fixedFactorValueWad The fixed factor for the position (in Wad)\\n    function fixedFactor(\\n        bool atMaturity,\\n        uint256 termStartTimestampWad,\\n        uint256 termEndTimestampWad\\n    ) internal view returns (uint256 fixedFactorValueWad) {\\n        require(termEndTimestampWad > termStartTimestampWad, \\\"E<=S\\\");\\n\\n        require(Time.blockTimestampScaled() >= termStartTimestampWad, \\\"B.T<S\\\");\\n\\n        uint256 timeInSecondsWad;\\n\\n        if (\\n            atMaturity || (Time.blockTimestampScaled() >= termEndTimestampWad)\\n        ) {\\n            timeInSecondsWad = termEndTimestampWad - termStartTimestampWad;\\n        } else {\\n            timeInSecondsWad =\\n                Time.blockTimestampScaled() -\\n                termStartTimestampWad;\\n        }\\n\\n        uint256 timeInYearsWad = accrualFact(timeInSecondsWad);\\n        fixedFactorValueWad = PRBMathUD60x18.div(\\n            timeInYearsWad,\\n            ONE_HUNDRED_IN_WAD\\n        );\\n    }\\n\\n    /// @notice Calculate the fixed token balance for a position over a timespan\\n    /// @param amount0Wad A fixed amount\\n    /// @param excessBalanceWad Any excess balance from the variable side of the position\\n    /// @param termStartTimestampWad When does the period of time begin, in wei-seconds\\n    /// @param termEndTimestampWad When does the period of time end, in wei-seconds\\n    /// @return fixedTokenBalanceWad The fixed token balance for that time period\\n    function calculateFixedTokenBalance(\\n        int256 amount0Wad,\\n        int256 excessBalanceWad,\\n        uint256 termStartTimestampWad,\\n        uint256 termEndTimestampWad\\n    ) internal view returns (int256 fixedTokenBalanceWad) {\\n        require(termEndTimestampWad > termStartTimestampWad, \\\"E<=S\\\");\\n\\n        /// explain the math in simple terms\\n\\n        // expected fixed cashflow with unbalanced number of fixed tokens\\n        int256 exp1Wad = PRBMathSD59x18.mul(\\n            amount0Wad,\\n            int256(\\n                fixedFactor(true, termStartTimestampWad, termEndTimestampWad)\\n            )\\n        );\\n\\n        // fixed cashflow with balanced number of fixed tokens, this cashflow accounts for the excess balance accrued since\\n        // the inception of the IRS AMM\\n        int256 numeratorWad = exp1Wad - excessBalanceWad;\\n\\n        // fixed token balance that takes into account acrrued cashflows\\n        fixedTokenBalanceWad = PRBMathSD59x18.div(\\n            numeratorWad,\\n            int256(\\n                fixedFactor(true, termStartTimestampWad, termEndTimestampWad)\\n            )\\n        );\\n    }\\n\\n    /// @notice Represent excess values accrued in some period\\n    struct AccruedValues {\\n        int256 excessFixedAccruedBalanceWad;\\n        int256 excessVariableAccruedBalanceWad;\\n        int256 excessBalanceWad;\\n    }\\n\\n    /// @notice Calculate the excess balance of both sides of a position in Wad\\n    /// @param amount0Wad A fixed balance\\n    /// @param amount1Wad A variable balance\\n    /// @param accruedVariableFactorWad An annualised factor in wei-years\\n    /// @param termStartTimestampWad When does the period of time begin, in wei-seconds\\n    /// @param termEndTimestampWad When does the period of time end, in wei-seconds\\n    /// @return excessBalanceWad The excess balance in wad\\n    function getExcessBalance(\\n        int256 amount0Wad,\\n        int256 amount1Wad,\\n        uint256 accruedVariableFactorWad,\\n        uint256 termStartTimestampWad,\\n        uint256 termEndTimestampWad\\n    ) internal view returns (int256) {\\n        AccruedValues memory accruedValues;\\n\\n        accruedValues.excessFixedAccruedBalanceWad = PRBMathSD59x18.mul(\\n            amount0Wad,\\n            int256(\\n                fixedFactor(false, termStartTimestampWad, termEndTimestampWad)\\n            )\\n        );\\n\\n        accruedValues.excessVariableAccruedBalanceWad = PRBMathSD59x18.mul(\\n            amount1Wad,\\n            int256(accruedVariableFactorWad)\\n        );\\n\\n        /// @dev cashflows accrued since the inception of the IRS AMM\\n\\n        accruedValues.excessBalanceWad =\\n            accruedValues.excessFixedAccruedBalanceWad +\\n            accruedValues.excessVariableAccruedBalanceWad;\\n\\n        return accruedValues.excessBalanceWad;\\n    }\\n\\n    /// @notice Calculate the fixed token balance given both fixed and variable balances\\n    /// @param amount0 A fixed balance\\n    /// @param amount1 A variable balance\\n    /// @param accruedVariableFactorWad An annualised factor in wei-years\\n    /// @param termStartTimestampWad When does the period of time begin, in wei-seconds\\n    /// @param termEndTimestampWad When does the period of time end, in wei-seconds\\n    /// @return fixedTokenBalance The fixed token balance for that time period\\n    function getFixedTokenBalance(\\n        int256 amount0,\\n        int256 amount1,\\n        uint256 accruedVariableFactorWad,\\n        uint256 termStartTimestampWad,\\n        uint256 termEndTimestampWad\\n    ) internal view returns (int256 fixedTokenBalance) {\\n        if (\\n            !(((amount0 <= 0 && amount1 >= 0) ||\\n                (amount0 >= 0 && amount1 <= 0)) ||\\n                (amount0 == 0 && amount1 == 0))\\n        ) {\\n            revert AmountSignsSame();\\n        }\\n\\n        int256 amount0Wad = PRBMathSD59x18.fromInt(amount0);\\n        int256 amount1Wad = PRBMathSD59x18.fromInt(amount1);\\n\\n        require(termEndTimestampWad > termStartTimestampWad, \\\"E<=S\\\");\\n\\n        int256 excessBalanceWad = getExcessBalance(\\n            amount0Wad,\\n            amount1Wad,\\n            accruedVariableFactorWad,\\n            termStartTimestampWad,\\n            termEndTimestampWad\\n        );\\n\\n        int256 fixedTokenBalanceWad = calculateFixedTokenBalance(\\n            amount0Wad,\\n            excessBalanceWad,\\n            termStartTimestampWad,\\n            termEndTimestampWad\\n        );\\n\\n        fixedTokenBalance = PRBMathSD59x18.toInt(fixedTokenBalanceWad);\\n    }\\n}\\n\",\"keccak256\":\"0x639f7b110df49d70c792613a87beed88567fd3ec61db256b0282d47b69c6737c\",\"license\":\"MIT\"},\"contracts/core_libraries/Time.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"prb-math/contracts/PRBMathUD60x18.sol\\\";\\n\\nlibrary Time {\\n    uint256 private constant MAX_UINT32 = 2**32 - 1;\\n    uint256 public constant SECONDS_IN_DAY_WAD = 86400 * 10**18; /// convert into WAD via PRB\\n\\n    /// @notice Calculate block.timestamp to wei precision\\n    /// @return Current timestamp in wei-seconds (1/1e18)\\n    function blockTimestampScaled() internal view returns (uint256) {\\n        // solhint-disable-next-line not-rely-on-time\\n        return PRBMathUD60x18.fromUint(block.timestamp);\\n    }\\n\\n    /// @dev Returns the block timestamp truncated to 32 bits, checking for overflow.\\n    function blockTimestampTruncated() internal view returns (uint32) {\\n        return timestampAsUint32(block.timestamp);\\n    }\\n\\n    function timestampAsUint32(uint256 _timestamp)\\n        internal\\n        pure\\n        returns (uint32 timestamp)\\n    {\\n        require(_timestamp <= MAX_UINT32, \\\"TSOFLOW\\\");\\n        return uint32(_timestamp);\\n    }\\n\\n    function isCloseToMaturityOrBeyondMaturity(uint256 termEndTimestampWad)\\n        internal\\n        view\\n        returns (bool vammInactive)\\n    {\\n        uint256 currentTimestamp = Time.blockTimestampScaled();\\n\\n        if (currentTimestamp >= termEndTimestampWad) {\\n            vammInactive = true;\\n        } else {\\n            uint256 timeDelta = termEndTimestampWad - currentTimestamp;\\n            if (timeDelta <= SECONDS_IN_DAY_WAD) {\\n                vammInactive = true;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x26c357d7c6e1e7b33d280b45725030f70e7bacba78f95567e906d665215eb989\",\"license\":\"MIT\"},\"contracts/interfaces/IFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n/// @title The interface for the Voltz AMM Factory\\n/// @notice The AMM Factory facilitates creation of Voltz AMMs\\ninterface IFactory {\\n    event IrsInstanceDeployed(\\n        address indexed underlyingToken,\\n        address indexed rateOracle,\\n        uint256 termStartTimestampWad,\\n        uint256 termEndTimestampWad,\\n        int24 tickSpacing,\\n        address marginEngine,\\n        address vamm,\\n        address fcm\\n    );\\n\\n    event MasterFCMSet(\\n        address masterFCMAddressOld,\\n        address masterFCMAddress,\\n        uint8 yieldBearingProtocolID\\n    );\\n\\n    function setApproval(address intAddress, bool allowIntegration) external;\\n\\n    function isApproved(address _owner, address intAddress)\\n        external\\n        view\\n        returns (bool);\\n\\n    function setMasterFCM(address masterFCMAddress, address _rateOracle)\\n        external;\\n\\n    function getVAMMAddress(\\n        address _underlyingToken,\\n        address _rateOracle,\\n        uint256 _termStartTimestampWad,\\n        uint256 _termEndTimestampWad,\\n        int24 _tickSpacing\\n    ) external view returns (address);\\n\\n    function getMarginEngineAddress(\\n        address _underlyingToken,\\n        address _rateOracle,\\n        uint256 _termStartTimestampWad,\\n        uint256 _termEndTimestampWad,\\n        int24 _tickSpacing\\n    ) external view returns (address);\\n\\n    function getFCMAddress(\\n        address _underlyingToken,\\n        address _rateOracle,\\n        uint256 _termStartTimestampWad,\\n        uint256 _termEndTimestampWad,\\n        int24 _tickSpacing\\n    ) external view returns (address);\\n\\n    function masterVAMM() external view returns (address);\\n\\n    function masterMarginEngine() external view returns (address);\\n\\n    /// @notice Deploys the contracts required for a new Interest Rate Swap instance\\n    function deployIrsInstance(\\n        address _underlyingToken,\\n        address _rateOracle,\\n        uint256 _termStartTimestampWad,\\n        uint256 _termEndTimestampWad,\\n        int24 _tickSpacing\\n    )\\n        external\\n        returns (\\n            address marginEngineProxy,\\n            address vammProxy,\\n            address fcmProxy\\n        );\\n\\n    function masterFCMs(uint8 yieldBearingProtocolID)\\n        external\\n        returns (address masterFCMAddress);\\n}\\n\",\"keccak256\":\"0xac2c0042640dffc1904078ebe0fdf04670a4af93af6440f18b8716a502b517ee\",\"license\":\"GPL-2.0-or-later\"},\"contracts/interfaces/aave/IAaveV2LendingPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\nimport \\\"../../aave/AaveDataTypes.sol\\\";\\n\\ninterface IAaveV2LendingPool {\\n\\n\\n    function getReserveNormalizedIncome(address underlyingAsset) external view returns (uint256);\\n\\n    function initReserve(\\n        address asset,\\n        address aTokenAddress\\n    ) external;\\n\\n    function getReserveData(address asset) external view returns (AaveDataTypes.ReserveData memory);\\n\\n    function withdraw(\\n        address asset,\\n        uint256 amount,\\n        address to\\n    ) external returns (uint256);\\n\\n\\n}\\n\",\"keccak256\":\"0x3848d980cec548494b8f5d595f20634d4a13f6e07651d5bcc756ce56e3207d9a\",\"license\":\"MIT\"},\"contracts/interfaces/rate_oracles/IAaveRateOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../aave/IAaveV2LendingPool.sol\\\";\\nimport \\\"../rate_oracles/IRateOracle.sol\\\";\\n\\ninterface IAaveRateOracle is IRateOracle {\\n\\n    /// @notice Gets the address of the Aave Lending Pool\\n    /// @return Address of the Aave Lending Pool\\n    function aaveLendingPool() external view returns (address);\\n\\n}\",\"keccak256\":\"0x278d51877876e8ffd5a0b946ea2cfc1b4d19aa6a37d6f4e58c603cc798164156\",\"license\":\"MIT\"},\"contracts/interfaces/rate_oracles/IRateOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @dev The RateOracle is used for two purposes on the Voltz Protocol\\n/// @dev Settlement: in order to be able to settle IRS positions after the termEndTimestamp of a given AMM\\n/// @dev Margin Engine Computations: getApyFromTo is used by the MarginCalculator and MarginEngine\\n/// @dev It is necessary to produce margin requirements for Trader and Liquidity Providers\\ninterface IRateOracle {\\n\\n    // events\\n    event MinSecondsSinceLastUpdateSet(uint256 _minSecondsSinceLastUpdate);\\n    event OracleBufferWrite(\\n        uint256 blockTimestampScaled,\\n        address source,\\n        uint16 index,\\n        uint32 blockTimestamp,\\n        uint256 observedValue,\\n        uint16 cardinality,\\n        uint16 cardinalityNext\\n    );\\n\\n    /// @notice Emitted by the rate oracle for increases to the number of observations that can be stored\\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\\n    event IncreaserateCardinalityNext(\\n        uint16 observationCardinalityNextOld,\\n        uint16 observationCardinalityNextNew\\n    );\\n\\n    // view functions\\n\\n    /// @notice Gets minimum number of seconds that need to pass since the last update to the rates array\\n    /// @dev This is a throttling mechanic that needs to ensure we don't run out of space in the rates array\\n    /// @dev The maximum size of the rates array is 65535 entries\\n    // AB: as long as this doesn't affect the termEndTimestamp rateValue too much\\n    // AB: can have a different minSecondsSinceLastUpdate close to termEndTimestamp to have more granularity for settlement purposes\\n    /// @return minSecondsSinceLastUpdate in seconds\\n    function minSecondsSinceLastUpdate() external view returns (uint256);\\n\\n    /// @notice Gets the address of the underlying token of the RateOracle\\n    /// @return underlying The address of the underlying token\\n    function underlying() external view returns (address);\\n\\n    /// @notice Gets the variable factor between termStartTimestamp and termEndTimestamp\\n    /// @return result The variable factor\\n    /// @dev If the current block timestamp is beyond the maturity of the AMM, then the variableFactor is getRateFromTo(termStartTimestamp, termEndTimestamp). Term end timestamps are cached for quick retrieval later.\\n    /// @dev If the current block timestamp is before the maturity of the AMM, then the variableFactor is getRateFromTo(termStartTimestamp,Time.blockTimestampScaled());\\n    function variableFactor(uint256 termStartTimestamp, uint256 termEndTimestamp) external returns(uint256 result);\\n\\n    /// @notice Gets the variable factor between termStartTimestamp and termEndTimestamp\\n    /// @return result The variable factor\\n    /// @dev If the current block timestamp is beyond the maturity of the AMM, then the variableFactor is getRateFromTo(termStartTimestamp, termEndTimestamp). No caching takes place.\\n    /// @dev If the current block timestamp is before the maturity of the AMM, then the variableFactor is getRateFromTo(termStartTimestamp,Time.blockTimestampScaled());\\n    function variableFactorNoCache(uint256 termStartTimestamp, uint256 termEndTimestamp) external view returns(uint256 result);\\n\\n    /// @notice Calculates the observed interest returned by the underlying in a given period\\n    /// @dev Reverts if we have no data point for either timestamp\\n    /// @param from The timestamp of the start of the period, in seconds\\n    /// @param to The timestamp of the end of the period, in seconds\\n    /// @return The \\\"floating rate\\\" expressed in Wad, e.g. 4% is encoded as 0.04*10**18 = 4*10*16\\n    function getRateFromTo(uint256 from, uint256 to)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @notice Calculates the observed APY returned by the rate oracle in a given period\\n    /// @param from The timestamp of the start of the period, in seconds\\n    /// @param to The timestamp of the end of the period, in seconds\\n    /// @dev Reverts if we have no data point for either timestamp\\n    //  how is the returned rate encoded? Floating rate?\\n    function getApyFromTo(uint256 from, uint256 to)\\n        external\\n        view\\n        returns (uint256 apyFromTo);\\n\\n    // non-view functions\\n\\n    /// @notice Sets minSecondsSinceLastUpdate: The minimum number of seconds in wei that need to pass since the last update to the rates array\\n    /// @dev Can only be set by the Factory Owner\\n    function setMinSecondsSinceLastUpdate(uint256 _minSecondsSinceLastUpdate) external;\\n\\n    /// @notice Increase the maximum number of rates observations that this RateOracle will store\\n    /// @dev This method is no-op if the RateOracle already has an observationCardinalityNext greater than or equal to\\n    /// the input observationCardinalityNext.\\n    /// @param rateCardinalityNext The desired minimum number of observations for the pool to store\\n    function increaseObservationCardinalityNext(uint16 rateCardinalityNext) external;\\n\\n    /// @notice Writes a rate observation to the rates array given the current rate cardinality, rate index and rate cardinality next\\n    /// Write oracle entry is called whenever a new position is minted via the vamm or when a swap is initiated via the vamm\\n    /// That way the gas costs of Rate Oracle updates can be distributed across organic interactions with the protocol\\n    function writeOracleEntry() external;\\n\\n    /// @notice unique ID of the underlying yield bearing protocol (e.g. Aave v2 has id 1)\\n    /// @return yieldBearingProtocolID unique id of the underlying yield bearing protocol\\n    function underlyingYieldBearingProtocolID() external view returns(uint8 yieldBearingProtocolID);\\n}\\n\",\"keccak256\":\"0x637eb5529514a60f93f3f51bd61fbcc5fb8734a2a8d138908574be9126798762\",\"license\":\"MIT\"},\"contracts/rate_oracles/AaveRateOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/rate_oracles/IAaveRateOracle.sol\\\";\\nimport \\\"../interfaces/aave/IAaveV2LendingPool.sol\\\";\\nimport \\\"../core_libraries/FixedAndVariableMath.sol\\\";\\nimport \\\"../utils/WayRayMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"../rate_oracles/BaseRateOracle.sol\\\";\\n\\ncontract AaveRateOracle is BaseRateOracle, IAaveRateOracle {\\n    using SafeMath for uint256;\\n    using OracleBuffer for OracleBuffer.Observation[65535];\\n\\n    /// @dev getReserveNormalizedIncome() returned zero for underlying asset. Oracle only supports active Aave-V2 assets.\\n    error AavePoolGetReserveNormalizedIncomeReturnedZero();\\n\\n    /// @inheritdoc IAaveRateOracle\\n    address public override aaveLendingPool;\\n\\n    uint8 public constant override underlyingYieldBearingProtocolID = 1; // id of aave v2 is 1\\n\\n    constructor(address _aaveLendingPool, address underlying)\\n        BaseRateOracle(underlying)\\n    {\\n        aaveLendingPool = _aaveLendingPool;\\n        uint32 blockTimestamp = Time.blockTimestampTruncated();\\n        uint256 result = IAaveV2LendingPool(aaveLendingPool)\\n            .getReserveNormalizedIncome(underlying);\\n\\n        (\\n            oracleVars.rateCardinality,\\n            oracleVars.rateCardinalityNext\\n        ) = observations.initialize(blockTimestamp, result);\\n    }\\n\\n    /// @notice Store the Aave Lending Pool's current normalized income per unit of an underlying asset, in Ray\\n    /// @param index The index of the Observation that was most recently written to the observations buffer\\n    /// @param cardinality The number of populated elements in the observations buffer\\n    /// @param cardinalityNext The new length of the observations buffer, independent of population\\n    function writeRate(\\n        uint16 index,\\n        uint16 cardinality,\\n        uint16 cardinalityNext\\n    ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {\\n        OracleBuffer.Observation memory last = observations[index];\\n        uint32 blockTimestamp = Time.blockTimestampTruncated();\\n\\n        // early return (to increase ttl of data in the observations buffer) if we've already written an observation recently\\n        if (blockTimestamp - minSecondsSinceLastUpdate < last.blockTimestamp)\\n            return (index, cardinality);\\n\\n        uint256 resultRay = IAaveV2LendingPool(aaveLendingPool)\\n            .getReserveNormalizedIncome(underlying);\\n        if (resultRay == 0) {\\n            revert AavePoolGetReserveNormalizedIncomeReturnedZero();\\n        }\\n\\n        emit OracleBufferWrite(\\n            Time.blockTimestampScaled(),\\n            address(this),\\n            index,\\n            blockTimestamp,\\n            resultRay,\\n            cardinality,\\n            cardinalityNext\\n        );\\n\\n        return\\n            observations.write(\\n                index,\\n                blockTimestamp,\\n                resultRay,\\n                cardinality,\\n                cardinalityNext\\n            );\\n    }\\n\\n    /// @notice Calculates the observed interest returned by the underlying in a given period\\n    /// @dev Reverts if we have no data point for either timestamp\\n    /// @param _from The timestamp of the start of the period, in seconds\\n    /// @param _to The timestamp of the end of the period, in seconds\\n    /// @return The \\\"floating rate\\\" expressed in Wad, e.g. 4% is encoded as 0.04*10**18 = 4*10**16\\n    function getRateFromTo(\\n        uint256 _from,\\n        uint256 _to //  move docs to IRateOracle. Add additional parameter to use cache and implement cache.\\n    ) public view override(BaseRateOracle, IRateOracle) returns (uint256) {\\n        if (_from == _to) {\\n            return 0;\\n        }\\n\\n        // note that we have to convert aave index into \\\"floating rate\\\" for\\n        // swap calculations, e.g. an index multiple of 1.04*10**27 corresponds to\\n        // 0.04*10**27 = 4*10*25\\n        uint32 currentTime = Time.blockTimestampTruncated();\\n        uint32 from = Time.timestampAsUint32(_from);\\n        uint32 to = Time.timestampAsUint32(_to);\\n\\n        uint256 rateFromRay = observeSingle(\\n            currentTime,\\n            from,\\n            oracleVars.rateIndex,\\n            oracleVars.rateCardinality\\n        );\\n        uint256 rateToRay = observeSingle(\\n            currentTime,\\n            to,\\n            oracleVars.rateIndex,\\n            oracleVars.rateCardinality\\n        );\\n\\n        if (rateToRay > rateFromRay) {\\n            return\\n                WadRayMath.rayToWad(\\n                    WadRayMath.rayDiv(rateToRay, rateFromRay).sub(\\n                        WadRayMath.RAY\\n                    )\\n                );\\n        } else {\\n            /// is this precise, have there been instances where the aave rate is negative?\\n            return 0;\\n        }\\n    }\\n\\n    /// @notice Calculates the interpolated (counterfactual) rate value\\n    /// @param beforeOrAtRateValueRay  Rate Value (in ray) before the timestamp for which we want to calculate the counterfactual rate value\\n    /// @param apyFromBeforeOrAtToAtOrAfterWad Apy in the period between the timestamp of the beforeOrAt Rate and the atOrAfter Rate\\n    /// @param timeDeltaBeforeOrAtToQueriedTimeWad Time Delta (in wei seconds) between the timestamp of the beforeOrAt Rate and the atOrAfter Rate\\n    /// @return rateValueRay Counterfactual (interpolated) rate value in ray\\n    /// @dev Given [beforeOrAt, atOrAfter] where the timestamp for which the counterfactual is calculated is within that range (but does not touch any of the bounds)\\n    /// @dev We can calculate the apy for [beforeOrAt, atOrAfter] --> refer to this value as apyFromBeforeOrAtToAtOrAfter\\n    /// @dev Then we want a counterfactual rate value which results in apy_before_after if the apy is calculated between [beforeOrAt, timestampForCounterfactual]\\n    /// @dev Hence (1+rateValueWei/beforeOrAtRateValueWei)^(1/timeInYears) = apyFromBeforeOrAtToAtOrAfter\\n    /// @dev Hence rateValueWei = beforeOrAtRateValueWei * (1+apyFromBeforeOrAtToAtOrAfter)^timeInYears - 1)\\n    function interpolateRateValue(\\n        uint256 beforeOrAtRateValueRay,\\n        uint256 apyFromBeforeOrAtToAtOrAfterWad,\\n        uint256 timeDeltaBeforeOrAtToQueriedTimeWad\\n    ) public pure returns (uint256 rateValueRay) {\\n        uint256 timeInYearsWad = FixedAndVariableMath.accrualFact(\\n            timeDeltaBeforeOrAtToQueriedTimeWad\\n        );\\n        uint256 apyPlusOne = apyFromBeforeOrAtToAtOrAfterWad +\\n            PRBMathUD60x18.fromUint(1);\\n        uint256 factorInWad = PRBMathUD60x18.pow(apyPlusOne, timeInYearsWad);\\n        uint256 factorInRay = WadRayMath.wadToRay(factorInWad);\\n        rateValueRay = WadRayMath.rayMul(beforeOrAtRateValueRay, factorInRay);\\n    }\\n\\n    function observeSingle(\\n        uint32 currentTime,\\n        uint32 queriedTime,\\n        uint16 index,\\n        uint16 cardinality\\n    ) internal view returns (uint256 rateValueRay) {\\n        require(currentTime >= queriedTime, \\\"OOO\\\");\\n\\n        if (currentTime == queriedTime) {\\n            OracleBuffer.Observation memory rate;\\n            rate = observations[index];\\n            if (rate.blockTimestamp != currentTime) {\\n                rateValueRay = IAaveV2LendingPool(aaveLendingPool)\\n                    .getReserveNormalizedIncome(underlying);\\n            } else {\\n                rateValueRay = rate.observedValue;\\n            }\\n            return rateValueRay;\\n        }\\n\\n        uint256 currentValueRay = IAaveV2LendingPool(aaveLendingPool)\\n            .getReserveNormalizedIncome(underlying);\\n        (\\n            OracleBuffer.Observation memory beforeOrAt,\\n            OracleBuffer.Observation memory atOrAfter\\n        ) = observations.getSurroundingObservations(\\n                queriedTime,\\n                currentValueRay,\\n                index,\\n                cardinality\\n            );\\n\\n        if (queriedTime == beforeOrAt.blockTimestamp) {\\n            // we are at the left boundary\\n            rateValueRay = beforeOrAt.observedValue;\\n        } else if (queriedTime == atOrAfter.blockTimestamp) {\\n            // we are at the right boundary\\n            rateValueRay = atOrAfter.observedValue;\\n        } else {\\n            // we are in the middle\\n            // find apy between beforeOrAt and atOrAfter\\n\\n            uint256 rateFromBeforeOrAtToAtOrAfterWad;\\n\\n            // more generally, what should our terminology be to distinguish cases where we represetn a 5% APY as = 1.05 vs. 0.05? We should pick a clear terminology and be use it throughout our descriptions / Hungarian notation / user defined types.\\n\\n            if (atOrAfter.observedValue > beforeOrAt.observedValue) {\\n                uint256 rateFromBeforeOrAtToAtOrAfterRay = WadRayMath\\n                    .rayDiv(atOrAfter.observedValue, beforeOrAt.observedValue)\\n                    .sub(WadRayMath.RAY);\\n\\n                rateFromBeforeOrAtToAtOrAfterWad = WadRayMath.rayToWad(\\n                    rateFromBeforeOrAtToAtOrAfterRay\\n                );\\n            }\\n\\n            uint256 timeInYearsWad = FixedAndVariableMath.accrualFact(\\n                (atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp) *\\n                    WadRayMath.wad()\\n            );\\n\\n            uint256 apyFromBeforeOrAtToAtOrAfterWad = computeApyFromRate(\\n                rateFromBeforeOrAtToAtOrAfterWad,\\n                timeInYearsWad\\n            );\\n\\n            // interpolate rateValue for queriedTime\\n            rateValueRay = interpolateRateValue(\\n                beforeOrAt.observedValue,\\n                apyFromBeforeOrAtToAtOrAfterWad,\\n                (queriedTime - beforeOrAt.blockTimestamp) * WadRayMath.wad()\\n            );\\n        }\\n    }\\n\\n    function writeOracleEntry() external override(BaseRateOracle, IRateOracle) {\\n        // In the case of Aave, the values we write are obtained by calling IAaveV2LendingPool(aaveLendingPool).getReserveNormalizedIncome(underlying)\\n        (oracleVars.rateIndex, oracleVars.rateCardinality) = writeRate(\\n            oracleVars.rateIndex,\\n            oracleVars.rateCardinality,\\n            oracleVars.rateCardinalityNext\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x48e816d9e65b522d8e18ee639b1f13564b3882753a4eb60ee680c89dfe2e280f\",\"license\":\"MIT\"},\"contracts/rate_oracles/BaseRateOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./OracleBuffer.sol\\\";\\nimport \\\"../interfaces/rate_oracles/IRateOracle.sol\\\";\\nimport \\\"../core_libraries/FixedAndVariableMath.sol\\\";\\nimport \\\"prb-math/contracts/PRBMathUD60x18.sol\\\";\\nimport \\\"../interfaces/IFactory.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../core_libraries/Time.sol\\\";\\n\\n/// @notice Common contract base for a Rate Oracle implementation.\\n/// @dev Each specific rate oracle implementation will need to implement the virtual functions\\nabstract contract BaseRateOracle is IRateOracle, Ownable {\\n    using OracleBuffer for OracleBuffer.Observation[65535];\\n\\n    uint256 public constant ONE_WEI = 10**18;\\n\\n    /// @notice a cache of settlement rates for interest rate swaps associated with this rate oracle, indexed by start time and then end time\\n    mapping(uint32 => mapping(uint32 => uint256)) public settlementRateCache;\\n    struct OracleVars {\\n        /// @dev the most-recently updated index of the rates array\\n        uint16 rateIndex;\\n        /// @dev the current maximum number of rates that are being stored\\n        uint16 rateCardinality;\\n        /// @dev the next maximum number of rates to store, triggered in rates.write\\n        uint16 rateCardinalityNext;\\n    }\\n\\n    /// @inheritdoc IRateOracle\\n    address public immutable override underlying;\\n\\n    /// @inheritdoc IRateOracle\\n    uint256 public override minSecondsSinceLastUpdate;\\n\\n    OracleVars public oracleVars;\\n\\n    /// @notice the observations tracked over time by this oracle\\n    OracleBuffer.Observation[65535] public observations;\\n\\n    /// @inheritdoc IRateOracle\\n    function setMinSecondsSinceLastUpdate(uint256 _minSecondsSinceLastUpdate)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        minSecondsSinceLastUpdate = _minSecondsSinceLastUpdate; // in wei\\n\\n        emit MinSecondsSinceLastUpdateSet(_minSecondsSinceLastUpdate);\\n    }\\n\\n    constructor(address _underlying) {\\n        underlying = _underlying;\\n    }\\n\\n    // AB: lock the amm when calling this function?\\n    /// @inheritdoc IRateOracle\\n    function increaseObservationCardinalityNext(uint16 rateCardinalityNext)\\n        external\\n        override\\n    {\\n        uint16 rateCardinalityNextOld = oracleVars.rateCardinalityNext; // for the event\\n\\n        uint16 rateCardinalityNextNew = observations.grow(\\n            rateCardinalityNextOld,\\n            rateCardinalityNext\\n        );\\n\\n        oracleVars.rateCardinalityNext = rateCardinalityNextNew;\\n\\n        if (rateCardinalityNextOld != rateCardinalityNextNew) {\\n            emit IncreaserateCardinalityNext(\\n                rateCardinalityNextOld,\\n                rateCardinalityNextNew\\n            );\\n        }\\n    }\\n\\n    /// @notice Computes the APY based on the un-annualised rateFromTo value and timeInYears (in wei)\\n    /// @param rateFromToWad Un-annualised rate (in wei)\\n    /// @param timeInYearsWad Time in years for the period for which we want to calculate the apy (in wei)\\n    /// @return apyWad APY for a given rateFromTo and timeInYears\\n    function computeApyFromRate(uint256 rateFromToWad, uint256 timeInYearsWad)\\n        internal\\n        pure\\n        returns (uint256 apyWad)\\n    {\\n        if (rateFromToWad == 0) {\\n            return 0;\\n        }\\n        uint256 exponentWad = PRBMathUD60x18.div(ONE_WEI, timeInYearsWad);\\n        uint256 apyPlusOneWad = PRBMathUD60x18.pow(\\n            (ONE_WEI + rateFromToWad),\\n            exponentWad\\n        );\\n        apyWad = apyPlusOneWad - ONE_WEI;\\n    }\\n\\n    /// @inheritdoc IRateOracle\\n    function getRateFromTo(uint256 from, uint256 to)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256);\\n\\n    /// @inheritdoc IRateOracle\\n    function getApyFromTo(uint256 from, uint256 to)\\n        public\\n        view\\n        override\\n        returns (uint256 apyFromToWad)\\n    {\\n        require(from <= to, \\\"Misordered dates\\\");\\n\\n        uint256 rateFromToWad = getRateFromTo(from, to);\\n\\n        uint256 timeInSeconds = to - from;\\n\\n        uint256 timeInSecondsWad = PRBMathUD60x18.fromUint(timeInSeconds);\\n\\n        uint256 timeInYearsWad = FixedAndVariableMath.accrualFact(\\n            timeInSecondsWad\\n        );\\n\\n        apyFromToWad = computeApyFromRate(rateFromToWad, timeInYearsWad);\\n    }\\n\\n    /// @inheritdoc IRateOracle\\n    function variableFactor(\\n        uint256 termStartTimestampInWeiSeconds,\\n        uint256 termEndTimestampInWeiSeconds\\n    ) public override(IRateOracle) returns (uint256 resultWad) {\\n        bool cacheable;\\n        (resultWad, cacheable) = _variableFactor(\\n            termStartTimestampInWeiSeconds,\\n            termEndTimestampInWeiSeconds\\n        );\\n\\n        if (cacheable) {\\n            uint32 termStartTimestamp = Time.timestampAsUint32(\\n                PRBMathUD60x18.toUint(termStartTimestampInWeiSeconds)\\n            );\\n            uint32 termEndTimestamp = Time.timestampAsUint32(\\n                PRBMathUD60x18.toUint(termEndTimestampInWeiSeconds)\\n            );\\n\\n            settlementRateCache[termStartTimestamp][\\n                termEndTimestamp\\n            ] = resultWad;\\n        }\\n\\n        return resultWad;\\n    }\\n\\n    /// @inheritdoc IRateOracle\\n    function variableFactorNoCache(\\n        uint256 termStartTimestampInWeiSeconds,\\n        uint256 termEndTimestampInWeiSeconds\\n    ) public view override(IRateOracle) returns (uint256 resultWad) {\\n        (resultWad, ) = _variableFactor(\\n            termStartTimestampInWeiSeconds,\\n            termEndTimestampInWeiSeconds\\n        );\\n    }\\n\\n    function _variableFactor(\\n        uint256 termStartTimestampInWeiSeconds,\\n        uint256 termEndTimestampInWeiSeconds\\n    ) private view returns (uint256 resultWad, bool cacheable) {\\n        uint32 termStartTimestamp = Time.timestampAsUint32(\\n            PRBMathUD60x18.toUint(termStartTimestampInWeiSeconds)\\n        );\\n        uint32 termEndTimestamp = Time.timestampAsUint32(\\n            PRBMathUD60x18.toUint(termEndTimestampInWeiSeconds)\\n        );\\n\\n        require(termStartTimestamp > 0 && termEndTimestamp > 0, \\\"UNITS\\\");\\n        if (settlementRateCache[termStartTimestamp][termEndTimestamp] != 0) {\\n            resultWad = settlementRateCache[termStartTimestamp][\\n                termEndTimestamp\\n            ];\\n        } else if (Time.blockTimestampTruncated() >= termEndTimestamp) {\\n            resultWad = getRateFromTo(termStartTimestamp, termEndTimestamp);\\n            cacheable = true;\\n        } else {\\n            resultWad = getRateFromTo(\\n                termStartTimestamp,\\n                Time.blockTimestampTruncated()\\n            );\\n        }\\n        return (resultWad, cacheable);\\n    }\\n\\n    /// @inheritdoc IRateOracle\\n    function writeOracleEntry() external virtual override;\\n}\\n\",\"keccak256\":\"0xe4141c69adb9969188dc28f996e7200c1d16a3d701be6f1af599b59764e34c58\",\"license\":\"MIT\"},\"contracts/rate_oracles/OracleBuffer.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/// @title OracleBuffer\\n/// @notice Provides the value history needed by multiple oracle contracts\\n/// @dev Instances of stored oracle data, \\\"observations\\\", are collected in the oracle array\\n/// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the\\n/// maximum length of the oracle array. New slots will be added when the array is fully populated.\\n/// Observations are overwritten when the full length of the oracle array is populated.\\n/// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()\\nlibrary OracleBuffer {\\n    uint256 private constant MAX_UINT216 = 2**216 - 1;\\n\\n    /// @dev An Observation fits in one storage slot, keeping gas costs down and allowing `grow()` to pre-pay for gas\\n    struct Observation {\\n        // The timesamp in seconds. uint32 allows tiemstamps up to the year 2105. Future versions may wish to use uint40.\\n        uint32 blockTimestamp;\\n        /// @dev Even if observedVale is a decimal with 27 decimal places, this still allows decimal values up to 1.053122916685572e+38\\n        uint216 observedValue;\\n        bool initialized;\\n    }\\n\\n    /// @notice Creates an observation struct from the current timestamp and observed value\\n    /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows\\n    /// @param blockTimestamp The timestamp of the new observation\\n    /// @param observedValue The observed value (semantics may differ for different types of rate oracle)\\n    /// @return Observation The newly populated observation\\n    function observation(uint32 blockTimestamp, uint256 observedValue)\\n        private\\n        pure\\n        returns (Observation memory)\\n    {\\n        require(observedValue <= MAX_UINT216, \\\">216\\\");\\n        return\\n            Observation({\\n                blockTimestamp: blockTimestamp,\\n                observedValue: uint216(observedValue),\\n                initialized: true\\n            });\\n    }\\n\\n    /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array\\n    /// @param self The stored oracle array\\n    /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32\\n    /// @return cardinality The number of populated elements in the oracle array\\n    /// @return cardinalityNext The new length of the oracle array, independent of population\\n    function initialize(\\n        Observation[65535] storage self,\\n        uint32 time,\\n        uint256 observedValue\\n    ) internal returns (uint16 cardinality, uint16 cardinalityNext) {\\n        self[0] = observation(time, observedValue);\\n        return (1, 1);\\n    }\\n\\n    /// @notice Writes an oracle observation to the array\\n    /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.\\n    /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality\\n    /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.\\n    /// @param self The stored oracle array\\n    /// @param index The index of the observation that was most recently written to the observations array\\n    /// @param blockTimestamp The timestamp of the new observation\\n    /// @param observedValue The observed value (semantics may differ for different types of rate oracle)\\n    /// @param cardinality The number of populated elements in the oracle array\\n    /// @param cardinalityNext The new length of the oracle array, independent of population\\n    /// @return indexUpdated The new index of the most recently written element in the oracle array\\n    /// @return cardinalityUpdated The new cardinality of the oracle array\\n    function write(\\n        Observation[65535] storage self,\\n        uint16 index,\\n        uint32 blockTimestamp,\\n        uint256 observedValue,\\n        uint16 cardinality,\\n        uint16 cardinalityNext\\n    ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {\\n        Observation memory last = self[index];\\n\\n        // early return if we've already written an observation this block\\n        if (last.blockTimestamp == blockTimestamp) return (index, cardinality);\\n\\n        // if the conditions are right, we can bump the cardinality\\n        if (cardinalityNext > cardinality && index == (cardinality - 1)) {\\n            cardinalityUpdated = cardinalityNext;\\n        } else {\\n            cardinalityUpdated = cardinality;\\n        }\\n\\n        indexUpdated = (index + 1) % cardinalityUpdated;\\n        self[indexUpdated] = observation(blockTimestamp, observedValue);\\n    }\\n\\n    /// @notice Prepares the oracle array to store up to `next` observations\\n    /// @param self The stored oracle array\\n    /// @param current The current next cardinality of the oracle array\\n    /// @param next The proposed next cardinality which will be populated in the oracle array\\n    /// @return next The next cardinality which will be populated in the oracle array\\n    function grow(\\n        Observation[65535] storage self,\\n        uint16 current,\\n        uint16 next\\n    ) internal returns (uint16) {\\n        require(current > 0, \\\"I\\\");\\n        // no-op if the passed next value isn't greater than the current next value\\n        if (next <= current) return current;\\n        // store in each slot to prevent fresh SSTOREs in swaps\\n        // this data will not be used because the initialized boolean is still false\\n        for (uint16 i = current; i < next; i++) self[i].blockTimestamp = 1;\\n        return next;\\n    }\\n\\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.\\n    /// The result may be the same observation, or adjacent observations.\\n    /// @dev The answer must be contained in the array, used when the target is located within the stored observation\\n    /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation\\n    /// @param self The stored oracle array\\n    /// @param target The timestamp at which the reserved observation should be for\\n    /// @param index The index of the observation that was most recently written to the observations array\\n    /// @param cardinality The number of populated elements in the oracle array\\n    /// @return beforeOrAt The observation recorded before, or at, the target\\n    /// @return atOrAfter The observation recorded at, or after, the target\\n    function binarySearch(\\n        Observation[65535] storage self,\\n        uint32 target,\\n        uint16 index,\\n        uint16 cardinality\\n    )\\n        internal\\n        view\\n        returns (Observation memory beforeOrAt, Observation memory atOrAfter)\\n    {\\n        uint256 l = (index + 1) % cardinality; // oldest observation\\n        uint256 r = l + cardinality - 1; // newest observation\\n        uint256 i;\\n        while (true) {\\n            i = (l + r) / 2;\\n\\n            beforeOrAt = self[i % cardinality];\\n\\n            // we've landed on an uninitialized tick, keep searching higher (more recently)\\n            if (!beforeOrAt.initialized) {\\n                l = i + 1;\\n                continue;\\n            }\\n\\n            atOrAfter = self[(i + 1) % cardinality];\\n\\n            bool targetAtOrAfter = beforeOrAt.blockTimestamp <= target;\\n\\n            // check if we've found the answer!\\n            if (targetAtOrAfter && target <= atOrAfter.blockTimestamp) break;\\n\\n            if (!targetAtOrAfter) r = i - 1;\\n            else l = i + 1;\\n        }\\n    }\\n\\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied\\n    /// @dev Assumes there is at least 1 initialized observation.\\n    /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.\\n    /// @param self The stored oracle array\\n    /// @param target The timestamp at which the reserved observation should be for. Must be chronologically before time.\\n    /// @param currentValue The current observed value if we were writing a new observation now (semantics may differ for different types of rate oracle)\\n    /// @param index The index of the observation that was most recently written to the observations array\\n    /// @param cardinality The number of populated elements in the oracle array\\n    /// @return beforeOrAt The observation which occurred at, or before, the given timestamp\\n    /// @return atOrAfter The observation which occurred at, or after, the given timestamp\\n    function getSurroundingObservations(\\n        Observation[65535] storage self,\\n        uint32 target,\\n        uint256 currentValue,\\n        uint16 index,\\n        uint16 cardinality\\n    )\\n        internal\\n        view\\n        returns (Observation memory beforeOrAt, Observation memory atOrAfter)\\n    {\\n        // optimistically set before to the newest observation\\n        beforeOrAt = self[index];\\n\\n        // if the target is chronologically at or after the newest observation, we can early return\\n        if (beforeOrAt.blockTimestamp <= target) {\\n            if (beforeOrAt.blockTimestamp == target) {\\n                // if newest observation equals target, we're in the same block, so we can ignore atOrAfter\\n                return (beforeOrAt, atOrAfter);\\n            } else {\\n                // otherwise, we need to transform\\n                return (beforeOrAt, observation(target, currentValue));\\n            }\\n        }\\n\\n        // now, set before to the oldest observation\\n        beforeOrAt = self[(index + 1) % cardinality];\\n        if (!beforeOrAt.initialized) beforeOrAt = self[0];\\n\\n        // ensure that the target is chronologically at or after the oldest observation\\n        require(beforeOrAt.blockTimestamp <= target, \\\"OLD\\\");\\n\\n        // if we've reached this point, we have to binary search\\n        return binarySearch(self, target, index, cardinality);\\n    }\\n}\\n\",\"keccak256\":\"0x62dd32e06f342bf3d40637a377e4a16f5c5d8f6deb3b0423148e009538b0ec53\",\"license\":\"BUSL-1.1\"},\"contracts/utils/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Errors library\\n * @author Aave\\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\\n * @dev Error messages prefix glossary:\\n *  - VL = ValidationLogic\\n *  - MATH = Math libraries\\n *  - CT = Common errors between tokens (AToken, VariableDebtToken and StableDebtToken)\\n *  - AT = AToken\\n *  - SDT = StableDebtToken\\n *  - VDT = VariableDebtToken\\n *  - LP = LendingPool\\n *  - LPAPR = LendingPoolAddressesProviderRegistry\\n *  - LPC = LendingPoolConfiguration\\n *  - RL = ReserveLogic\\n *  - LPCM = LendingPoolCollateralManager\\n *  - P = Pausable\\n */\\nlibrary Errors {\\n    //common errors\\n    string public constant CALLER_NOT_POOL_ADMIN = \\\"33\\\"; // \\\"The caller must be the pool admin\\\"\\n    string public constant BORROW_ALLOWANCE_NOT_ENOUGH = \\\"59\\\"; // User borrows on behalf, but allowance are too small\\n\\n    //contract specific errors\\n    string public constant VL_INVALID_AMOUNT = \\\"1\\\"; // \\\"Amount must be greater than 0\\\"\\n    string public constant VL_NO_ACTIVE_RESERVE = \\\"2\\\"; // \\\"Action requires an active reserve\\\"\\n    string public constant VL_RESERVE_FROZEN = \\\"3\\\"; // \\\"Action cannot be performed because the reserve is frozen\\\"\\n    string public constant VL_CURRENT_AVAILABLE_LIQUIDITY_NOT_ENOUGH = \\\"4\\\"; // \\\"The current liquidity is not enough\\\"\\n    string public constant VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE = \\\"5\\\"; // \\\"User cannot withdraw more than the available balance\\\"\\n    string public constant VL_TRANSFER_NOT_ALLOWED = \\\"6\\\"; // \\\"Transfer cannot be allowed.\\\"\\n    string public constant VL_BORROWING_NOT_ENABLED = \\\"7\\\"; // \\\"Borrowing is not enabled\\\"\\n    string public constant VL_INVALID_INTEREST_RATE_MODE_SELECTED = \\\"8\\\"; // \\\"Invalid interest rate mode selected\\\"\\n    string public constant VL_COLLATERAL_BALANCE_IS_0 = \\\"9\\\"; // \\\"The collateral balance is 0\\\"\\n    string public constant VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD =\\n        \\\"10\\\"; // \\\"Health factor is lesser than the liquidation threshold\\\"\\n    string public constant VL_COLLATERAL_CANNOT_COVER_NEW_BORROW = \\\"11\\\"; // \\\"There is not enough collateral to cover a new borrow\\\"\\n    string public constant VL_STABLE_BORROWING_NOT_ENABLED = \\\"12\\\"; // stable borrowing not enabled\\n    string public constant VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY = \\\"13\\\"; // collateral is (mostly) the same currency that is being borrowed\\n    string public constant VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = \\\"14\\\"; // \\\"The requested amount is greater than the max loan size in stable rate mode\\n    string public constant VL_NO_DEBT_OF_SELECTED_TYPE = \\\"15\\\"; // \\\"for repayment of stable debt, the user needs to have stable debt, otherwise, he needs to have variable debt\\\"\\n    string public constant VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = \\\"16\\\"; // \\\"To repay on behalf of an user an explicit amount to repay is needed\\\"\\n    string public constant VL_NO_STABLE_RATE_LOAN_IN_RESERVE = \\\"17\\\"; // \\\"User does not have a stable rate loan in progress on this reserve\\\"\\n    string public constant VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE = \\\"18\\\"; // \\\"User does not have a variable rate loan in progress on this reserve\\\"\\n    string public constant VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0 = \\\"19\\\"; // \\\"The underlying balance needs to be greater than 0\\\"\\n    string public constant VL_DEPOSIT_ALREADY_IN_USE = \\\"20\\\"; // \\\"User deposit is already being used as collateral\\\"\\n    string public constant LP_NOT_ENOUGH_STABLE_BORROW_BALANCE = \\\"21\\\"; // \\\"User does not have any stable rate loan for this reserve\\\"\\n    string public constant LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = \\\"22\\\"; // \\\"Interest rate rebalance conditions were not met\\\"\\n    string public constant LP_LIQUIDATION_CALL_FAILED = \\\"23\\\"; // \\\"Liquidation call failed\\\"\\n    string public constant LP_NOT_ENOUGH_LIQUIDITY_TO_BORROW = \\\"24\\\"; // \\\"There is not enough liquidity available to borrow\\\"\\n    string public constant LP_REQUESTED_AMOUNT_TOO_SMALL = \\\"25\\\"; // \\\"The requested amount is too small for a FlashLoan.\\\"\\n    string public constant LP_INCONSISTENT_PROTOCOL_ACTUAL_BALANCE = \\\"26\\\"; // \\\"The actual balance of the protocol is inconsistent\\\"\\n    string public constant LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR = \\\"27\\\"; // \\\"The caller of the function is not the lending pool configurator\\\"\\n    string public constant LP_INCONSISTENT_FLASHLOAN_PARAMS = \\\"28\\\";\\n    string public constant CT_CALLER_MUST_BE_LENDING_POOL = \\\"29\\\"; // \\\"The caller of this function must be a lending pool\\\"\\n    string public constant CT_CANNOT_GIVE_ALLOWANCE_TO_HIMSELF = \\\"30\\\"; // \\\"User cannot give allowance to himself\\\"\\n    string public constant CT_TRANSFER_AMOUNT_NOT_GT_0 = \\\"31\\\"; // \\\"Transferred amount needs to be greater than zero\\\"\\n    string public constant RL_RESERVE_ALREADY_INITIALIZED = \\\"32\\\"; // \\\"Reserve has already been initialized\\\"\\n    string public constant LPC_RESERVE_LIQUIDITY_NOT_0 = \\\"34\\\"; // \\\"The liquidity of the reserve needs to be 0\\\"\\n    string public constant LPC_INVALID_ATOKEN_POOL_ADDRESS = \\\"35\\\"; // \\\"The liquidity of the reserve needs to be 0\\\"\\n    string public constant LPC_INVALID_STABLE_DEBT_TOKEN_POOL_ADDRESS = \\\"36\\\"; // \\\"The liquidity of the reserve needs to be 0\\\"\\n    string public constant LPC_INVALID_VARIABLE_DEBT_TOKEN_POOL_ADDRESS = \\\"37\\\"; // \\\"The liquidity of the reserve needs to be 0\\\"\\n    string public constant LPC_INVALID_STABLE_DEBT_TOKEN_UNDERLYING_ADDRESS =\\n        \\\"38\\\"; // \\\"The liquidity of the reserve needs to be 0\\\"\\n    string public constant LPC_INVALID_VARIABLE_DEBT_TOKEN_UNDERLYING_ADDRESS =\\n        \\\"39\\\"; // \\\"The liquidity of the reserve needs to be 0\\\"\\n    string public constant LPC_INVALID_ADDRESSES_PROVIDER_ID = \\\"40\\\"; // \\\"The liquidity of the reserve needs to be 0\\\"\\n    string public constant LPC_INVALID_CONFIGURATION = \\\"75\\\"; // \\\"Invalid risk parameters for the reserve\\\"\\n    string public constant LPC_CALLER_NOT_EMERGENCY_ADMIN = \\\"76\\\"; // \\\"The caller must be the emergency admin\\\"\\n    string public constant LPAPR_PROVIDER_NOT_REGISTERED = \\\"41\\\"; // \\\"Provider is not registered\\\"\\n    string public constant LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD = \\\"42\\\"; // \\\"Health factor is not below the threshold\\\"\\n    string public constant LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED = \\\"43\\\"; // \\\"The collateral chosen cannot be liquidated\\\"\\n    string public constant LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = \\\"44\\\"; // \\\"User did not borrow the specified currency\\\"\\n    string public constant LPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE = \\\"45\\\"; // \\\"There isn\\\"t enough liquidity available to liquidate\\\"\\n    string public constant LPCM_NO_ERRORS = \\\"46\\\"; // \\\"No errors\\\"\\n    string public constant LP_INVALID_FLASHLOAN_MODE = \\\"47\\\"; //Invalid flashloan mode selected\\n    string public constant MATH_MULTIPLICATION_OVERFLOW = \\\"48\\\";\\n    string public constant MATH_ADDITION_OVERFLOW = \\\"49\\\";\\n    string public constant MATH_DIVISION_BY_ZERO = \\\"50\\\";\\n    string public constant RL_LIQUIDITY_INDEX_OVERFLOW = \\\"51\\\"; //  Liquidity index overflows uint128\\n    string public constant RL_VARIABLE_BORROW_INDEX_OVERFLOW = \\\"52\\\"; //  Variable borrow index overflows uint128\\n    string public constant RL_LIQUIDITY_RATE_OVERFLOW = \\\"53\\\"; //  Liquidity rate overflows uint128\\n    string public constant RL_VARIABLE_BORROW_RATE_OVERFLOW = \\\"54\\\"; //  Variable borrow rate overflows uint128\\n    string public constant RL_STABLE_BORROW_RATE_OVERFLOW = \\\"55\\\"; //  Stable borrow rate overflows uint128\\n    string public constant CT_INVALID_MINT_AMOUNT = \\\"56\\\"; //invalid amount to mint\\n    string public constant LP_FAILED_REPAY_WITH_COLLATERAL = \\\"57\\\";\\n    string public constant CT_INVALID_BURN_AMOUNT = \\\"58\\\"; //invalid amount to burn\\n    string public constant LP_FAILED_COLLATERAL_SWAP = \\\"60\\\";\\n    string public constant LP_INVALID_EQUAL_ASSETS_TO_SWAP = \\\"61\\\";\\n    string public constant LP_REENTRANCY_NOT_ALLOWED = \\\"62\\\";\\n    string public constant LP_CALLER_MUST_BE_AN_ATOKEN = \\\"63\\\";\\n    string public constant LP_IS_PAUSED = \\\"64\\\"; // \\\"Pool is paused\\\"\\n    string public constant LP_NO_MORE_RESERVES_ALLOWED = \\\"65\\\";\\n    string public constant LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN = \\\"66\\\";\\n    string public constant RC_INVALID_LTV = \\\"67\\\";\\n    string public constant RC_INVALID_LIQ_THRESHOLD = \\\"68\\\";\\n    string public constant RC_INVALID_LIQ_BONUS = \\\"69\\\";\\n    string public constant RC_INVALID_DECIMALS = \\\"70\\\";\\n    string public constant RC_INVALID_RESERVE_FACTOR = \\\"71\\\";\\n    string public constant LPAPR_INVALID_ADDRESSES_PROVIDER_ID = \\\"72\\\";\\n    string public constant VL_INCONSISTENT_FLASHLOAN_PARAMS = \\\"73\\\";\\n    string public constant LP_INCONSISTENT_PARAMS_LENGTH = \\\"74\\\";\\n    string public constant UL_INVALID_INDEX = \\\"77\\\";\\n    string public constant LP_NOT_CONTRACT = \\\"78\\\";\\n    string public constant SDT_STABLE_DEBT_OVERFLOW = \\\"79\\\";\\n    string public constant SDT_BURN_EXCEEDS_BALANCE = \\\"80\\\";\\n\\n    enum CollateralManagerErrors {\\n        NO_ERROR,\\n        NO_COLLATERAL_AVAILABLE,\\n        COLLATERAL_CANNOT_BE_LIQUIDATED,\\n        CURRRENCY_NOT_BORROWED,\\n        HEALTH_FACTOR_ABOVE_THRESHOLD,\\n        NOT_ENOUGH_LIQUIDITY,\\n        NO_ACTIVE_RESERVE,\\n        HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD,\\n        INVALID_EQUAL_ASSETS_TO_SWAP,\\n        FROZEN_RESERVE\\n    }\\n}\\n\",\"keccak256\":\"0x3709bc7d5a8d2c2912509f0276a7c1bb767ec8374b2cba39eb9f489d279f3f77\",\"license\":\"MIT\"},\"contracts/utils/WayRayMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable const-name-snakecase\\n\\npragma solidity ^0.8.0;\\nimport \\\"./Errors.sol\\\";\\n\\n/**\\n * @title WadRayMath library\\n * @author Aave\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\n **/\\n\\nlibrary WadRayMath {\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant halfWAD = WAD / 2;\\n\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant halfRAY = RAY / 2;\\n\\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n    /**\\n     * @return One ray, 1e27\\n     **/\\n    function ray() internal pure returns (uint256) {\\n        return RAY;\\n    }\\n\\n    /**\\n     * @return One wad, 1e18\\n     **/\\n\\n    function wad() internal pure returns (uint256) {\\n        return WAD;\\n    }\\n\\n    /**\\n     * @return Half ray, 1e27/2\\n     **/\\n    function halfRay() internal pure returns (uint256) {\\n        return halfRAY;\\n    }\\n\\n    /**\\n     * @return Half ray, 1e18/2\\n     **/\\n    function halfWad() internal pure returns (uint256) {\\n        return halfWAD;\\n    }\\n\\n    /**\\n     * @dev Multiplies two wad, rounding half up to the nearest wad\\n     * @param a Wad\\n     * @param b Wad\\n     * @return The result of a*b, in wad\\n     **/\\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0 || b == 0) {\\n            return 0;\\n        }\\n\\n        require(\\n            a <= (type(uint256).max - halfWAD) / b,\\n            Errors.MATH_MULTIPLICATION_OVERFLOW\\n        );\\n\\n        return (a * b + halfWAD) / WAD;\\n    }\\n\\n    /**\\n     * @dev Divides two wad, rounding half up to the nearest wad\\n     * @param a Wad\\n     * @param b Wad\\n     * @return The result of a/b, in wad\\n     **/\\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\\n        uint256 halfB = b / 2;\\n\\n        require(\\n            a <= (type(uint256).max - halfB) / WAD,\\n            Errors.MATH_MULTIPLICATION_OVERFLOW\\n        );\\n\\n        return (a * WAD + halfB) / b;\\n    }\\n\\n    /**\\n     * @dev Multiplies two ray, rounding half up to the nearest ray\\n     * @param a Ray\\n     * @param b Ray\\n     * @return The result of a*b, in ray\\n     **/\\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0 || b == 0) {\\n            return 0;\\n        }\\n\\n        require(\\n            a <= (type(uint256).max - halfRAY) / b,\\n            Errors.MATH_MULTIPLICATION_OVERFLOW\\n        );\\n\\n        return (a * b + halfRAY) / RAY;\\n    }\\n\\n    /**\\n     * @dev Divides two ray, rounding half up to the nearest ray\\n     * @param a Ray\\n     * @param b Ray\\n     * @return The result of a/b, in ray\\n     **/\\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\\n        uint256 halfB = b / 2;\\n\\n        require(\\n            a <= (type(uint256).max - halfB) / RAY,\\n            Errors.MATH_MULTIPLICATION_OVERFLOW\\n        );\\n\\n        return (a * RAY + halfB) / b;\\n    }\\n\\n    /**\\n     * @dev Casts ray down to wad\\n     * @param a Ray\\n     * @return a casted to wad, rounded half up to the nearest wad\\n     **/\\n    function rayToWad(uint256 a) internal pure returns (uint256) {\\n        uint256 halfRatio = WAD_RAY_RATIO / 2;\\n        uint256 result = halfRatio + a;\\n        require(result >= halfRatio, Errors.MATH_ADDITION_OVERFLOW);\\n\\n        return result / WAD_RAY_RATIO;\\n    }\\n\\n    /**\\n     * @dev Converts wad up to ray\\n     * @param a Wad\\n     * @return a converted in ray\\n     **/\\n    function wadToRay(uint256 a) internal pure returns (uint256) {\\n        uint256 result = a * WAD_RAY_RATIO;\\n        require(\\n            result / WAD_RAY_RATIO == a,\\n            Errors.MATH_MULTIPLICATION_OVERFLOW\\n        );\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x2270639ea4ac5dab81b7ee25aeefec998fa2c6ed3afbba8fe672d2bae11ccb31\",\"license\":\"MIT\"},\"prb-math/contracts/PRBMath.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\n/// @notice Emitted when the result overflows uint256.\\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\\n\\n/// @notice Emitted when the result overflows uint256.\\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\\n\\n/// @notice Emitted when one of the inputs is type(int256).min.\\nerror PRBMath__MulDivSignedInputTooSmall();\\n\\n/// @notice Emitted when the intermediary absolute result overflows int256.\\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is MIN_SD59x18.\\nerror PRBMathSD59x18__AbsInputTooSmall();\\n\\n/// @notice Emitted when ceiling a number overflows SD59x18.\\nerror PRBMathSD59x18__CeilOverflow(int256 x);\\n\\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\\nerror PRBMathSD59x18__DivInputTooSmall();\\n\\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is greater than 133.084258667509499441.\\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\\n\\n/// @notice Emitted when the input is greater than 192.\\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\\n\\n/// @notice Emitted when flooring a number underflows SD59x18.\\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\\n\\n/// @notice Emitted when the product of the inputs is negative.\\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\\n\\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\\n\\n/// @notice Emitted when the input is less than or equal to zero.\\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\\n\\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\\nerror PRBMathSD59x18__MulInputTooSmall();\\n\\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is negative.\\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\\n\\n/// @notice Emitted when the calculating the square root overflows SD59x18.\\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\\n\\n/// @notice Emitted when addition overflows UD60x18.\\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\\n\\n/// @notice Emitted when ceiling a number overflows UD60x18.\\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\\n\\n/// @notice Emitted when the input is greater than 133.084258667509499441.\\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\\n\\n/// @notice Emitted when the input is greater than 192.\\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\\n\\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\\n\\n/// @notice Emitted when the input is less than 1.\\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\\n\\n/// @notice Emitted when the calculating the square root overflows UD60x18.\\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\\n\\n/// @notice Emitted when subtraction underflows UD60x18.\\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\\n\\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\\nlibrary PRBMath {\\n    /// STRUCTS ///\\n\\n    struct SD59x18 {\\n        int256 value;\\n    }\\n\\n    struct UD60x18 {\\n        uint256 value;\\n    }\\n\\n    /// STORAGE ///\\n\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n    /// @dev Largest power of two divisor of SCALE.\\n    uint256 internal constant SCALE_LPOTD = 262144;\\n\\n    /// @dev SCALE inverted mod 2^256.\\n    uint256 internal constant SCALE_INVERSE =\\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\\n\\n    /// FUNCTIONS ///\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    /// @dev Has to use 192.64-bit fixed-point numbers.\\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp2(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            // Start from 0.5 in the 192.64-bit fixed-point format.\\n            result = 0x800000000000000000000000000000000000000000000000;\\n\\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\\n            if (x & 0x8000000000000000 > 0) {\\n                result = (result * 0x16A09E667F3BCC909) >> 64;\\n            }\\n            if (x & 0x4000000000000000 > 0) {\\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\\n            }\\n            if (x & 0x2000000000000000 > 0) {\\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\\n            }\\n            if (x & 0x1000000000000000 > 0) {\\n                result = (result * 0x10B5586CF9890F62A) >> 64;\\n            }\\n            if (x & 0x800000000000000 > 0) {\\n                result = (result * 0x1059B0D31585743AE) >> 64;\\n            }\\n            if (x & 0x400000000000000 > 0) {\\n                result = (result * 0x102C9A3E778060EE7) >> 64;\\n            }\\n            if (x & 0x200000000000000 > 0) {\\n                result = (result * 0x10163DA9FB33356D8) >> 64;\\n            }\\n            if (x & 0x100000000000000 > 0) {\\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\\n            }\\n            if (x & 0x80000000000000 > 0) {\\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\\n            }\\n            if (x & 0x40000000000000 > 0) {\\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\\n            }\\n            if (x & 0x20000000000000 > 0) {\\n                result = (result * 0x100162F3904051FA1) >> 64;\\n            }\\n            if (x & 0x10000000000000 > 0) {\\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\\n            }\\n            if (x & 0x8000000000000 > 0) {\\n                result = (result * 0x100058BA01FB9F96D) >> 64;\\n            }\\n            if (x & 0x4000000000000 > 0) {\\n                result = (result * 0x10002C5CC37DA9492) >> 64;\\n            }\\n            if (x & 0x2000000000000 > 0) {\\n                result = (result * 0x1000162E525EE0547) >> 64;\\n            }\\n            if (x & 0x1000000000000 > 0) {\\n                result = (result * 0x10000B17255775C04) >> 64;\\n            }\\n            if (x & 0x800000000000 > 0) {\\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\\n            }\\n            if (x & 0x400000000000 > 0) {\\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\\n            }\\n            if (x & 0x200000000000 > 0) {\\n                result = (result * 0x10000162E43F4F831) >> 64;\\n            }\\n            if (x & 0x100000000000 > 0) {\\n                result = (result * 0x100000B1721BCFC9A) >> 64;\\n            }\\n            if (x & 0x80000000000 > 0) {\\n                result = (result * 0x10000058B90CF1E6E) >> 64;\\n            }\\n            if (x & 0x40000000000 > 0) {\\n                result = (result * 0x1000002C5C863B73F) >> 64;\\n            }\\n            if (x & 0x20000000000 > 0) {\\n                result = (result * 0x100000162E430E5A2) >> 64;\\n            }\\n            if (x & 0x10000000000 > 0) {\\n                result = (result * 0x1000000B172183551) >> 64;\\n            }\\n            if (x & 0x8000000000 > 0) {\\n                result = (result * 0x100000058B90C0B49) >> 64;\\n            }\\n            if (x & 0x4000000000 > 0) {\\n                result = (result * 0x10000002C5C8601CC) >> 64;\\n            }\\n            if (x & 0x2000000000 > 0) {\\n                result = (result * 0x1000000162E42FFF0) >> 64;\\n            }\\n            if (x & 0x1000000000 > 0) {\\n                result = (result * 0x10000000B17217FBB) >> 64;\\n            }\\n            if (x & 0x800000000 > 0) {\\n                result = (result * 0x1000000058B90BFCE) >> 64;\\n            }\\n            if (x & 0x400000000 > 0) {\\n                result = (result * 0x100000002C5C85FE3) >> 64;\\n            }\\n            if (x & 0x200000000 > 0) {\\n                result = (result * 0x10000000162E42FF1) >> 64;\\n            }\\n            if (x & 0x100000000 > 0) {\\n                result = (result * 0x100000000B17217F8) >> 64;\\n            }\\n            if (x & 0x80000000 > 0) {\\n                result = (result * 0x10000000058B90BFC) >> 64;\\n            }\\n            if (x & 0x40000000 > 0) {\\n                result = (result * 0x1000000002C5C85FE) >> 64;\\n            }\\n            if (x & 0x20000000 > 0) {\\n                result = (result * 0x100000000162E42FF) >> 64;\\n            }\\n            if (x & 0x10000000 > 0) {\\n                result = (result * 0x1000000000B17217F) >> 64;\\n            }\\n            if (x & 0x8000000 > 0) {\\n                result = (result * 0x100000000058B90C0) >> 64;\\n            }\\n            if (x & 0x4000000 > 0) {\\n                result = (result * 0x10000000002C5C860) >> 64;\\n            }\\n            if (x & 0x2000000 > 0) {\\n                result = (result * 0x1000000000162E430) >> 64;\\n            }\\n            if (x & 0x1000000 > 0) {\\n                result = (result * 0x10000000000B17218) >> 64;\\n            }\\n            if (x & 0x800000 > 0) {\\n                result = (result * 0x1000000000058B90C) >> 64;\\n            }\\n            if (x & 0x400000 > 0) {\\n                result = (result * 0x100000000002C5C86) >> 64;\\n            }\\n            if (x & 0x200000 > 0) {\\n                result = (result * 0x10000000000162E43) >> 64;\\n            }\\n            if (x & 0x100000 > 0) {\\n                result = (result * 0x100000000000B1721) >> 64;\\n            }\\n            if (x & 0x80000 > 0) {\\n                result = (result * 0x10000000000058B91) >> 64;\\n            }\\n            if (x & 0x40000 > 0) {\\n                result = (result * 0x1000000000002C5C8) >> 64;\\n            }\\n            if (x & 0x20000 > 0) {\\n                result = (result * 0x100000000000162E4) >> 64;\\n            }\\n            if (x & 0x10000 > 0) {\\n                result = (result * 0x1000000000000B172) >> 64;\\n            }\\n            if (x & 0x8000 > 0) {\\n                result = (result * 0x100000000000058B9) >> 64;\\n            }\\n            if (x & 0x4000 > 0) {\\n                result = (result * 0x10000000000002C5D) >> 64;\\n            }\\n            if (x & 0x2000 > 0) {\\n                result = (result * 0x1000000000000162E) >> 64;\\n            }\\n            if (x & 0x1000 > 0) {\\n                result = (result * 0x10000000000000B17) >> 64;\\n            }\\n            if (x & 0x800 > 0) {\\n                result = (result * 0x1000000000000058C) >> 64;\\n            }\\n            if (x & 0x400 > 0) {\\n                result = (result * 0x100000000000002C6) >> 64;\\n            }\\n            if (x & 0x200 > 0) {\\n                result = (result * 0x10000000000000163) >> 64;\\n            }\\n            if (x & 0x100 > 0) {\\n                result = (result * 0x100000000000000B1) >> 64;\\n            }\\n            if (x & 0x80 > 0) {\\n                result = (result * 0x10000000000000059) >> 64;\\n            }\\n            if (x & 0x40 > 0) {\\n                result = (result * 0x1000000000000002C) >> 64;\\n            }\\n            if (x & 0x20 > 0) {\\n                result = (result * 0x10000000000000016) >> 64;\\n            }\\n            if (x & 0x10 > 0) {\\n                result = (result * 0x1000000000000000B) >> 64;\\n            }\\n            if (x & 0x8 > 0) {\\n                result = (result * 0x10000000000000006) >> 64;\\n            }\\n            if (x & 0x4 > 0) {\\n                result = (result * 0x10000000000000003) >> 64;\\n            }\\n            if (x & 0x2 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n            if (x & 0x1 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n\\n            // We're doing two things at the same time:\\n            //\\n            //   1. Multiply the result by 2^n + 1, where \\\"2^n\\\" is the integer part and the one is added to account for\\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\\n            //      rather than 192.\\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\\n            //\\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \\\"ip\\\" is the integer part \\\"2^n\\\".\\n            result *= SCALE;\\n            result >>= (191 - (x >> 64));\\n        }\\n    }\\n\\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n    /// @dev See the note on msb in the \\\"Find First Set\\\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n    /// @param x The uint256 number for which to find the index of the most significant bit.\\n    /// @return msb The index of the most significant bit as an uint256.\\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n        if (x >= 2**128) {\\n            x >>= 128;\\n            msb += 128;\\n        }\\n        if (x >= 2**64) {\\n            x >>= 64;\\n            msb += 64;\\n        }\\n        if (x >= 2**32) {\\n            x >>= 32;\\n            msb += 32;\\n        }\\n        if (x >= 2**16) {\\n            x >>= 16;\\n            msb += 16;\\n        }\\n        if (x >= 2**8) {\\n            x >>= 8;\\n            msb += 8;\\n        }\\n        if (x >= 2**4) {\\n            x >>= 4;\\n            msb += 4;\\n        }\\n        if (x >= 2**2) {\\n            x >>= 2;\\n            msb += 2;\\n        }\\n        if (x >= 2**1) {\\n            // No need to shift x any more.\\n            msb += 1;\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\\u00f7denominator) with full precision.\\n    ///\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\\n    ///\\n    /// Requirements:\\n    /// - The denominator cannot be zero.\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The multiplicand as an uint256.\\n    /// @param y The multiplier as an uint256.\\n    /// @param denominator The divisor as an uint256.\\n    /// @return result The result as an uint256.\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2^256 + prod0.\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division.\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = prod0 / denominator;\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n        if (prod1 >= denominator) {\\n            revert PRBMath__MulDivOverflow(prod1, denominator);\\n        }\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0].\\n        uint256 remainder;\\n        assembly {\\n            // Compute remainder using mulmod.\\n            remainder := mulmod(x, y, denominator)\\n\\n            // Subtract 256 bit number from 512 bit number.\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n        // See https://cs.stackexchange.com/q/138556/92363.\\n        unchecked {\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 lpotdod = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by lpotdod.\\n                denominator := div(denominator, lpotdod)\\n\\n                // Divide [prod1 prod0] by lpotdod.\\n                prod0 := div(prod0, lpotdod)\\n\\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * lpotdod;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\\u00f71e18) with full precision.\\n    ///\\n    /// @dev Variant of \\\"mulDiv\\\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\\n    /// being rounded to 1e-18.  See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717.\\n    ///\\n    /// Requirements:\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - The body is purposely left uncommented; see the NatSpec comments in \\\"PRBMath.mulDiv\\\" to understand how this works.\\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\\n    ///     1. x * y = type(uint256).max * SCALE\\n    ///     2. (x * y) % SCALE >= SCALE / 2\\n    ///\\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        uint256 prod0;\\n        uint256 prod1;\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        if (prod1 >= SCALE) {\\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\\n        }\\n\\n        uint256 remainder;\\n        uint256 roundUpUnit;\\n        assembly {\\n            remainder := mulmod(x, y, SCALE)\\n            roundUpUnit := gt(remainder, 499999999999999999)\\n        }\\n\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = (prod0 / SCALE) + roundUpUnit;\\n                return result;\\n            }\\n        }\\n\\n        assembly {\\n            result := add(\\n                mul(\\n                    or(\\n                        div(sub(prod0, remainder), SCALE_LPOTD),\\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\\n                    ),\\n                    SCALE_INVERSE\\n                ),\\n                roundUpUnit\\n            )\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\\u00f7denominator) with full precision.\\n    ///\\n    /// @dev An extension of \\\"mulDiv\\\" for signed numbers. Works by computing the signs and the absolute values separately.\\n    ///\\n    /// Requirements:\\n    /// - None of the inputs can be type(int256).min.\\n    /// - The result must fit within int256.\\n    ///\\n    /// @param x The multiplicand as an int256.\\n    /// @param y The multiplier as an int256.\\n    /// @param denominator The divisor as an int256.\\n    /// @return result The result as an int256.\\n    function mulDivSigned(\\n        int256 x,\\n        int256 y,\\n        int256 denominator\\n    ) internal pure returns (int256 result) {\\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\\n            revert PRBMath__MulDivSignedInputTooSmall();\\n        }\\n\\n        // Get hold of the absolute values of x, y and the denominator.\\n        uint256 ax;\\n        uint256 ay;\\n        uint256 ad;\\n        unchecked {\\n            ax = x < 0 ? uint256(-x) : uint256(x);\\n            ay = y < 0 ? uint256(-y) : uint256(y);\\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\\n        }\\n\\n        // Compute the absolute value of (x*y)\\u00f7denominator. The result must fit within int256.\\n        uint256 rAbs = mulDiv(ax, ay, ad);\\n        if (rAbs > uint256(type(int256).max)) {\\n            revert PRBMath__MulDivSignedOverflow(rAbs);\\n        }\\n\\n        // Get the signs of x, y and the denominator.\\n        uint256 sx;\\n        uint256 sy;\\n        uint256 sd;\\n        assembly {\\n            sx := sgt(x, sub(0, 1))\\n            sy := sgt(y, sub(0, 1))\\n            sd := sgt(denominator, sub(0, 1))\\n        }\\n\\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\\n        // If yes, the result should be negative.\\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The uint256 number for which to calculate the square root.\\n    /// @return result The result as an uint256.\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\\n        uint256 xAux = uint256(x);\\n        result = 1;\\n        if (xAux >= 0x100000000000000000000000000000000) {\\n            xAux >>= 128;\\n            result <<= 64;\\n        }\\n        if (xAux >= 0x10000000000000000) {\\n            xAux >>= 64;\\n            result <<= 32;\\n        }\\n        if (xAux >= 0x100000000) {\\n            xAux >>= 32;\\n            result <<= 16;\\n        }\\n        if (xAux >= 0x10000) {\\n            xAux >>= 16;\\n            result <<= 8;\\n        }\\n        if (xAux >= 0x100) {\\n            xAux >>= 8;\\n            result <<= 4;\\n        }\\n        if (xAux >= 0x10) {\\n            xAux >>= 4;\\n            result <<= 2;\\n        }\\n        if (xAux >= 0x8) {\\n            result <<= 1;\\n        }\\n\\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\\n        unchecked {\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1; // Seven iterations should be enough\\n            uint256 roundedDownResult = x / result;\\n            return result >= roundedDownResult ? roundedDownResult : result;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xed164c95012964f5e125b5d2b2d00471a4bdee4def618cd1fcf341d196011b61\",\"license\":\"Unlicense\"},\"prb-math/contracts/PRBMathSD59x18.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\nimport \\\"./PRBMath.sol\\\";\\n\\n/// @title PRBMathSD59x18\\n/// @author Paul Razvan Berg\\n/// @notice Smart contract library for advanced fixed-point math that works with int256 numbers considered to have 18\\n/// trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have\\n/// a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers\\n/// are bound by the minimum and the maximum values permitted by the Solidity type int256.\\nlibrary PRBMathSD59x18 {\\n    /// @dev log2(e) as a signed 59.18-decimal fixed-point number.\\n    int256 internal constant LOG2_E = 1_442695040888963407;\\n\\n    /// @dev Half the SCALE number.\\n    int256 internal constant HALF_SCALE = 5e17;\\n\\n    /// @dev The maximum value a signed 59.18-decimal fixed-point number can have.\\n    int256 internal constant MAX_SD59x18 =\\n        57896044618658097711785492504343953926634992332820282019728_792003956564819967;\\n\\n    /// @dev The maximum whole value a signed 59.18-decimal fixed-point number can have.\\n    int256 internal constant MAX_WHOLE_SD59x18 =\\n        57896044618658097711785492504343953926634992332820282019728_000000000000000000;\\n\\n    /// @dev The minimum value a signed 59.18-decimal fixed-point number can have.\\n    int256 internal constant MIN_SD59x18 =\\n        -57896044618658097711785492504343953926634992332820282019728_792003956564819968;\\n\\n    /// @dev The minimum whole value a signed 59.18-decimal fixed-point number can have.\\n    int256 internal constant MIN_WHOLE_SD59x18 =\\n        -57896044618658097711785492504343953926634992332820282019728_000000000000000000;\\n\\n    /// @dev How many trailing decimals can be represented.\\n    int256 internal constant SCALE = 1e18;\\n\\n    /// INTERNAL FUNCTIONS ///\\n\\n    /// @notice Calculate the absolute value of x.\\n    ///\\n    /// @dev Requirements:\\n    /// - x must be greater than MIN_SD59x18.\\n    ///\\n    /// @param x The number to calculate the absolute value for.\\n    /// @param result The absolute value of x.\\n    function abs(int256 x) internal pure returns (int256 result) {\\n        unchecked {\\n            if (x == MIN_SD59x18) {\\n                revert PRBMathSD59x18__AbsInputTooSmall();\\n            }\\n            result = x < 0 ? -x : x;\\n        }\\n    }\\n\\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\\n    /// @param x The first operand as a signed 59.18-decimal fixed-point number.\\n    /// @param y The second operand as a signed 59.18-decimal fixed-point number.\\n    /// @return result The arithmetic average as a signed 59.18-decimal fixed-point number.\\n    function avg(int256 x, int256 y) internal pure returns (int256 result) {\\n        // The operations can never overflow.\\n        unchecked {\\n            int256 sum = (x >> 1) + (y >> 1);\\n            if (sum < 0) {\\n                // If at least one of x and y is odd, we add 1 to the result. This is because shifting negative numbers to the\\n                // right rounds down to infinity.\\n                assembly {\\n                    result := add(sum, and(or(x, y), 1))\\n                }\\n            } else {\\n                // If both x and y are odd, we add 1 to the result. This is because if both numbers are odd, the 0.5\\n                // remainder gets truncated twice.\\n                result = sum + (x & y & 1);\\n            }\\n        }\\n    }\\n\\n    /// @notice Yields the least greatest signed 59.18 decimal fixed-point number greater than or equal to x.\\n    ///\\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    ///\\n    /// Requirements:\\n    /// - x must be less than or equal to MAX_WHOLE_SD59x18.\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number to ceil.\\n    /// @param result The least integer greater than or equal to x, as a signed 58.18-decimal fixed-point number.\\n    function ceil(int256 x) internal pure returns (int256 result) {\\n        if (x > MAX_WHOLE_SD59x18) {\\n            revert PRBMathSD59x18__CeilOverflow(x);\\n        }\\n        unchecked {\\n            int256 remainder = x % SCALE;\\n            if (remainder == 0) {\\n                result = x;\\n            } else {\\n                // Solidity uses C fmod style, which returns a modulus with the same sign as x.\\n                result = x - remainder;\\n                if (x > 0) {\\n                    result += SCALE;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Divides two signed 59.18-decimal fixed-point numbers, returning a new signed 59.18-decimal fixed-point number.\\n    ///\\n    /// @dev Variant of \\\"mulDiv\\\" that works with signed numbers. Works by computing the signs and the absolute values separately.\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"PRBMath.mulDiv\\\".\\n    /// - None of the inputs can be MIN_SD59x18.\\n    /// - The denominator cannot be zero.\\n    /// - The result must fit within int256.\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"PRBMath.mulDiv\\\".\\n    ///\\n    /// @param x The numerator as a signed 59.18-decimal fixed-point number.\\n    /// @param y The denominator as a signed 59.18-decimal fixed-point number.\\n    /// @param result The quotient as a signed 59.18-decimal fixed-point number.\\n    function div(int256 x, int256 y) internal pure returns (int256 result) {\\n        if (x == MIN_SD59x18 || y == MIN_SD59x18) {\\n            revert PRBMathSD59x18__DivInputTooSmall();\\n        }\\n\\n        // Get hold of the absolute values of x and y.\\n        uint256 ax;\\n        uint256 ay;\\n        unchecked {\\n            ax = x < 0 ? uint256(-x) : uint256(x);\\n            ay = y < 0 ? uint256(-y) : uint256(y);\\n        }\\n\\n        // Compute the absolute value of (x*SCALE)\\u00f7y. The result must fit within int256.\\n        uint256 rAbs = PRBMath.mulDiv(ax, uint256(SCALE), ay);\\n        if (rAbs > uint256(MAX_SD59x18)) {\\n            revert PRBMathSD59x18__DivOverflow(rAbs);\\n        }\\n\\n        // Get the signs of x and y.\\n        uint256 sx;\\n        uint256 sy;\\n        assembly {\\n            sx := sgt(x, sub(0, 1))\\n            sy := sgt(y, sub(0, 1))\\n        }\\n\\n        // XOR over sx and sy. This is basically checking whether the inputs have the same sign. If yes, the result\\n        // should be positive. Otherwise, it should be negative.\\n        result = sx ^ sy == 1 ? -int256(rAbs) : int256(rAbs);\\n    }\\n\\n    /// @notice Returns Euler's number as a signed 59.18-decimal fixed-point number.\\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\\n    function e() internal pure returns (int256 result) {\\n        result = 2_718281828459045235;\\n    }\\n\\n    /// @notice Calculates the natural exponent of x.\\n    ///\\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    /// - x must be less than 133.084258667509499441.\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"exp2\\\".\\n    /// - For any x less than -41.446531673892822322, the result is zero.\\n    ///\\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\\n    function exp(int256 x) internal pure returns (int256 result) {\\n        // Without this check, the value passed to \\\"exp2\\\" would be less than -59.794705707972522261.\\n        if (x < -41_446531673892822322) {\\n            return 0;\\n        }\\n\\n        // Without this check, the value passed to \\\"exp2\\\" would be greater than 192.\\n        if (x >= 133_084258667509499441) {\\n            revert PRBMathSD59x18__ExpInputTooBig(x);\\n        }\\n\\n        // Do the fixed-point multiplication inline to save gas.\\n        unchecked {\\n            int256 doubleScaleProduct = x * LOG2_E;\\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\\n        }\\n    }\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    ///\\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\\n    ///\\n    /// Requirements:\\n    /// - x must be 192 or less.\\n    /// - The result must fit within MAX_SD59x18.\\n    ///\\n    /// Caveats:\\n    /// - For any x less than -59.794705707972522261, the result is zero.\\n    ///\\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\\n    function exp2(int256 x) internal pure returns (int256 result) {\\n        // This works because 2^(-x) = 1/2^x.\\n        if (x < 0) {\\n            // 2^59.794705707972522262 is the maximum number whose inverse does not truncate down to zero.\\n            if (x < -59_794705707972522261) {\\n                return 0;\\n            }\\n\\n            // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\\n            unchecked {\\n                result = 1e36 / exp2(-x);\\n            }\\n        } else {\\n            // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\\n            if (x >= 192e18) {\\n                revert PRBMathSD59x18__Exp2InputTooBig(x);\\n            }\\n\\n            unchecked {\\n                // Convert x to the 192.64-bit fixed-point format.\\n                uint256 x192x64 = (uint256(x) << 64) / uint256(SCALE);\\n\\n                // Safe to convert the result to int256 directly because the maximum input allowed is 192.\\n                result = int256(PRBMath.exp2(x192x64));\\n            }\\n        }\\n    }\\n\\n    /// @notice Yields the greatest signed 59.18 decimal fixed-point number less than or equal to x.\\n    ///\\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    ///\\n    /// Requirements:\\n    /// - x must be greater than or equal to MIN_WHOLE_SD59x18.\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number to floor.\\n    /// @param result The greatest integer less than or equal to x, as a signed 58.18-decimal fixed-point number.\\n    function floor(int256 x) internal pure returns (int256 result) {\\n        if (x < MIN_WHOLE_SD59x18) {\\n            revert PRBMathSD59x18__FloorUnderflow(x);\\n        }\\n        unchecked {\\n            int256 remainder = x % SCALE;\\n            if (remainder == 0) {\\n                result = x;\\n            } else {\\n                // Solidity uses C fmod style, which returns a modulus with the same sign as x.\\n                result = x - remainder;\\n                if (x < 0) {\\n                    result -= SCALE;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Yields the excess beyond the floor of x for positive numbers and the part of the number to the right\\n    /// of the radix point for negative numbers.\\n    /// @dev Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part\\n    /// @param x The signed 59.18-decimal fixed-point number to get the fractional part of.\\n    /// @param result The fractional part of x as a signed 59.18-decimal fixed-point number.\\n    function frac(int256 x) internal pure returns (int256 result) {\\n        unchecked {\\n            result = x % SCALE;\\n        }\\n    }\\n\\n    /// @notice Converts a number from basic integer form to signed 59.18-decimal fixed-point representation.\\n    ///\\n    /// @dev Requirements:\\n    /// - x must be greater than or equal to MIN_SD59x18 divided by SCALE.\\n    /// - x must be less than or equal to MAX_SD59x18 divided by SCALE.\\n    ///\\n    /// @param x The basic integer to convert.\\n    /// @param result The same number in signed 59.18-decimal fixed-point representation.\\n    function fromInt(int256 x) internal pure returns (int256 result) {\\n        unchecked {\\n            if (x < MIN_SD59x18 / SCALE) {\\n                revert PRBMathSD59x18__FromIntUnderflow(x);\\n            }\\n            if (x > MAX_SD59x18 / SCALE) {\\n                revert PRBMathSD59x18__FromIntOverflow(x);\\n            }\\n            result = x * SCALE;\\n        }\\n    }\\n\\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\\n    ///\\n    /// @dev Requirements:\\n    /// - x * y must fit within MAX_SD59x18, lest it overflows.\\n    /// - x * y cannot be negative.\\n    ///\\n    /// @param x The first operand as a signed 59.18-decimal fixed-point number.\\n    /// @param y The second operand as a signed 59.18-decimal fixed-point number.\\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\\n    function gm(int256 x, int256 y) internal pure returns (int256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        unchecked {\\n            // Checking for overflow this way is faster than letting Solidity do it.\\n            int256 xy = x * y;\\n            if (xy / x != y) {\\n                revert PRBMathSD59x18__GmOverflow(x, y);\\n            }\\n\\n            // The product cannot be negative.\\n            if (xy < 0) {\\n                revert PRBMathSD59x18__GmNegativeProduct(x, y);\\n            }\\n\\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\\n            // during multiplication. See the comments within the \\\"sqrt\\\" function.\\n            result = int256(PRBMath.sqrt(uint256(xy)));\\n        }\\n    }\\n\\n    /// @notice Calculates 1 / x, rounding toward zero.\\n    ///\\n    /// @dev Requirements:\\n    /// - x cannot be zero.\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the inverse.\\n    /// @return result The inverse as a signed 59.18-decimal fixed-point number.\\n    function inv(int256 x) internal pure returns (int256 result) {\\n        unchecked {\\n            // 1e36 is SCALE * SCALE.\\n            result = 1e36 / x;\\n        }\\n    }\\n\\n    /// @notice Calculates the natural logarithm of x.\\n    ///\\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    /// - This doesn't return exactly 1 for 2718281828459045235, for that we would need more fine-grained precision.\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the natural logarithm.\\n    /// @return result The natural logarithm as a signed 59.18-decimal fixed-point number.\\n    function ln(int256 x) internal pure returns (int256 result) {\\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\\n        // can return is 195205294292027477728.\\n        unchecked {\\n            result = (log2(x) * SCALE) / LOG2_E;\\n        }\\n    }\\n\\n    /// @notice Calculates the common logarithm of x.\\n    ///\\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the common logarithm.\\n    /// @return result The common logarithm as a signed 59.18-decimal fixed-point number.\\n    function log10(int256 x) internal pure returns (int256 result) {\\n        if (x <= 0) {\\n            revert PRBMathSD59x18__LogInputTooSmall(x);\\n        }\\n\\n        // Note that the \\\"mul\\\" in this block is the assembly mul operation, not the \\\"mul\\\" function defined in this contract.\\n        // prettier-ignore\\n        assembly {\\n            switch x\\n            case 1 { result := mul(SCALE, sub(0, 18)) }\\n            case 10 { result := mul(SCALE, sub(1, 18)) }\\n            case 100 { result := mul(SCALE, sub(2, 18)) }\\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\\n            case 1000000000000000000 { result := 0 }\\n            case 10000000000000000000 { result := SCALE }\\n            case 100000000000000000000 { result := mul(SCALE, 2) }\\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\\n            default {\\n                result := MAX_SD59x18\\n            }\\n        }\\n\\n        if (result == MAX_SD59x18) {\\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\\n            unchecked {\\n                result = (log2(x) * SCALE) / 3_321928094887362347;\\n            }\\n        }\\n    }\\n\\n    /// @notice Calculates the binary logarithm of x.\\n    ///\\n    /// @dev Based on the iterative approximation algorithm.\\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n    ///\\n    /// Requirements:\\n    /// - x must be greater than zero.\\n    ///\\n    /// Caveats:\\n    /// - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the binary logarithm.\\n    /// @return result The binary logarithm as a signed 59.18-decimal fixed-point number.\\n    function log2(int256 x) internal pure returns (int256 result) {\\n        if (x <= 0) {\\n            revert PRBMathSD59x18__LogInputTooSmall(x);\\n        }\\n        unchecked {\\n            // This works because log2(x) = -log2(1/x).\\n            int256 sign;\\n            if (x >= SCALE) {\\n                sign = 1;\\n            } else {\\n                sign = -1;\\n                // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\\n                assembly {\\n                    x := div(1000000000000000000000000000000000000, x)\\n                }\\n            }\\n\\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\\n            uint256 n = PRBMath.mostSignificantBit(uint256(x / SCALE));\\n\\n            // The integer part of the logarithm as a signed 59.18-decimal fixed-point number. The operation can't overflow\\n            // because n is maximum 255, SCALE is 1e18 and sign is either 1 or -1.\\n            result = int256(n) * SCALE;\\n\\n            // This is y = x * 2^(-n).\\n            int256 y = x >> n;\\n\\n            // If y = 1, the fractional part is zero.\\n            if (y == SCALE) {\\n                return result * sign;\\n            }\\n\\n            // Calculate the fractional part via the iterative approximation.\\n            // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n            for (int256 delta = int256(HALF_SCALE); delta > 0; delta >>= 1) {\\n                y = (y * y) / SCALE;\\n\\n                // Is y^2 > 2 and so in the range [2,4)?\\n                if (y >= 2 * SCALE) {\\n                    // Add the 2^(-m) factor to the logarithm.\\n                    result += delta;\\n\\n                    // Corresponds to z/2 on Wikipedia.\\n                    y >>= 1;\\n                }\\n            }\\n            result *= sign;\\n        }\\n    }\\n\\n    /// @notice Multiplies two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal\\n    /// fixed-point number.\\n    ///\\n    /// @dev Variant of \\\"mulDiv\\\" that works with signed numbers and employs constant folding, i.e. the denominator is\\n    /// always 1e18.\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"PRBMath.mulDivFixedPoint\\\".\\n    /// - None of the inputs can be MIN_SD59x18\\n    /// - The result must fit within MAX_SD59x18.\\n    ///\\n    /// Caveats:\\n    /// - The body is purposely left uncommented; see the NatSpec comments in \\\"PRBMath.mulDiv\\\" to understand how this works.\\n    ///\\n    /// @param x The multiplicand as a signed 59.18-decimal fixed-point number.\\n    /// @param y The multiplier as a signed 59.18-decimal fixed-point number.\\n    /// @return result The product as a signed 59.18-decimal fixed-point number.\\n    function mul(int256 x, int256 y) internal pure returns (int256 result) {\\n        if (x == MIN_SD59x18 || y == MIN_SD59x18) {\\n            revert PRBMathSD59x18__MulInputTooSmall();\\n        }\\n\\n        unchecked {\\n            uint256 ax;\\n            uint256 ay;\\n            ax = x < 0 ? uint256(-x) : uint256(x);\\n            ay = y < 0 ? uint256(-y) : uint256(y);\\n\\n            uint256 rAbs = PRBMath.mulDivFixedPoint(ax, ay);\\n            if (rAbs > uint256(MAX_SD59x18)) {\\n                revert PRBMathSD59x18__MulOverflow(rAbs);\\n            }\\n\\n            uint256 sx;\\n            uint256 sy;\\n            assembly {\\n                sx := sgt(x, sub(0, 1))\\n                sy := sgt(y, sub(0, 1))\\n            }\\n            result = sx ^ sy == 1 ? -int256(rAbs) : int256(rAbs);\\n        }\\n    }\\n\\n    /// @notice Returns PI as a signed 59.18-decimal fixed-point number.\\n    function pi() internal pure returns (int256 result) {\\n        result = 3_141592653589793238;\\n    }\\n\\n    /// @notice Raises x to the power of y.\\n    ///\\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"exp2\\\", \\\"log2\\\" and \\\"mul\\\".\\n    /// - z cannot be zero.\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"exp2\\\", \\\"log2\\\" and \\\"mul\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x Number to raise to given power y, as a signed 59.18-decimal fixed-point number.\\n    /// @param y Exponent to raise x to, as a signed 59.18-decimal fixed-point number.\\n    /// @return result x raised to power y, as a signed 59.18-decimal fixed-point number.\\n    function pow(int256 x, int256 y) internal pure returns (int256 result) {\\n        if (x == 0) {\\n            result = y == 0 ? SCALE : int256(0);\\n        } else {\\n            result = exp2(mul(log2(x), y));\\n        }\\n    }\\n\\n    /// @notice Raises x (signed 59.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\\n    /// famous algorithm \\\"exponentiation by squaring\\\".\\n    ///\\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"abs\\\" and \\\"PRBMath.mulDivFixedPoint\\\".\\n    /// - The result must fit within MAX_SD59x18.\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"PRBMath.mulDivFixedPoint\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x The base as a signed 59.18-decimal fixed-point number.\\n    /// @param y The exponent as an uint256.\\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\\n    function powu(int256 x, uint256 y) internal pure returns (int256 result) {\\n        uint256 xAbs = uint256(abs(x));\\n\\n        // Calculate the first iteration of the loop in advance.\\n        uint256 rAbs = y & 1 > 0 ? xAbs : uint256(SCALE);\\n\\n        // Equivalent to \\\"for(y /= 2; y > 0; y /= 2)\\\" but faster.\\n        uint256 yAux = y;\\n        for (yAux >>= 1; yAux > 0; yAux >>= 1) {\\n            xAbs = PRBMath.mulDivFixedPoint(xAbs, xAbs);\\n\\n            // Equivalent to \\\"y % 2 == 1\\\" but faster.\\n            if (yAux & 1 > 0) {\\n                rAbs = PRBMath.mulDivFixedPoint(rAbs, xAbs);\\n            }\\n        }\\n\\n        // The result must fit within the 59.18-decimal fixed-point representation.\\n        if (rAbs > uint256(MAX_SD59x18)) {\\n            revert PRBMathSD59x18__PowuOverflow(rAbs);\\n        }\\n\\n        // Is the base negative and the exponent an odd number?\\n        bool isNegative = x < 0 && y & 1 == 1;\\n        result = isNegative ? -int256(rAbs) : int256(rAbs);\\n    }\\n\\n    /// @notice Returns 1 as a signed 59.18-decimal fixed-point number.\\n    function scale() internal pure returns (int256 result) {\\n        result = SCALE;\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Requirements:\\n    /// - x cannot be negative.\\n    /// - x must be less than MAX_SD59x18 / SCALE.\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the square root.\\n    /// @return result The result as a signed 59.18-decimal fixed-point .\\n    function sqrt(int256 x) internal pure returns (int256 result) {\\n        unchecked {\\n            if (x < 0) {\\n                revert PRBMathSD59x18__SqrtNegativeInput(x);\\n            }\\n            if (x > MAX_SD59x18 / SCALE) {\\n                revert PRBMathSD59x18__SqrtOverflow(x);\\n            }\\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two signed\\n            // 59.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\\n            result = int256(PRBMath.sqrt(uint256(x * SCALE)));\\n        }\\n    }\\n\\n    /// @notice Converts a signed 59.18-decimal fixed-point number to basic integer form, rounding down in the process.\\n    /// @param x The signed 59.18-decimal fixed-point number to convert.\\n    /// @return result The same number in basic integer form.\\n    function toInt(int256 x) internal pure returns (int256 result) {\\n        unchecked {\\n            result = x / SCALE;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1886d687eace717c05b7dcc20e43a088df0e549df86b453c2222961b520308f0\",\"license\":\"Unlicense\"},\"prb-math/contracts/PRBMathUD60x18.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\nimport \\\"./PRBMath.sol\\\";\\n\\n/// @title PRBMathUD60x18\\n/// @author Paul Razvan Berg\\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\\n/// maximum values permitted by the Solidity type uint256.\\nlibrary PRBMathUD60x18 {\\n    /// @dev Half the SCALE number.\\n    uint256 internal constant HALF_SCALE = 5e17;\\n\\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\\n    uint256 internal constant LOG2_E = 1_442695040888963407;\\n\\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\\n    uint256 internal constant MAX_UD60x18 =\\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\\n\\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\\n    uint256 internal constant MAX_WHOLE_UD60x18 =\\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\\n\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        // The operations can never overflow.\\n        unchecked {\\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\\n        }\\n    }\\n\\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\\n    ///\\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    ///\\n    /// Requirements:\\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\\n    function ceil(uint256 x) internal pure returns (uint256 result) {\\n        if (x > MAX_WHOLE_UD60x18) {\\n            revert PRBMathUD60x18__CeilOverflow(x);\\n        }\\n        assembly {\\n            // Equivalent to \\\"x % SCALE\\\" but faster.\\n            let remainder := mod(x, SCALE)\\n\\n            // Equivalent to \\\"SCALE - remainder\\\" but faster.\\n            let delta := sub(SCALE, remainder)\\n\\n            // Equivalent to \\\"x + delta * (remainder > 0 ? 1 : 0)\\\" but faster.\\n            result := add(x, mul(delta, gt(remainder, 0)))\\n        }\\n    }\\n\\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\\n    ///\\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\\n    ///\\n    /// Requirements:\\n    /// - The denominator cannot be zero.\\n    ///\\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        result = PRBMath.mulDiv(x, SCALE, y);\\n    }\\n\\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\\n    function e() internal pure returns (uint256 result) {\\n        result = 2_718281828459045235;\\n    }\\n\\n    /// @notice Calculates the natural exponent of x.\\n    ///\\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    /// - x must be less than 133.084258667509499441.\\n    ///\\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp(uint256 x) internal pure returns (uint256 result) {\\n        // Without this check, the value passed to \\\"exp2\\\" would be greater than 192.\\n        if (x >= 133_084258667509499441) {\\n            revert PRBMathUD60x18__ExpInputTooBig(x);\\n        }\\n\\n        // Do the fixed-point multiplication inline to save gas.\\n        unchecked {\\n            uint256 doubleScaleProduct = x * LOG2_E;\\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\\n        }\\n    }\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    ///\\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\\n    ///\\n    /// Requirements:\\n    /// - x must be 192 or less.\\n    /// - The result must fit within MAX_UD60x18.\\n    ///\\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp2(uint256 x) internal pure returns (uint256 result) {\\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\\n        if (x >= 192e18) {\\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\\n        }\\n\\n        unchecked {\\n            // Convert x to the 192.64-bit fixed-point format.\\n            uint256 x192x64 = (x << 64) / SCALE;\\n\\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\\n            result = PRBMath.exp2(x192x64);\\n        }\\n    }\\n\\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\\n    function floor(uint256 x) internal pure returns (uint256 result) {\\n        assembly {\\n            // Equivalent to \\\"x % SCALE\\\" but faster.\\n            let remainder := mod(x, SCALE)\\n\\n            // Equivalent to \\\"x - remainder * (remainder > 0 ? 1 : 0)\\\" but faster.\\n            result := sub(x, mul(remainder, gt(remainder, 0)))\\n        }\\n    }\\n\\n    /// @notice Yields the excess beyond the floor of x.\\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\\n    function frac(uint256 x) internal pure returns (uint256 result) {\\n        assembly {\\n            result := mod(x, SCALE)\\n        }\\n    }\\n\\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\\n    ///\\n    /// @dev Requirements:\\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\\n    ///\\n    /// @param x The basic integer to convert.\\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            if (x > MAX_UD60x18 / SCALE) {\\n                revert PRBMathUD60x18__FromUintOverflow(x);\\n            }\\n            result = x * SCALE;\\n        }\\n    }\\n\\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\\n    ///\\n    /// @dev Requirements:\\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\\n    ///\\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        unchecked {\\n            // Checking for overflow this way is faster than letting Solidity do it.\\n            uint256 xy = x * y;\\n            if (xy / x != y) {\\n                revert PRBMathUD60x18__GmOverflow(x, y);\\n            }\\n\\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\\n            // during multiplication. See the comments within the \\\"sqrt\\\" function.\\n            result = PRBMath.sqrt(xy);\\n        }\\n    }\\n\\n    /// @notice Calculates 1 / x, rounding toward zero.\\n    ///\\n    /// @dev Requirements:\\n    /// - x cannot be zero.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\\n    function inv(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 1e36 is SCALE * SCALE.\\n            result = 1e36 / x;\\n        }\\n    }\\n\\n    /// @notice Calculates the natural logarithm of x.\\n    ///\\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function ln(uint256 x) internal pure returns (uint256 result) {\\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\\n        // can return is 196205294292027477728.\\n        unchecked {\\n            result = (log2(x) * SCALE) / LOG2_E;\\n        }\\n    }\\n\\n    /// @notice Calculates the common logarithm of x.\\n    ///\\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function log10(uint256 x) internal pure returns (uint256 result) {\\n        if (x < SCALE) {\\n            revert PRBMathUD60x18__LogInputTooSmall(x);\\n        }\\n\\n        // Note that the \\\"mul\\\" in this block is the assembly multiplication operation, not the \\\"mul\\\" function defined\\n        // in this contract.\\n        // prettier-ignore\\n        assembly {\\n            switch x\\n            case 1 { result := mul(SCALE, sub(0, 18)) }\\n            case 10 { result := mul(SCALE, sub(1, 18)) }\\n            case 100 { result := mul(SCALE, sub(2, 18)) }\\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\\n            case 1000000000000000000 { result := 0 }\\n            case 10000000000000000000 { result := SCALE }\\n            case 100000000000000000000 { result := mul(SCALE, 2) }\\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\\n            default {\\n                result := MAX_UD60x18\\n            }\\n        }\\n\\n        if (result == MAX_UD60x18) {\\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\\n            unchecked {\\n                result = (log2(x) * SCALE) / 3_321928094887362347;\\n            }\\n        }\\n    }\\n\\n    /// @notice Calculates the binary logarithm of x.\\n    ///\\n    /// @dev Based on the iterative approximation algorithm.\\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n    ///\\n    /// Requirements:\\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\\n    ///\\n    /// Caveats:\\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function log2(uint256 x) internal pure returns (uint256 result) {\\n        if (x < SCALE) {\\n            revert PRBMathUD60x18__LogInputTooSmall(x);\\n        }\\n        unchecked {\\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\\n\\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\\n            // because n is maximum 255 and SCALE is 1e18.\\n            result = n * SCALE;\\n\\n            // This is y = x * 2^(-n).\\n            uint256 y = x >> n;\\n\\n            // If y = 1, the fractional part is zero.\\n            if (y == SCALE) {\\n                return result;\\n            }\\n\\n            // Calculate the fractional part via the iterative approximation.\\n            // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\\n                y = (y * y) / SCALE;\\n\\n                // Is y^2 > 2 and so in the range [2,4)?\\n                if (y >= 2 * SCALE) {\\n                    // Add the 2^(-m) factor to the logarithm.\\n                    result += delta;\\n\\n                    // Corresponds to z/2 on Wikipedia.\\n                    y >>= 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\\n    /// fixed-point number.\\n    /// @dev See the documentation for the \\\"PRBMath.mulDivFixedPoint\\\" function.\\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        result = PRBMath.mulDivFixedPoint(x, y);\\n    }\\n\\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\\n    function pi() internal pure returns (uint256 result) {\\n        result = 3_141592653589793238;\\n    }\\n\\n    /// @notice Raises x to the power of y.\\n    ///\\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"exp2\\\", \\\"log2\\\" and \\\"mul\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"exp2\\\", \\\"log2\\\" and \\\"mul\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            result = y == 0 ? SCALE : uint256(0);\\n        } else {\\n            result = exp2(mul(log2(x), y));\\n        }\\n    }\\n\\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\\n    /// famous algorithm \\\"exponentiation by squaring\\\".\\n    ///\\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\\n    ///\\n    /// Requirements:\\n    /// - The result must fit within MAX_UD60x18.\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"mul\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The exponent as an uint256.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        // Calculate the first iteration of the loop in advance.\\n        result = y & 1 > 0 ? x : SCALE;\\n\\n        // Equivalent to \\\"for(y /= 2; y > 0; y /= 2)\\\" but faster.\\n        for (y >>= 1; y > 0; y >>= 1) {\\n            x = PRBMath.mulDivFixedPoint(x, x);\\n\\n            // Equivalent to \\\"y % 2 == 1\\\" but faster.\\n            if (y & 1 > 0) {\\n                result = PRBMath.mulDivFixedPoint(result, x);\\n            }\\n        }\\n    }\\n\\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\\n    function scale() internal pure returns (uint256 result) {\\n        result = SCALE;\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Requirements:\\n    /// - x must be less than MAX_UD60x18 / SCALE.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            if (x > MAX_UD60x18 / SCALE) {\\n                revert PRBMathUD60x18__SqrtOverflow(x);\\n            }\\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\\n            result = PRBMath.sqrt(x * SCALE);\\n        }\\n    }\\n\\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\\n    /// @return result The same number in basic integer form.\\n    function toUint(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = x / SCALE;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2180489de7680a79844dd5ef145f800e4f68e515e0e89409242f0187dbbd657b\",\"license\":\"Unlicense\"}},\"version\":1}",
  "bytecode": "0x60a06040523480156200001157600080fd5b5060405162002a5138038062002a51833981016040819052620000349162000346565b80620000403362000169565b60601b6001600160601b0319166080526201000380546001600160a01b0319166001600160a01b038416179055600062000085620001b9602090811b6200078a17901c565b620100035460405163d15e005360e01b81526001600160a01b0385811660048301529293506000929091169063d15e00539060240160206040518083038186803b158015620000d357600080fd5b505afa158015620000e8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200010e91906200037d565b90506200012d82826004620001cb60201b6200079a179092919060201c565b6003805465ffffffff0000191664010000000061ffff9384160263ffff0000191617620100009390921692909202179055506200039692505050565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000620001c64262000250565b905090565b600080620001da84846200029a565b8051865460208301516040909301511515600160f81b026001600160f81b036001600160d81b03909416640100000000027fff0000000000000000000000000000000000000000000000000000000000000090921663ffffffff9093169290921717919091161790945550600193849350915050565b600063ffffffff821115620002965760405162461bcd60e51b815260206004820152600760248201526654534f464c4f5760c81b60448201526064015b60405180910390fd5b5090565b60408051606081018252600080825260208201819052918101919091526001600160d81b03821115620002f95760405162461bcd60e51b81526004016200028d906020808252600490820152631f19189b60e11b604082015260600190565b506040805160608101825263ffffffff9390931683526001600160d81b0391909116602083015260019082015290565b80516001600160a01b03811681146200034157600080fd5b919050565b6000806040838503121562000359578182fd5b620003648362000329565b9150620003746020840162000329565b90509250929050565b6000602082840312156200038f578081fd5b5051919050565b60805160601c612687620003ca600039600081816101c601528181610d2101528181610fa0015261106101526126876000f3fe608060405234801561001057600080fd5b50600436106100f15760003560e01c80631195082e146100f6578063252c09d71461013457806325f258dd146101735780632d92c2db14610186578063414535281461019b57806354124c64146101ae5780636f307dc3146101c1578063715018a6146101f55780637aa4db13146101fd5780637cf2cc9f146102055780638da5cb5b1461020e57806393556dbd14610216578063b909f73214610229578063bdb0509214610238578063c7db359b1461024b578063dd9d05d114610293578063e9d337b8146102ad578063f2fde38b146102c2578063f739670c146102d5575b600080fd5b610121610104366004612438565b600160209081526000928352604080842090915290825290205481565b6040519081526020015b60405180910390f35b6101476101423660046123bc565b6102e8565b6040805163ffffffff90941684526001600160d81b03909216602084015215159082015260600161012b565b6101216101813660046123ec565b610322565b61019961019436600461239a565b610390565b005b6101216101a93660046123ec565b61041c565b6101216101bc36600461240d565b610430565b6101e87f000000000000000000000000000000000000000000000000000000000000000081565b60405161012b919061246a565b610199610487565b6101996104cb565b61012160025481565b6101e8610518565b6101216102243660046123ec565b610527565b610121670de0b6b3a764000081565b6101996102463660046123bc565b6105b7565b60035461026e9061ffff80821691620100008104821691600160201b9091041683565b6040805161ffff9485168152928416602084015292169181019190915260600161012b565b61029b600181565b60405160ff909116815260200161012b565b62010003546101e8906001600160a01b031681565b6101996102d0366004612373565b610621565b6101216102e33660046123ec565b6106c1565b60048161ffff81106102f957600080fd5b015463ffffffff81169150600160201b81046001600160d81b031690600160f81b900460ff1683565b60008061032f848461080b565b9092509050801561038857600061034d61034886610934565b610942565b9050600061035d61034886610934565b63ffffffff928316600090815260016020908152604080832095909316825293909352909120839055505b505b92915050565b600354600160201b900461ffff1660006103ac60048385610986565b6003805461ffff808416600160201b810261ffff60201b1990931692909217909255919250831614610417576040805161ffff8085168252831660208201527f1f0a33a4e18d81b29e729a440bc8de6a84b65d9fbdf81682d85c3a382296e55e910160405180910390a15b505050565b6000610428838361080b565b509392505050565b60008061043c83610a45565b9050600061044a6001610a5c565b610454908661252c565b905060006104628284610aa9565b9050600061046f82610ae8565b905061047b8882610b44565b98975050505050505050565b33610490610518565b6001600160a01b0316146104bf5760405162461bcd60e51b81526004016104b6906124d1565b60405180910390fd5b6104c96000610bfd565b565b6003546104f09061ffff80821691620100008104821691600160201b90910416610c4d565b6003805463ffffffff19166201000061ffff9384160261ffff19161792909116919091179055565b6000546001600160a01b031690565b60008183111561056c5760405162461bcd60e51b815260206004820152601060248201526f4d69736f72646572656420646174657360801b60448201526064016104b6565b600061057884846106c1565b90506000610586858561259a565b9050600061059382610a5c565b905060006105a082610a45565b90506105ac8482610e43565b979650505050505050565b336105c0610518565b6001600160a01b0316146105e65760405162461bcd60e51b81526004016104b6906124d1565b60028190556040518181527f19ede2e51d1531988bc60742b8bb97134e9f3a1ec45cf7cf4ea09953f80b2ac59060200160405180910390a150565b3361062a610518565b6001600160a01b0316146106505760405162461bcd60e51b81526004016104b6906124d1565b6001600160a01b0381166106b55760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084016104b6565b6106be81610bfd565b50565b6000818314156106d35750600061038a565b60006106dd61078a565b905060006106ea85610942565b905060006106f785610942565b60035490915060009061071b908590859061ffff8082169162010000900416610ea2565b60035490915060009061073f908690859061ffff8082169162010000900416610ea2565b90508181111561077c5761077061076b676765c793fa10079d601b1b610765848661123c565b90611310565b61131c565b9550505050505061038a565b60009550505050505061038a565b600061079542610942565b905090565b6000806107a7848461138a565b85600082519101805460208401516040909401511515600160f81b026001600160f81b036001600160d81b03909516600160201b026001600160f81b031990921663ffffffff9094169390931717929092161790555060019050805b935093915050565b600080600061081c61034886610934565b9050600061082c61034886610934565b905060008263ffffffff1611801561084a575060008163ffffffff16115b61087e5760405162461bcd60e51b8152602060048201526005602482015264554e49545360d81b60448201526064016104b6565b63ffffffff808316600090815260016020908152604080832093851683529290522054156108d05763ffffffff808316600090815260016020908152604080832093851683529290522054935061092b565b8063ffffffff166108df61078a565b63ffffffff161061090b576109008263ffffffff168263ffffffff166106c1565b93506001925061092b565b6109288263ffffffff1661091d61078a565b63ffffffff166106c1565b93505b50509250929050565b670de0b6b3a7640000900490565b600063ffffffff8211156109825760405162461bcd60e51b815260206004820152600760248201526654534f464c4f5760c81b60448201526064016104b6565b5090565b6000808361ffff16116109bf5760405162461bcd60e51b81526020600482015260016024820152604960f81b60448201526064016104b6565b8261ffff168261ffff16116109d5575081610a3e565b825b8261ffff168161ffff161015610a39576001858261ffff1661ffff8110610a0e57634e487b7160e01b600052603260045260246000fd5b01805463ffffffff191663ffffffff9290921691909117905580610a31816125ce565b9150506109d7565b508190505b9392505050565b600061038a826a1a1601fc4ea7109e000000611402565b60007812725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21821115610a9b57604051633492ffd960e01b8152600481018390526024016104b6565b50670de0b6b3a76400000290565b600082610ace578115610abd576000610ac7565b670de0b6b3a76400005b905061038a565b610a3e610ae3610add85611417565b846114c7565b6114d3565b600080610af9633b9aca0084612558565b905082610b0a633b9aca0083612544565b1460405180604001604052806002815260200161068760f31b815250906103885760405162461bcd60e51b81526004016104b6919061247e565b6000821580610b51575081155b15610b5e5750600061038a565b81610b756002676765c793fa10079d601b1b612544565b610b819060001961259a565b610b8b9190612544565b83111560405180604001604052806002815260200161068760f31b81525090610bc75760405162461bcd60e51b81526004016104b6919061247e565b50676765c793fa10079d601b1b610bdf600282612544565b610be98486612558565b610bf3919061252c565b610a3e9190612544565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600080600060048661ffff1661ffff8110610c7857634e487b7160e01b600052603260045260246000fd5b60408051606081018252929091015463ffffffff811683526001600160d81b03600160201b820416602084015260ff600160f81b9091041615159082015290506000610cc261078a565b9050816000015163ffffffff166002548263ffffffff16610ce3919061259a565b1015610cf6578686935093505050610803565b620100035460405163d15e005360e01b81526000916001600160a01b03169063d15e005390610d49907f00000000000000000000000000000000000000000000000000000000000000009060040161246a565b60206040518083038186803b158015610d6157600080fd5b505afa158015610d75573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d9991906123d4565b905080610db95760405163bd89c5af60e01b815260040160405180910390fd5b7f43bca372be3e74f9c236cf54450ec01eb2d011690a24a7402ddff4e41267e447610de2611519565b6040805191825230602083015261ffff8b81168383015263ffffffff86166060840152608083018590528a811660a0840152891660c0830152519081900360e00190a1610e3460048984848b8b611524565b94509450505050935093915050565b600082610e525750600061038a565b6000610e66670de0b6b3a764000084611402565b90506000610e85610e7f86670de0b6b3a764000061252c565b83610aa9565b9050610e99670de0b6b3a76400008261259a565b95945050505050565b60008363ffffffff168563ffffffff161015610ee65760405162461bcd60e51b81526020600482015260036024820152624f4f4f60e81b60448201526064016104b6565b8363ffffffff168563ffffffff16141561103657610f0261233f565b60048461ffff1661ffff8110610f2857634e487b7160e01b600052603260045260246000fd5b60408051606081018252919092015463ffffffff808216808452600160201b83046001600160d81b03166020850152600160f81b90920460ff161515938301939093529092509087161461101f57620100035460405163d15e005360e01b81526001600160a01b039091169063d15e005390610fc8907f00000000000000000000000000000000000000000000000000000000000000009060040161246a565b60206040518083038186803b158015610fe057600080fd5b505afa158015610ff4573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061101891906123d4565b9150611030565b80602001516001600160d81b031691505b50611234565b620100035460405163d15e005360e01b81526000916001600160a01b03169063d15e005390611089907f00000000000000000000000000000000000000000000000000000000000000009060040161246a565b60206040518083038186803b1580156110a157600080fd5b505afa1580156110b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110d991906123d4565b90506000806110ec600488858989611688565b91509150816000015163ffffffff168763ffffffff16141561111d5781602001516001600160d81b03169350611230565b805163ffffffff888116911614156111445780602001516001600160d81b03169350611230565b600082602001516001600160d81b031682602001516001600160d81b031611156111ac57600061119d676765c793fa10079d601b1b61076585602001516001600160d81b031687602001516001600160d81b031661123c565b90506111a88161131c565b9150505b60006111dd670de0b6b3a7640000855185516111c891906125b1565b63ffffffff166111d89190612558565b610a45565b905060006111eb8383610e43565b905061122a85602001516001600160d81b03168261120e670de0b6b3a764000090565b885161121a908f6125b1565b63ffffffff166101bc9190612558565b96505050505b5050505b949350505050565b604080518082019091526002815261035360f41b6020820152600090826112765760405162461bcd60e51b81526004016104b6919061247e565b506000611284600284612544565b9050676765c793fa10079d601b1b61129e8260001961259a565b6112a89190612544565b84111560405180604001604052806002815260200161068760f31b815250906112e45760405162461bcd60e51b81526004016104b6919061247e565b5082816112fc676765c793fa10079d601b1b87612558565b611306919061252c565b6112349190612544565b6000610a3e828461259a565b60008061132e6002633b9aca00612544565b9050600061133c848361252c565b90508181101560405180604001604052806002815260200161343960f01b8152509061137b5760405162461bcd60e51b81526004016104b6919061247e565b50611234633b9aca0082612544565b61139261233f565b6001600160d81b038211156113d25760405162461bcd60e51b81526004016104b6906020808252600490820152631f19189b60e11b604082015260600190565b506040805160608101825263ffffffff9390931683526001600160d81b0391909116602083015260019082015290565b6000610a3e83670de0b6b3a764000084611856565b6000670de0b6b3a764000082101561144557604051633621413760e21b8152600481018390526024016104b6565b600061145a670de0b6b3a76400008404611932565b670de0b6b3a7640000808202935090915083821c9081141561147d575050919050565b6706f05b59d3b200005b80156114bf57670de0b6b3a7640000828002049150671bc16d674ec8000082106114b7579283019260019190911c905b60011c611487565b505050919050565b6000610a3e8383611a15565b6000680a688906bd8b000000821061150157604051634a4f26f160e01b8152600481018390526024016104b6565b670de0b6b3a7640000604083901b04610a3e81611ad7565b600061079542610a5c565b6000806000888861ffff1661ffff811061154e57634e487b7160e01b600052603260045260246000fd5b60408051606081018252919092015463ffffffff808216808452600160201b83046001600160d81b03166020850152600160f81b90920460ff1615159383019390935290925090881614156115a9578785925092505061167d565b8461ffff168461ffff161180156115d157506115c6600186612577565b61ffff168861ffff16145b156115de578391506115e2565b8491505b816115ee896001612506565b6115f891906125f0565b9250611604878761138a565b898461ffff1661ffff811061162957634e487b7160e01b600052603260045260246000fd5b82519101805460208401516040909401511515600160f81b026001600160f81b036001600160d81b03909516600160201b026001600160f81b031990921663ffffffff909416939093171792909216179055505b965096945050505050565b61169061233f565b61169861233f565b868461ffff1661ffff81106116bd57634e487b7160e01b600052603260045260246000fd5b60408051606081018252919092015463ffffffff808216808452600160201b83046001600160d81b03166020850152600160f81b90920460ff161515938301939093529093509087161061173c578563ffffffff16826000015163ffffffff1614156117285761184c565b81611733878761138a565b9150915061184c565b8683611749866001612506565b61175391906125f0565b61ffff1661ffff811061177657634e487b7160e01b600052603260045260246000fd5b60408051606081018252919092015463ffffffff81168252600160201b81046001600160d81b03166020830152600160f81b900460ff16151591810182905292506117fb5760408051606081018252885463ffffffff81168252600160201b81046001600160d81b03166020830152600160f81b900460ff1615159181019190915291505b815163ffffffff8088169116111561183b5760405162461bcd60e51b815260206004820152600360248201526213d31160ea1b60448201526064016104b6565b61184787878686612169565b915091505b9550959350505050565b60008080600019858709858702925082811083820303915050806000141561189f5783828161189557634e487b7160e01b600052601260045260246000fd5b0492505050610a3e565b8381106118c957604051631dcf306360e21b815260048101829052602481018590526044016104b6565b60008486880960026001871981018816978890046003810283188082028403028082028403028082028403028082028403028082028403029081029092039091026000889003889004909101858311909403939093029303949094049190911702949350505050565b6000600160801b821061195257608091821c9161194f908261252c565b90505b600160401b821061197057604091821c9161196d908261252c565b90505b600160201b821061198e57602091821c9161198b908261252c565b90505b6201000082106119ab57601091821c916119a8908261252c565b90505b61010082106119c757600891821c916119c4908261252c565b90505b601082106119e257600491821c916119df908261252c565b90505b600482106119fd57600291821c916119fa908261252c565b90505b60028210611a105761038a60018261252c565b919050565b60008080600019848609848602925082811083820303915050670de0b6b3a76400008110611a595760405163698d9a0160e11b8152600481018290526024016104b6565b600080670de0b6b3a76400008688099150506706f05b59d3b1ffff811182611a935780670de0b6b3a764000085040194505050505061038a565b620400008285030493909111909103600160ee1b02919091177faccb18165bd6fe31ae1cf318dc5b51eee0e1ba569b88cd74c1773b91fac106690201905092915050565b600160bf1b6001603f1b821615611af75768016a09e667f3bcc9090260401c5b6001603e1b821615611b12576801306fe0a31b7152df0260401c5b6001603d1b821615611b2d576801172b83c7d517adce0260401c5b6001603c1b821615611b485768010b5586cf9890f62a0260401c5b6001603b1b821615611b63576801059b0d31585743ae0260401c5b6001603a1b821615611b7e57680102c9a3e778060ee70260401c5b600160391b821615611b995768010163da9fb33356d80260401c5b600160381b821615611bb457680100b1afa5abcbed610260401c5b600160371b821615611bcf5768010058c86da1c09ea20260401c5b600160361b821615611bea576801002c605e2e8cec500260401c5b600160351b821615611c0557680100162f3904051fa10260401c5b600160341b821615611c20576801000b175effdc76ba0260401c5b600160331b821615611c3b57680100058ba01fb9f96d0260401c5b600160321b821615611c565768010002c5cc37da94920260401c5b600160311b821615611c71576801000162e525ee05470260401c5b600160301b821615611c8c5768010000b17255775c040260401c5b6001602f1b821615611ca7576801000058b91b5bc9ae0260401c5b6001602e1b821615611cc257680100002c5c89d5ec6d0260401c5b6001602d1b821615611cdd5768010000162e43f4f8310260401c5b6001602c1b821615611cf857680100000b1721bcfc9a0260401c5b6001602b1b821615611d135768010000058b90cf1e6e0260401c5b6001602a1b821615611d2e576801000002c5c863b73f0260401c5b600160291b821615611d4957680100000162e430e5a20260401c5b600160281b821615611d64576801000000b1721835510260401c5b600160271b821615611d7f57680100000058b90c0b490260401c5b600160261b821615611d9a5768010000002c5c8601cc0260401c5b600160251b821615611db5576801000000162e42fff00260401c5b600160241b821615611dd05768010000000b17217fbb0260401c5b600160231b821615611deb576801000000058b90bfce0260401c5b600160221b821615611e0657680100000002c5c85fe30260401c5b600160211b821615611e215768010000000162e42ff10260401c5b600160201b821615611e3c57680100000000b17217f80260401c5b6380000000821615611e575768010000000058b90bfc0260401c5b6340000000821615611e72576801000000002c5c85fe0260401c5b6320000000821615611e8d57680100000000162e42ff0260401c5b6310000000821615611ea8576801000000000b17217f0260401c5b6308000000821615611ec357680100000000058b90c00260401c5b6304000000821615611ede5768010000000002c5c8600260401c5b6302000000821615611ef9576801000000000162e4300260401c5b6301000000821615611f145768010000000000b172180260401c5b62800000821615611f2e576801000000000058b90c0260401c5b62400000821615611f4857680100000000002c5c860260401c5b62200000821615611f625768010000000000162e430260401c5b62100000821615611f7c57680100000000000b17210260401c5b62080000821615611f965768010000000000058b910260401c5b62040000821615611fb0576801000000000002c5c80260401c5b62020000821615611fca57680100000000000162e40260401c5b62010000821615611fe35761b172600160401b010260401c5b618000821615611ffb576158b9600160401b010260401c5b61400082161561201357612c5d600160401b010260401c5b61200082161561202b5761162e600160401b010260401c5b61100082161561204357610b17600160401b010260401c5b61080082161561205b5761058c600160401b010260401c5b610400821615612073576102c6600160401b010260401c5b61020082161561208b57610163600160401b010260401c5b6101008216156120a25760b1600160401b010260401c5b60808216156120b8576059600160401b010260401c5b60408216156120ce57602c600160401b010260401c5b60208216156120e4576016600160401b010260401c5b60108216156120fa57600b600160401b010260401c5b6008821615612110576006600160401b010260401c5b6004821615612126576003600160401b010260401c5b600282161561213c576001600160401b010260401c5b6001821615612152576001600160401b010260401c5b670de0b6b3a76400000260409190911c60bf031c90565b61217161233f565b61217961233f565b600083612187866001612506565b61219191906125f0565b61ffff169050600060018561ffff16836121ab919061252c565b6121b5919061259a565b905060005b60026121c6838561252c565b6121d09190612544565b9050886121e161ffff881683612611565b61ffff811061220057634e487b7160e01b600052603260045260246000fd5b60408051606081018252919092015463ffffffff81168252600160201b81046001600160d81b03166020830152600160f81b900460ff16151591810182905295506122575761225081600161252c565b92506121ba565b8861ffff871661226883600161252c565b6122729190612611565b61ffff811061229157634e487b7160e01b600052603260045260246000fd5b60408051606081018252919092015463ffffffff8082168352600160201b82046001600160d81b03166020840152600160f81b90910460ff16151592820192909252865190955089821691161180159081906122fd5750846000015163ffffffff168963ffffffff1611155b156123085750612333565b8061231f5761231860018361259a565b925061232d565b61232a82600161252c565b93505b506121ba565b50505094509492505050565b604080516060810182526000808252602082018190529181019190915290565b803563ffffffff81168114611a1057600080fd5b600060208284031215612384578081fd5b81356001600160a01b0381168114610a3e578182fd5b6000602082840312156123ab578081fd5b813561ffff81168114610a3e578182fd5b6000602082840312156123cd578081fd5b5035919050565b6000602082840312156123e5578081fd5b5051919050565b600080604083850312156123fe578081fd5b50508035926020909101359150565b600080600060608486031215612421578081fd5b505081359360208301359350604090920135919050565b6000806040838503121561244a578182fd5b6124538361235f565b91506124616020840161235f565b90509250929050565b6001600160a01b0391909116815260200190565b6000602080835283518082850152825b818110156124aa5785810183015185820160400152820161248e565b818111156124bb5783604083870101525b50601f01601f1916929092016040019392505050565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b600061ffff80831681851680830382111561252357612523612625565b01949350505050565b6000821982111561253f5761253f612625565b500190565b6000826125535761255361263b565b500490565b600081600019048311821515161561257257612572612625565b500290565b600061ffff8381169083168181101561259257612592612625565b039392505050565b6000828210156125ac576125ac612625565b500390565b600063ffffffff8381169083168181101561259257612592612625565b600061ffff808316818114156125e6576125e6612625565b6001019392505050565b600061ffff808416806126055761260561263b565b92169190910692915050565b6000826126205761262061263b565b500690565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fdfea26469706673582212202b6cc9586787797b631964bed55d35dc1e4b55037e35c0fe79d0f2fc657ba2c564736f6c63430008040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100f15760003560e01c80631195082e146100f6578063252c09d71461013457806325f258dd146101735780632d92c2db14610186578063414535281461019b57806354124c64146101ae5780636f307dc3146101c1578063715018a6146101f55780637aa4db13146101fd5780637cf2cc9f146102055780638da5cb5b1461020e57806393556dbd14610216578063b909f73214610229578063bdb0509214610238578063c7db359b1461024b578063dd9d05d114610293578063e9d337b8146102ad578063f2fde38b146102c2578063f739670c146102d5575b600080fd5b610121610104366004612438565b600160209081526000928352604080842090915290825290205481565b6040519081526020015b60405180910390f35b6101476101423660046123bc565b6102e8565b6040805163ffffffff90941684526001600160d81b03909216602084015215159082015260600161012b565b6101216101813660046123ec565b610322565b61019961019436600461239a565b610390565b005b6101216101a93660046123ec565b61041c565b6101216101bc36600461240d565b610430565b6101e87f000000000000000000000000000000000000000000000000000000000000000081565b60405161012b919061246a565b610199610487565b6101996104cb565b61012160025481565b6101e8610518565b6101216102243660046123ec565b610527565b610121670de0b6b3a764000081565b6101996102463660046123bc565b6105b7565b60035461026e9061ffff80821691620100008104821691600160201b9091041683565b6040805161ffff9485168152928416602084015292169181019190915260600161012b565b61029b600181565b60405160ff909116815260200161012b565b62010003546101e8906001600160a01b031681565b6101996102d0366004612373565b610621565b6101216102e33660046123ec565b6106c1565b60048161ffff81106102f957600080fd5b015463ffffffff81169150600160201b81046001600160d81b031690600160f81b900460ff1683565b60008061032f848461080b565b9092509050801561038857600061034d61034886610934565b610942565b9050600061035d61034886610934565b63ffffffff928316600090815260016020908152604080832095909316825293909352909120839055505b505b92915050565b600354600160201b900461ffff1660006103ac60048385610986565b6003805461ffff808416600160201b810261ffff60201b1990931692909217909255919250831614610417576040805161ffff8085168252831660208201527f1f0a33a4e18d81b29e729a440bc8de6a84b65d9fbdf81682d85c3a382296e55e910160405180910390a15b505050565b6000610428838361080b565b509392505050565b60008061043c83610a45565b9050600061044a6001610a5c565b610454908661252c565b905060006104628284610aa9565b9050600061046f82610ae8565b905061047b8882610b44565b98975050505050505050565b33610490610518565b6001600160a01b0316146104bf5760405162461bcd60e51b81526004016104b6906124d1565b60405180910390fd5b6104c96000610bfd565b565b6003546104f09061ffff80821691620100008104821691600160201b90910416610c4d565b6003805463ffffffff19166201000061ffff9384160261ffff19161792909116919091179055565b6000546001600160a01b031690565b60008183111561056c5760405162461bcd60e51b815260206004820152601060248201526f4d69736f72646572656420646174657360801b60448201526064016104b6565b600061057884846106c1565b90506000610586858561259a565b9050600061059382610a5c565b905060006105a082610a45565b90506105ac8482610e43565b979650505050505050565b336105c0610518565b6001600160a01b0316146105e65760405162461bcd60e51b81526004016104b6906124d1565b60028190556040518181527f19ede2e51d1531988bc60742b8bb97134e9f3a1ec45cf7cf4ea09953f80b2ac59060200160405180910390a150565b3361062a610518565b6001600160a01b0316146106505760405162461bcd60e51b81526004016104b6906124d1565b6001600160a01b0381166106b55760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084016104b6565b6106be81610bfd565b50565b6000818314156106d35750600061038a565b60006106dd61078a565b905060006106ea85610942565b905060006106f785610942565b60035490915060009061071b908590859061ffff8082169162010000900416610ea2565b60035490915060009061073f908690859061ffff8082169162010000900416610ea2565b90508181111561077c5761077061076b676765c793fa10079d601b1b610765848661123c565b90611310565b61131c565b9550505050505061038a565b60009550505050505061038a565b600061079542610942565b905090565b6000806107a7848461138a565b85600082519101805460208401516040909401511515600160f81b026001600160f81b036001600160d81b03909516600160201b026001600160f81b031990921663ffffffff9094169390931717929092161790555060019050805b935093915050565b600080600061081c61034886610934565b9050600061082c61034886610934565b905060008263ffffffff1611801561084a575060008163ffffffff16115b61087e5760405162461bcd60e51b8152602060048201526005602482015264554e49545360d81b60448201526064016104b6565b63ffffffff808316600090815260016020908152604080832093851683529290522054156108d05763ffffffff808316600090815260016020908152604080832093851683529290522054935061092b565b8063ffffffff166108df61078a565b63ffffffff161061090b576109008263ffffffff168263ffffffff166106c1565b93506001925061092b565b6109288263ffffffff1661091d61078a565b63ffffffff166106c1565b93505b50509250929050565b670de0b6b3a7640000900490565b600063ffffffff8211156109825760405162461bcd60e51b815260206004820152600760248201526654534f464c4f5760c81b60448201526064016104b6565b5090565b6000808361ffff16116109bf5760405162461bcd60e51b81526020600482015260016024820152604960f81b60448201526064016104b6565b8261ffff168261ffff16116109d5575081610a3e565b825b8261ffff168161ffff161015610a39576001858261ffff1661ffff8110610a0e57634e487b7160e01b600052603260045260246000fd5b01805463ffffffff191663ffffffff9290921691909117905580610a31816125ce565b9150506109d7565b508190505b9392505050565b600061038a826a1a1601fc4ea7109e000000611402565b60007812725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21821115610a9b57604051633492ffd960e01b8152600481018390526024016104b6565b50670de0b6b3a76400000290565b600082610ace578115610abd576000610ac7565b670de0b6b3a76400005b905061038a565b610a3e610ae3610add85611417565b846114c7565b6114d3565b600080610af9633b9aca0084612558565b905082610b0a633b9aca0083612544565b1460405180604001604052806002815260200161068760f31b815250906103885760405162461bcd60e51b81526004016104b6919061247e565b6000821580610b51575081155b15610b5e5750600061038a565b81610b756002676765c793fa10079d601b1b612544565b610b819060001961259a565b610b8b9190612544565b83111560405180604001604052806002815260200161068760f31b81525090610bc75760405162461bcd60e51b81526004016104b6919061247e565b50676765c793fa10079d601b1b610bdf600282612544565b610be98486612558565b610bf3919061252c565b610a3e9190612544565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600080600060048661ffff1661ffff8110610c7857634e487b7160e01b600052603260045260246000fd5b60408051606081018252929091015463ffffffff811683526001600160d81b03600160201b820416602084015260ff600160f81b9091041615159082015290506000610cc261078a565b9050816000015163ffffffff166002548263ffffffff16610ce3919061259a565b1015610cf6578686935093505050610803565b620100035460405163d15e005360e01b81526000916001600160a01b03169063d15e005390610d49907f00000000000000000000000000000000000000000000000000000000000000009060040161246a565b60206040518083038186803b158015610d6157600080fd5b505afa158015610d75573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d9991906123d4565b905080610db95760405163bd89c5af60e01b815260040160405180910390fd5b7f43bca372be3e74f9c236cf54450ec01eb2d011690a24a7402ddff4e41267e447610de2611519565b6040805191825230602083015261ffff8b81168383015263ffffffff86166060840152608083018590528a811660a0840152891660c0830152519081900360e00190a1610e3460048984848b8b611524565b94509450505050935093915050565b600082610e525750600061038a565b6000610e66670de0b6b3a764000084611402565b90506000610e85610e7f86670de0b6b3a764000061252c565b83610aa9565b9050610e99670de0b6b3a76400008261259a565b95945050505050565b60008363ffffffff168563ffffffff161015610ee65760405162461bcd60e51b81526020600482015260036024820152624f4f4f60e81b60448201526064016104b6565b8363ffffffff168563ffffffff16141561103657610f0261233f565b60048461ffff1661ffff8110610f2857634e487b7160e01b600052603260045260246000fd5b60408051606081018252919092015463ffffffff808216808452600160201b83046001600160d81b03166020850152600160f81b90920460ff161515938301939093529092509087161461101f57620100035460405163d15e005360e01b81526001600160a01b039091169063d15e005390610fc8907f00000000000000000000000000000000000000000000000000000000000000009060040161246a565b60206040518083038186803b158015610fe057600080fd5b505afa158015610ff4573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061101891906123d4565b9150611030565b80602001516001600160d81b031691505b50611234565b620100035460405163d15e005360e01b81526000916001600160a01b03169063d15e005390611089907f00000000000000000000000000000000000000000000000000000000000000009060040161246a565b60206040518083038186803b1580156110a157600080fd5b505afa1580156110b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110d991906123d4565b90506000806110ec600488858989611688565b91509150816000015163ffffffff168763ffffffff16141561111d5781602001516001600160d81b03169350611230565b805163ffffffff888116911614156111445780602001516001600160d81b03169350611230565b600082602001516001600160d81b031682602001516001600160d81b031611156111ac57600061119d676765c793fa10079d601b1b61076585602001516001600160d81b031687602001516001600160d81b031661123c565b90506111a88161131c565b9150505b60006111dd670de0b6b3a7640000855185516111c891906125b1565b63ffffffff166111d89190612558565b610a45565b905060006111eb8383610e43565b905061122a85602001516001600160d81b03168261120e670de0b6b3a764000090565b885161121a908f6125b1565b63ffffffff166101bc9190612558565b96505050505b5050505b949350505050565b604080518082019091526002815261035360f41b6020820152600090826112765760405162461bcd60e51b81526004016104b6919061247e565b506000611284600284612544565b9050676765c793fa10079d601b1b61129e8260001961259a565b6112a89190612544565b84111560405180604001604052806002815260200161068760f31b815250906112e45760405162461bcd60e51b81526004016104b6919061247e565b5082816112fc676765c793fa10079d601b1b87612558565b611306919061252c565b6112349190612544565b6000610a3e828461259a565b60008061132e6002633b9aca00612544565b9050600061133c848361252c565b90508181101560405180604001604052806002815260200161343960f01b8152509061137b5760405162461bcd60e51b81526004016104b6919061247e565b50611234633b9aca0082612544565b61139261233f565b6001600160d81b038211156113d25760405162461bcd60e51b81526004016104b6906020808252600490820152631f19189b60e11b604082015260600190565b506040805160608101825263ffffffff9390931683526001600160d81b0391909116602083015260019082015290565b6000610a3e83670de0b6b3a764000084611856565b6000670de0b6b3a764000082101561144557604051633621413760e21b8152600481018390526024016104b6565b600061145a670de0b6b3a76400008404611932565b670de0b6b3a7640000808202935090915083821c9081141561147d575050919050565b6706f05b59d3b200005b80156114bf57670de0b6b3a7640000828002049150671bc16d674ec8000082106114b7579283019260019190911c905b60011c611487565b505050919050565b6000610a3e8383611a15565b6000680a688906bd8b000000821061150157604051634a4f26f160e01b8152600481018390526024016104b6565b670de0b6b3a7640000604083901b04610a3e81611ad7565b600061079542610a5c565b6000806000888861ffff1661ffff811061154e57634e487b7160e01b600052603260045260246000fd5b60408051606081018252919092015463ffffffff808216808452600160201b83046001600160d81b03166020850152600160f81b90920460ff1615159383019390935290925090881614156115a9578785925092505061167d565b8461ffff168461ffff161180156115d157506115c6600186612577565b61ffff168861ffff16145b156115de578391506115e2565b8491505b816115ee896001612506565b6115f891906125f0565b9250611604878761138a565b898461ffff1661ffff811061162957634e487b7160e01b600052603260045260246000fd5b82519101805460208401516040909401511515600160f81b026001600160f81b036001600160d81b03909516600160201b026001600160f81b031990921663ffffffff909416939093171792909216179055505b965096945050505050565b61169061233f565b61169861233f565b868461ffff1661ffff81106116bd57634e487b7160e01b600052603260045260246000fd5b60408051606081018252919092015463ffffffff808216808452600160201b83046001600160d81b03166020850152600160f81b90920460ff161515938301939093529093509087161061173c578563ffffffff16826000015163ffffffff1614156117285761184c565b81611733878761138a565b9150915061184c565b8683611749866001612506565b61175391906125f0565b61ffff1661ffff811061177657634e487b7160e01b600052603260045260246000fd5b60408051606081018252919092015463ffffffff81168252600160201b81046001600160d81b03166020830152600160f81b900460ff16151591810182905292506117fb5760408051606081018252885463ffffffff81168252600160201b81046001600160d81b03166020830152600160f81b900460ff1615159181019190915291505b815163ffffffff8088169116111561183b5760405162461bcd60e51b815260206004820152600360248201526213d31160ea1b60448201526064016104b6565b61184787878686612169565b915091505b9550959350505050565b60008080600019858709858702925082811083820303915050806000141561189f5783828161189557634e487b7160e01b600052601260045260246000fd5b0492505050610a3e565b8381106118c957604051631dcf306360e21b815260048101829052602481018590526044016104b6565b60008486880960026001871981018816978890046003810283188082028403028082028403028082028403028082028403028082028403029081029092039091026000889003889004909101858311909403939093029303949094049190911702949350505050565b6000600160801b821061195257608091821c9161194f908261252c565b90505b600160401b821061197057604091821c9161196d908261252c565b90505b600160201b821061198e57602091821c9161198b908261252c565b90505b6201000082106119ab57601091821c916119a8908261252c565b90505b61010082106119c757600891821c916119c4908261252c565b90505b601082106119e257600491821c916119df908261252c565b90505b600482106119fd57600291821c916119fa908261252c565b90505b60028210611a105761038a60018261252c565b919050565b60008080600019848609848602925082811083820303915050670de0b6b3a76400008110611a595760405163698d9a0160e11b8152600481018290526024016104b6565b600080670de0b6b3a76400008688099150506706f05b59d3b1ffff811182611a935780670de0b6b3a764000085040194505050505061038a565b620400008285030493909111909103600160ee1b02919091177faccb18165bd6fe31ae1cf318dc5b51eee0e1ba569b88cd74c1773b91fac106690201905092915050565b600160bf1b6001603f1b821615611af75768016a09e667f3bcc9090260401c5b6001603e1b821615611b12576801306fe0a31b7152df0260401c5b6001603d1b821615611b2d576801172b83c7d517adce0260401c5b6001603c1b821615611b485768010b5586cf9890f62a0260401c5b6001603b1b821615611b63576801059b0d31585743ae0260401c5b6001603a1b821615611b7e57680102c9a3e778060ee70260401c5b600160391b821615611b995768010163da9fb33356d80260401c5b600160381b821615611bb457680100b1afa5abcbed610260401c5b600160371b821615611bcf5768010058c86da1c09ea20260401c5b600160361b821615611bea576801002c605e2e8cec500260401c5b600160351b821615611c0557680100162f3904051fa10260401c5b600160341b821615611c20576801000b175effdc76ba0260401c5b600160331b821615611c3b57680100058ba01fb9f96d0260401c5b600160321b821615611c565768010002c5cc37da94920260401c5b600160311b821615611c71576801000162e525ee05470260401c5b600160301b821615611c8c5768010000b17255775c040260401c5b6001602f1b821615611ca7576801000058b91b5bc9ae0260401c5b6001602e1b821615611cc257680100002c5c89d5ec6d0260401c5b6001602d1b821615611cdd5768010000162e43f4f8310260401c5b6001602c1b821615611cf857680100000b1721bcfc9a0260401c5b6001602b1b821615611d135768010000058b90cf1e6e0260401c5b6001602a1b821615611d2e576801000002c5c863b73f0260401c5b600160291b821615611d4957680100000162e430e5a20260401c5b600160281b821615611d64576801000000b1721835510260401c5b600160271b821615611d7f57680100000058b90c0b490260401c5b600160261b821615611d9a5768010000002c5c8601cc0260401c5b600160251b821615611db5576801000000162e42fff00260401c5b600160241b821615611dd05768010000000b17217fbb0260401c5b600160231b821615611deb576801000000058b90bfce0260401c5b600160221b821615611e0657680100000002c5c85fe30260401c5b600160211b821615611e215768010000000162e42ff10260401c5b600160201b821615611e3c57680100000000b17217f80260401c5b6380000000821615611e575768010000000058b90bfc0260401c5b6340000000821615611e72576801000000002c5c85fe0260401c5b6320000000821615611e8d57680100000000162e42ff0260401c5b6310000000821615611ea8576801000000000b17217f0260401c5b6308000000821615611ec357680100000000058b90c00260401c5b6304000000821615611ede5768010000000002c5c8600260401c5b6302000000821615611ef9576801000000000162e4300260401c5b6301000000821615611f145768010000000000b172180260401c5b62800000821615611f2e576801000000000058b90c0260401c5b62400000821615611f4857680100000000002c5c860260401c5b62200000821615611f625768010000000000162e430260401c5b62100000821615611f7c57680100000000000b17210260401c5b62080000821615611f965768010000000000058b910260401c5b62040000821615611fb0576801000000000002c5c80260401c5b62020000821615611fca57680100000000000162e40260401c5b62010000821615611fe35761b172600160401b010260401c5b618000821615611ffb576158b9600160401b010260401c5b61400082161561201357612c5d600160401b010260401c5b61200082161561202b5761162e600160401b010260401c5b61100082161561204357610b17600160401b010260401c5b61080082161561205b5761058c600160401b010260401c5b610400821615612073576102c6600160401b010260401c5b61020082161561208b57610163600160401b010260401c5b6101008216156120a25760b1600160401b010260401c5b60808216156120b8576059600160401b010260401c5b60408216156120ce57602c600160401b010260401c5b60208216156120e4576016600160401b010260401c5b60108216156120fa57600b600160401b010260401c5b6008821615612110576006600160401b010260401c5b6004821615612126576003600160401b010260401c5b600282161561213c576001600160401b010260401c5b6001821615612152576001600160401b010260401c5b670de0b6b3a76400000260409190911c60bf031c90565b61217161233f565b61217961233f565b600083612187866001612506565b61219191906125f0565b61ffff169050600060018561ffff16836121ab919061252c565b6121b5919061259a565b905060005b60026121c6838561252c565b6121d09190612544565b9050886121e161ffff881683612611565b61ffff811061220057634e487b7160e01b600052603260045260246000fd5b60408051606081018252919092015463ffffffff81168252600160201b81046001600160d81b03166020830152600160f81b900460ff16151591810182905295506122575761225081600161252c565b92506121ba565b8861ffff871661226883600161252c565b6122729190612611565b61ffff811061229157634e487b7160e01b600052603260045260246000fd5b60408051606081018252919092015463ffffffff8082168352600160201b82046001600160d81b03166020840152600160f81b90910460ff16151592820192909252865190955089821691161180159081906122fd5750846000015163ffffffff168963ffffffff1611155b156123085750612333565b8061231f5761231860018361259a565b925061232d565b61232a82600161252c565b93505b506121ba565b50505094509492505050565b604080516060810182526000808252602082018190529181019190915290565b803563ffffffff81168114611a1057600080fd5b600060208284031215612384578081fd5b81356001600160a01b0381168114610a3e578182fd5b6000602082840312156123ab578081fd5b813561ffff81168114610a3e578182fd5b6000602082840312156123cd578081fd5b5035919050565b6000602082840312156123e5578081fd5b5051919050565b600080604083850312156123fe578081fd5b50508035926020909101359150565b600080600060608486031215612421578081fd5b505081359360208301359350604090920135919050565b6000806040838503121561244a578182fd5b6124538361235f565b91506124616020840161235f565b90509250929050565b6001600160a01b0391909116815260200190565b6000602080835283518082850152825b818110156124aa5785810183015185820160400152820161248e565b818111156124bb5783604083870101525b50601f01601f1916929092016040019392505050565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b600061ffff80831681851680830382111561252357612523612625565b01949350505050565b6000821982111561253f5761253f612625565b500190565b6000826125535761255361263b565b500490565b600081600019048311821515161561257257612572612625565b500290565b600061ffff8381169083168181101561259257612592612625565b039392505050565b6000828210156125ac576125ac612625565b500390565b600063ffffffff8381169083168181101561259257612592612625565b600061ffff808316818114156125e6576125e6612625565b6001019392505050565b600061ffff808416806126055761260561263b565b92169190910692915050565b6000826126205761262061263b565b500690565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fdfea26469706673582212202b6cc9586787797b631964bed55d35dc1e4b55037e35c0fe79d0f2fc657ba2c564736f6c63430008040033",
  "devdoc": {
    "errors": {
      "AavePoolGetReserveNormalizedIncomeReturnedZero()": [
        {
          "details": "getReserveNormalizedIncome() returned zero for underlying asset. Oracle only supports active Aave-V2 assets."
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "getApyFromTo(uint256,uint256)": {
        "details": "Reverts if we have no data point for either timestamp",
        "params": {
          "from": "The timestamp of the start of the period, in seconds",
          "to": "The timestamp of the end of the period, in seconds"
        }
      },
      "getRateFromTo(uint256,uint256)": {
        "details": "Reverts if we have no data point for either timestamp",
        "params": {
          "_from": "The timestamp of the start of the period, in seconds",
          "_to": "The timestamp of the end of the period, in seconds"
        },
        "returns": {
          "_0": "The \"floating rate\" expressed in Wad, e.g. 4% is encoded as 0.04*10**18 = 4*10**16"
        }
      },
      "increaseObservationCardinalityNext(uint16)": {
        "details": "This method is no-op if the RateOracle already has an observationCardinalityNext greater than or equal to the input observationCardinalityNext.",
        "params": {
          "rateCardinalityNext": "The desired minimum number of observations for the pool to store"
        }
      },
      "interpolateRateValue(uint256,uint256,uint256)": {
        "details": "Given [beforeOrAt, atOrAfter] where the timestamp for which the counterfactual is calculated is within that range (but does not touch any of the bounds)We can calculate the apy for [beforeOrAt, atOrAfter] --> refer to this value as apyFromBeforeOrAtToAtOrAfterThen we want a counterfactual rate value which results in apy_before_after if the apy is calculated between [beforeOrAt, timestampForCounterfactual]Hence (1+rateValueWei/beforeOrAtRateValueWei)^(1/timeInYears) = apyFromBeforeOrAtToAtOrAfterHence rateValueWei = beforeOrAtRateValueWei * (1+apyFromBeforeOrAtToAtOrAfter)^timeInYears - 1)",
        "params": {
          "apyFromBeforeOrAtToAtOrAfterWad": "Apy in the period between the timestamp of the beforeOrAt Rate and the atOrAfter Rate",
          "beforeOrAtRateValueRay": "Rate Value (in ray) before the timestamp for which we want to calculate the counterfactual rate value",
          "timeDeltaBeforeOrAtToQueriedTimeWad": "Time Delta (in wei seconds) between the timestamp of the beforeOrAt Rate and the atOrAfter Rate"
        },
        "returns": {
          "rateValueRay": "Counterfactual (interpolated) rate value in ray"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "setMinSecondsSinceLastUpdate(uint256)": {
        "details": "Can only be set by the Factory Owner"
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      },
      "variableFactor(uint256,uint256)": {
        "details": "If the current block timestamp is beyond the maturity of the AMM, then the variableFactor is getRateFromTo(termStartTimestamp, termEndTimestamp). Term end timestamps are cached for quick retrieval later.If the current block timestamp is before the maturity of the AMM, then the variableFactor is getRateFromTo(termStartTimestamp,Time.blockTimestampScaled());",
        "returns": {
          "resultWad": "The variable factor"
        }
      },
      "variableFactorNoCache(uint256,uint256)": {
        "details": "If the current block timestamp is beyond the maturity of the AMM, then the variableFactor is getRateFromTo(termStartTimestamp, termEndTimestamp). No caching takes place.If the current block timestamp is before the maturity of the AMM, then the variableFactor is getRateFromTo(termStartTimestamp,Time.blockTimestampScaled());",
        "returns": {
          "resultWad": "The variable factor"
        }
      }
    },
    "stateVariables": {
      "aaveLendingPool": {
        "return": "Address of the Aave Lending Pool",
        "returns": {
          "_0": "Address of the Aave Lending Pool"
        }
      },
      "underlyingYieldBearingProtocolID": {
        "return": "yieldBearingProtocolID unique id of the underlying yield bearing protocol",
        "returns": {
          "_0": "yieldBearingProtocolID unique id of the underlying yield bearing protocol"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "PRBMathUD60x18__Exp2InputTooBig(uint256)": [
        {
          "notice": "Emitted when the input is greater than 192."
        }
      ],
      "PRBMathUD60x18__FromUintOverflow(uint256)": [
        {
          "notice": "Emitted when converting a basic integer to the fixed-point format format overflows UD60x18."
        }
      ],
      "PRBMathUD60x18__LogInputTooSmall(uint256)": [
        {
          "notice": "Emitted when the input is less than 1."
        }
      ],
      "PRBMath__MulDivFixedPointOverflow(uint256)": [
        {
          "notice": "Emitted when the result overflows uint256."
        }
      ],
      "PRBMath__MulDivOverflow(uint256,uint256)": [
        {
          "notice": "Emitted when the result overflows uint256."
        }
      ]
    },
    "events": {
      "IncreaserateCardinalityNext(uint16,uint16)": {
        "notice": "Emitted by the rate oracle for increases to the number of observations that can be stored"
      }
    },
    "kind": "user",
    "methods": {
      "aaveLendingPool()": {
        "notice": "Gets the address of the Aave Lending Pool"
      },
      "getApyFromTo(uint256,uint256)": {
        "notice": "Calculates the observed APY returned by the rate oracle in a given period"
      },
      "getRateFromTo(uint256,uint256)": {
        "notice": "Calculates the observed interest returned by the underlying in a given period"
      },
      "increaseObservationCardinalityNext(uint16)": {
        "notice": "Increase the maximum number of rates observations that this RateOracle will store"
      },
      "interpolateRateValue(uint256,uint256,uint256)": {
        "notice": "Calculates the interpolated (counterfactual) rate value"
      },
      "observations(uint256)": {
        "notice": "the observations tracked over time by this oracle"
      },
      "setMinSecondsSinceLastUpdate(uint256)": {
        "notice": "Sets minSecondsSinceLastUpdate: The minimum number of seconds in wei that need to pass since the last update to the rates array"
      },
      "settlementRateCache(uint32,uint32)": {
        "notice": "a cache of settlement rates for interest rate swaps associated with this rate oracle, indexed by start time and then end time"
      },
      "underlying()": {
        "notice": "Gets the address of the underlying token of the RateOracle"
      },
      "underlyingYieldBearingProtocolID()": {
        "notice": "unique ID of the underlying yield bearing protocol (e.g. Aave v2 has id 1)"
      },
      "variableFactor(uint256,uint256)": {
        "notice": "Gets the variable factor between termStartTimestamp and termEndTimestamp"
      },
      "variableFactorNoCache(uint256,uint256)": {
        "notice": "Gets the variable factor between termStartTimestamp and termEndTimestamp"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 601,
        "contract": "contracts/rate_oracles/AaveRateOracle.sol:AaveRateOracle",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 11408,
        "contract": "contracts/rate_oracles/AaveRateOracle.sol:AaveRateOracle",
        "label": "settlementRateCache",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_uint32,t_mapping(t_uint32,t_uint256))"
      },
      {
        "astId": 11426,
        "contract": "contracts/rate_oracles/AaveRateOracle.sol:AaveRateOracle",
        "label": "minSecondsSinceLastUpdate",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 11429,
        "contract": "contracts/rate_oracles/AaveRateOracle.sol:AaveRateOracle",
        "label": "oracleVars",
        "offset": 0,
        "slot": "3",
        "type": "t_struct(OracleVars)11418_storage"
      },
      {
        "astId": 11435,
        "contract": "contracts/rate_oracles/AaveRateOracle.sol:AaveRateOracle",
        "label": "observations",
        "offset": 0,
        "slot": "4",
        "type": "t_array(t_struct(Observation)11802_storage)65535_storage"
      },
      {
        "astId": 10907,
        "contract": "contracts/rate_oracles/AaveRateOracle.sol:AaveRateOracle",
        "label": "aaveLendingPool",
        "offset": 0,
        "slot": "65539",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_struct(Observation)11802_storage)65535_storage": {
        "base": "t_struct(Observation)11802_storage",
        "encoding": "inplace",
        "label": "struct OracleBuffer.Observation[65535]",
        "numberOfBytes": "2097120"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_uint32,t_mapping(t_uint32,t_uint256))": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => mapping(uint32 => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint32,t_uint256)"
      },
      "t_mapping(t_uint32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(Observation)11802_storage": {
        "encoding": "inplace",
        "label": "struct OracleBuffer.Observation",
        "members": [
          {
            "astId": 11796,
            "contract": "contracts/rate_oracles/AaveRateOracle.sol:AaveRateOracle",
            "label": "blockTimestamp",
            "offset": 0,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 11799,
            "contract": "contracts/rate_oracles/AaveRateOracle.sol:AaveRateOracle",
            "label": "observedValue",
            "offset": 4,
            "slot": "0",
            "type": "t_uint216"
          },
          {
            "astId": 11801,
            "contract": "contracts/rate_oracles/AaveRateOracle.sol:AaveRateOracle",
            "label": "initialized",
            "offset": 31,
            "slot": "0",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(OracleVars)11418_storage": {
        "encoding": "inplace",
        "label": "struct BaseRateOracle.OracleVars",
        "members": [
          {
            "astId": 11411,
            "contract": "contracts/rate_oracles/AaveRateOracle.sol:AaveRateOracle",
            "label": "rateIndex",
            "offset": 0,
            "slot": "0",
            "type": "t_uint16"
          },
          {
            "astId": 11414,
            "contract": "contracts/rate_oracles/AaveRateOracle.sol:AaveRateOracle",
            "label": "rateCardinality",
            "offset": 2,
            "slot": "0",
            "type": "t_uint16"
          },
          {
            "astId": 11417,
            "contract": "contracts/rate_oracles/AaveRateOracle.sol:AaveRateOracle",
            "label": "rateCardinalityNext",
            "offset": 4,
            "slot": "0",
            "type": "t_uint16"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint16": {
        "encoding": "inplace",
        "label": "uint16",
        "numberOfBytes": "2"
      },
      "t_uint216": {
        "encoding": "inplace",
        "label": "uint216",
        "numberOfBytes": "27"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      }
    }
  }
}